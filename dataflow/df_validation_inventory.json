{
	"name": "df_validation_inventory",
	"properties": {
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "INVENTORY_UX",
						"type": "DatasetReference"
					},
					"name": "inventoryuxstaging",
					"description": "inventory ux staging"
				},
				{
					"dataset": {
						"referenceName": "locations",
						"type": "DatasetReference"
					},
					"name": "locations"
				},
				{
					"dataset": {
						"referenceName": "item",
						"type": "DatasetReference"
					},
					"name": "item",
					"description": "Import data from items"
				},
				{
					"dataset": {
						"referenceName": "inventory",
						"type": "DatasetReference"
					},
					"name": "inventory",
					"description": "Import data from inventory"
				},
				{
					"dataset": {
						"referenceName": "importhistory",
						"type": "DatasetReference"
					},
					"name": "importhistory"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "INVENTORY_MAIN_UX",
						"type": "DatasetReference"
					},
					"name": "ValidInventoryDataLoad"
				},
				{
					"dataset": {
						"referenceName": "FailedInventoryRows",
						"type": "DatasetReference"
					},
					"name": "failedrows"
				}
			],
			"transformations": [
				{
					"name": "validations"
				},
				{
					"name": "reverserename"
				},
				{
					"name": "deriveerrors"
				},
				{
					"name": "selectmainfields"
				},
				{
					"name": "aggregateerrors"
				},
				{
					"name": "joinaggregaterror"
				},
				{
					"name": "splitvalidatedrows"
				},
				{
					"name": "derivedfilename"
				},
				{
					"name": "newchangenameforassert"
				},
				{
					"name": "joinlocations"
				},
				{
					"name": "selectlocations"
				},
				{
					"name": "selectitem"
				},
				{
					"name": "derivepresence"
				},
				{
					"name": "joinitem"
				},
				{
					"name": "selectexistrecordcheck"
				},
				{
					"name": "joinexistrecordchech"
				},
				{
					"name": "selectcolsforassert"
				},
				{
					"name": "joininventory"
				},
				{
					"name": "derivestocktypeid"
				},
				{
					"name": "numericfieldintegritycheck"
				},
				{
					"name": "appendrecordid"
				},
				{
					"name": "detectduplicates"
				},
				{
					"name": "filtertransactionrecord"
				},
				{
					"name": "selectimporthistory"
				},
				{
					"name": "join1"
				},
				{
					"name": "joinitemtransbuorg"
				},
				{
					"name": "joininventorytransbuorg"
				},
				{
					"name": "filterrowswithvalidationerrors"
				},
				{
					"name": "removeemptyrows"
				}
			],
			"scriptLines": [
				"parameters{",
				"     file_path as string ('/DEV/Upload/Inventory/211.xlsx'),",
				"     transaction_id as string ('211')",
				"}",
				"source(output(",
				"          {Item ID} as string,",
				"          {Location ID} as string,",
				"          {Stock Date} as string,",
				"          {Stock Quantity} as string,",
				"          {Reserved Quantity} as string,",
				"          {Available Quantity} as string,",
				"          {On Order ID} as string,",
				"          {On Order Due Date} as string,",
				"          {On Order Supplier Shipping Date} as string,",
				"          {On Order Promised Delivery Date} as string",
				"     ),",
				"     allowSchemaDrift: false,",
				"     validateSchema: true,",
				"     ignoreNoFilesFound: false,",
				"     rowUrlColumn: 'file_name',",
				"     wildcardPaths:[($file_path)]) ~> inventoryuxstaging",
				"source(output(",
				"          id as integer,",
				"          location_code as string,",
				"          name as string,",
				"          address as string,",
				"          city as string,",
				"          state as string,",
				"          zip as string,",
				"          country as string,",
				"          sub_type as string,",
				"          delivery_partners as string,",
				"          throughput as float,",
				"          capacity as float,",
				"          special_information as string,",
				"          holding_cost as float,",
				"          inbound_handling_cost as float,",
				"          outbound_handling_cost as float,",
				"          longitude as double,",
				"          latitude as double,",
				"          updated_date as date,",
				"          created_date as date,",
				"          status as string,",
				"          inbound_processing_time as decimal(0,0),",
				"          outbound_processing_time as decimal(0,0),",
				"          type as integer,",
				"          transfer_inbound_processing_time as double,",
				"          transfer_outbound_processing_time as double,",
				"          transfer_inbound_handling_cost as double,",
				"          transfer_outbound_handling_cost as double,",
				"          tenant_id as string,",
				"          organization_id as string,",
				"          business_unit_id as string,",
				"          units_per_hour as float,",
				"          max_fte_regular_hours as float,",
				"          min_fte_regular_hours as float,",
				"          max_temp_regular_hours as float,",
				"          min_temp_regular_hours as float,",
				"          max_fte_overtime_hours as float,",
				"          max_temp_overtime_hours as float,",
				"          regular_fte_wage as float,",
				"          regular_temp_wage as float,",
				"          overtime_fte_wage as float,",
				"          overtime_temp_wage as float,",
				"          fte_staff_count as integer,",
				"          temp_staff_count as integer",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> locations",
				"source(output(",
				"          id as integer,",
				"          item_code as string,",
				"          description as string,",
				"          short_description as string,",
				"          department as string,",
				"          sub_department as string,",
				"          class as string,",
				"          sub_class as string,",
				"          style as string,",
				"          color as string,",
				"          size as string,",
				"          size_second as string,",
				"          sku_lifecycle_status as integer,",
				"          product_division as string,",
				"          product_family as string,",
				"          measurement_unit as string,",
				"          unit_cost as float,",
				"          unit_volume as float,",
				"          unit_weight as float,",
				"          unit_cube as float,",
				"          units_per_pallet as float,",
				"          uom_conversion_factor as float,",
				"          distribution_channel as string,",
				"          item_handling_type as string,",
				"          item_unit_price as float,",
				"          minimum_sales_qty as float,",
				"          birth_year as short,",
				"          birth_month as short,",
				"          expiration_year as short,",
				"          expiration_month as short,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          business_unit_id as string,",
				"          organization_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> item",
				"source(output(",
				"          id as integer,",
				"          item_id as integer,",
				"          location_id as integer,",
				"          on_hand_stock_date as date,",
				"          on_hand_stock_quantity as float,",
				"          reserved_on_hold_stock_ as float,",
				"          available_stock as float,",
				"          lot_id as string,",
				"          on_order_due_date as date,",
				"          on_order_quantity_ as float,",
				"          purchase_order_status as float,",
				"          on_order_supplier_shipping_date as date,",
				"          on_order_promised_delivery_date as date,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          tenant_id as string,",
				"          organization_id as string,",
				"          business_unit_id as string,",
				"          stock_type_id as integer",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> inventory",
				"source(output(",
				"          id as integer,",
				"          original_file_name as string,",
				"          user_id as string,",
				"          status_enum_value_id as integer,",
				"          processed_time as timestamp,",
				"          errors as string,",
				"          business_unit_id as string,",
				"          organization_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> importhistory",
				"removeemptyrows, selectlocations, selectitem assert(expectExists(selectcolsforassert@Location_ID == location_code, false, 'locationexist', null, 'Location ID Not Found In Database'),",
				"     expectExists(selectcolsforassert@Item_ID == item_code, false, 'itemexists', null, 'Item Specified Does Not Exists In Database'),",
				"     expectTrue(isNull(presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
				"     expectTrue(numericintegrity, false, 'numericfieldintegrity', null, 'Non numerical values exist in numerical fields'),",
				"     expectTrue(nonduplicatedrow, false, 'duplicated', null, 'Duplicate records found in upload')) ~> validations",
				"validations select(mapColumn(",
				"          {Item ID} = selectcolsforassert@Item_ID,",
				"          {Location ID} = selectcolsforassert@Location_ID,",
				"          {Stock Date},",
				"          {Stock Quantity},",
				"          {Reserved Quantity},",
				"          {Available Quantity},",
				"          {On Order ID},",
				"          {On Order Due Date},",
				"          {On Order Supplier Shipping Date},",
				"          {On Order Promised Delivery Date},",
				"          file_name,",
				"          presence,",
				"          record_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> reverserename",
				"reverserename derive(validation_errors = assertErrorMessages(),",
				"          transaction_id = toInteger($transaction_id),",
				"          sink_file_name = replace(file_name,'.xlsx','.txt')) ~> deriveerrors",
				"joinaggregaterror select(mapColumn(",
				"          {Item ID},",
				"          {Location ID},",
				"          {Stock Date},",
				"          {Stock Quantity},",
				"          {Reserved Quantity},",
				"          {Available Quantity},",
				"          {On Order ID},",
				"          {On Order Due Date},",
				"          {On Order Supplier Shipping Date},",
				"          {On Order Promised Delivery Date},",
				"          file_name = reverserename@file_name,",
				"          presence,",
				"          validation_errors,",
				"          transaction_id,",
				"          sink_file_name,",
				"          file_name = aggregateerrors@file_name,",
				"          errors_count,",
				"          record_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectmainfields",
				"deriveerrors aggregate(groupBy(file_name),",
				"     errors_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
				"deriveerrors, aggregateerrors join(reverserename@file_name == aggregateerrors@file_name,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinaggregaterror",
				"selectmainfields split(errors_count==0,",
				"     disjoint: false) ~> splitvalidatedrows@(validrows, validationfailedrows)",
				"filterrowswithvalidationerrors derive(failed_file_name = replace(replace($file_path,'/Upload/','/FailedTransactions/'),'.xlsx','.json'),",
				"          type = 'error',",
				"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedfilename",
				"numericfieldintegritycheck select(mapColumn(",
				"          Item_ID = {Item ID},",
				"          Location_ID = {Location ID},",
				"          {Stock Date},",
				"          {Stock Quantity},",
				"          {Reserved Quantity},",
				"          {Available Quantity},",
				"          {On Order ID},",
				"          {On Order Due Date},",
				"          {On Order Supplier Shipping Date},",
				"          {On Order Promised Delivery Date},",
				"          file_name,",
				"          numericintegrity,",
				"          record_id,",
				"          nonduplicatedrow",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> newchangenameforassert",
				"derivestocktypeid, selectlocations join({Location ID} == location_code,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinlocations",
				"join1 select(mapColumn(",
				"          location_id = locations@id,",
				"          location_code",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectlocations",
				"joinitemtransbuorg select(mapColumn(",
				"          item_id = item@id,",
				"          item_code",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectitem",
				"joininventorytransbuorg derive(presence = 'true') ~> derivepresence",
				"joinlocations, selectitem join({Item ID} == item_code,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinitem",
				"joininventory select(mapColumn(",
				"          {Item ID},",
				"          {Location ID},",
				"          {Stock Date},",
				"          {Stock Quantity},",
				"          {Reserved Quantity},",
				"          {Available Quantity},",
				"          {On Order ID},",
				"          {On Order Due Date},",
				"          {On Order Supplier Shipping Date},",
				"          {On Order Promised Delivery Date},",
				"          file_name,",
				"          presence,",
				"          record_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectexistrecordcheck",
				"newchangenameforassert, selectexistrecordcheck join(newchangenameforassert@record_id == selectexistrecordcheck@record_id,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinexistrecordchech",
				"joinexistrecordchech select(mapColumn(",
				"          Item_ID,",
				"          Location_ID,",
				"          {Stock Date} = newchangenameforassert@{Stock Date},",
				"          {Stock Quantity} = newchangenameforassert@{Stock Quantity},",
				"          {Reserved Quantity} = newchangenameforassert@{Reserved Quantity},",
				"          {Available Quantity} = newchangenameforassert@{Available Quantity},",
				"          {On Order ID} = newchangenameforassert@{On Order ID},",
				"          {On Order Due Date} = newchangenameforassert@{On Order Due Date},",
				"          {On Order Supplier Shipping Date} = newchangenameforassert@{On Order Supplier Shipping Date},",
				"          {On Order Promised Delivery Date} = newchangenameforassert@{On Order Promised Delivery Date},",
				"          file_name = newchangenameforassert@file_name,",
				"          presence,",
				"          numericintegrity,",
				"          nonduplicatedrow,",
				"          record_id = selectexistrecordcheck@record_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectcolsforassert",
				"joinitem, derivepresence join(selectlocations@location_id == inventory@location_id",
				"     && selectitem@item_id == inventory@item_id",
				"     && derivestocktypeid@stock_type_id == inventory@stock_type_id,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joininventory",
				"appendrecordid derive(stock_type_id = 1) ~> derivestocktypeid",
				"detectduplicates derive(numericintegrity = iif(isNull({Stock Quantity}),true(),not(isNull(toFloat({Stock Quantity})))) &&  iif(isNull({Reserved Quantity}),true(),not(isNull(toFloat({Reserved Quantity})))) && iif(isNull({Available Quantity}),true(),not(isNull(toFloat({Available Quantity}))))) ~> numericfieldintegritycheck",
				"inventoryuxstaging keyGenerate(output(record_id as long),",
				"     startAt: 1L,",
				"     stepValue: 1L) ~> appendrecordid",
				"appendrecordid window(over({Item ID},",
				"          {Location ID},",
				"          {Stock Date},",
				"          {On Order Supplier Shipping Date},",
				"          {On Order Promised Delivery Date},",
				"          {On Order Due Date},",
				"          {On Order ID}),",
				"     asc(record_id, true),",
				"     nonduplicatedrow = rowNumber() == 1) ~> detectduplicates",
				"importhistory filter(id == toInteger($transaction_id)) ~> filtertransactionrecord",
				"filtertransactionrecord select(mapColumn(",
				"          id,",
				"          business_unit_id,",
				"          organization_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
				"locations, selectimporthistory join(locations@business_unit_id == selectimporthistory@business_unit_id",
				"     && locations@organization_id == selectimporthistory@organization_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> join1",
				"item, selectimporthistory join(item@business_unit_id == selectimporthistory@business_unit_id",
				"     && item@organization_id == selectimporthistory@organization_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinitemtransbuorg",
				"inventory, selectimporthistory join(inventory@business_unit_id == selectimporthistory@business_unit_id",
				"     && inventory@organization_id == selectimporthistory@organization_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joininventorytransbuorg",
				"splitvalidatedrows@validationfailedrows filter(not(isNull(validation_errors))) ~> filterrowswithvalidationerrors",
				"selectcolsforassert filter(not(isNull(Item_ID)) || not(isNull(Location_ID)) || not(isNull({Stock Date})) || not(isNull({Stock Quantity})) || not(isNull({Reserved Quantity})) || not(isNull({Available Quantity})) || not(isNull({On Order ID})) || not(isNull({On Order Due Date})) || not(isNull({On Order Supplier Shipping Date})) || not(isNull({On Order Promised Delivery Date}))) ~> removeemptyrows",
				"splitvalidatedrows@validrows sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     input(",
				"          {Item ID} as string,",
				"          {Location ID} as string,",
				"          {Stock Date} as string,",
				"          {Stock Quantity} as string,",
				"          {Reserved Quantity} as string,",
				"          {Available Quantity} as string,",
				"          {On Order ID} as string,",
				"          {On Order Due Date} as string,",
				"          {On Order Supplier Shipping Date} as string,",
				"          {On Order Promised Delivery Date} as string",
				"     ),",
				"     rowUrlColumn:'sink_file_name',",
				"     umask: 0022,",
				"     preCommands: [],",
				"     postCommands: [],",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true,",
				"     mapColumn(",
				"          {Item ID},",
				"          {Location ID},",
				"          {Stock Date},",
				"          {Stock Quantity},",
				"          {Reserved Quantity},",
				"          {Available Quantity},",
				"          {On Order ID},",
				"          {On Order Due Date},",
				"          {On Order Supplier Shipping Date},",
				"          {On Order Promised Delivery Date}",
				"     )) ~> ValidInventoryDataLoad",
				"derivedfilename sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     rowUrlColumn:'failed_file_name',",
				"     umask: 0022,",
				"     preCommands: [],",
				"     postCommands: [],",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true,",
				"     mapColumn(",
				"          type,",
				"          message",
				"     )) ~> failedrows"
			]
		}
	}
}