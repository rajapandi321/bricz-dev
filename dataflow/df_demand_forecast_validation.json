{
	"name": "df_demand_forecast_validation",
	"properties": {
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "DEMAND_FORECAST_UX_UPLOAD",
						"type": "DatasetReference"
					},
					"name": "demandforecastuxupload"
				},
				{
					"dataset": {
						"referenceName": "item",
						"type": "DatasetReference"
					},
					"name": "item"
				},
				{
					"dataset": {
						"referenceName": "locations",
						"type": "DatasetReference"
					},
					"name": "locations"
				},
				{
					"dataset": {
						"referenceName": "micro_area",
						"type": "DatasetReference"
					},
					"name": "microarea"
				},
				{
					"dataset": {
						"referenceName": "customertypes",
						"type": "DatasetReference"
					},
					"name": "customertypes"
				},
				{
					"dataset": {
						"referenceName": "fulfillment_services",
						"type": "DatasetReference"
					},
					"name": "fulfillmentservices"
				},
				{
					"dataset": {
						"referenceName": "importhistory",
						"type": "DatasetReference"
					},
					"name": "importhistory"
				},
				{
					"dataset": {
						"referenceName": "tenant_heirarchy_table",
						"type": "DatasetReference"
					},
					"name": "TenantHeirarychyDetail"
				},
				{
					"dataset": {
						"referenceName": "forecast",
						"type": "DatasetReference"
					},
					"name": "demandforecastcheck"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "forecast",
						"type": "DatasetReference"
					},
					"name": "validdemandforecast"
				},
				{
					"dataset": {
						"referenceName": "FailedUXUploadDemandForecast",
						"type": "DatasetReference"
					},
					"name": "failedrows"
				}
			],
			"transformations": [
				{
					"name": "validations"
				},
				{
					"name": "derivations"
				},
				{
					"name": "aggregationerrors"
				},
				{
					"name": "join1"
				},
				{
					"name": "splitvalidationrows"
				},
				{
					"name": "mapissueroute"
				},
				{
					"name": "RenameBackwards"
				},
				{
					"name": "filterthtd"
				},
				{
					"name": "joinTHTD"
				},
				{
					"name": "selectimporthistory"
				},
				{
					"name": "SelectColumnsMain"
				},
				{
					"name": "joinitem"
				},
				{
					"name": "joinlocation"
				},
				{
					"name": "selectitems"
				},
				{
					"name": "selectlocations"
				},
				{
					"name": "selectmicroarea"
				},
				{
					"name": "selectcustomertypes"
				},
				{
					"name": "selectfulfillmentservice"
				},
				{
					"name": "joincustomertype"
				},
				{
					"name": "joinarea"
				},
				{
					"name": "joinfulfillmentservice"
				},
				{
					"name": "joindemandforecast"
				},
				{
					"name": "deriveddemandforecast"
				},
				{
					"name": "filtertemp"
				},
				{
					"name": "joinExistingRecErrors"
				},
				{
					"name": "outputfilenamefailed"
				},
				{
					"name": "nonnumericvalsinnumericfields"
				},
				{
					"name": "recordid"
				},
				{
					"name": "findduplicates"
				},
				{
					"name": "filtertransaction"
				},
				{
					"name": "joinbuorgtransactionlocation"
				},
				{
					"name": "jointransactionuorgitem"
				},
				{
					"name": "jointransactionbuorgcusttype"
				},
				{
					"name": "jointransactionbuorgfservice"
				},
				{
					"name": "jointransactionbuorgdemandforecast"
				},
				{
					"name": "selectextrecords"
				},
				{
					"name": "filterrowswithvalidationerrors"
				},
				{
					"name": "removeemptyrows"
				},
				{
					"name": "joinImportHistoryMain"
				},
				{
					"name": "derivedtransactionid"
				},
				{
					"name": "selectdemandforecasts"
				},
				{
					"name": "selectextrecordsload"
				},
				{
					"name": "joinLoadValuesSelectCols"
				},
				{
					"name": "datatypeconversions"
				}
			],
			"scriptLines": [
				"parameters{",
				"     file_path as string ('/TEST/Upload/DemandForecast/464.xlsx'),",
				"     transaction_id as string ('464')",
				"}",
				"source(output(",
				"          {Item ID*} as string,",
				"          {Area ID (3 Digit Zip Code)*} as string,",
				"          {Customer Type} as string,",
				"          {Fulfillment Service*} as string,",
				"          {Forecast Start Date*} as date 'yyyy-MM-dd',",
				"          {Forecast End Date*} as date 'yyyy-MM-dd',",
				"          {Low Demand Quantity} as string,",
				"          {Consensus Demand Quantity} as string,",
				"          {High Demand Quantity} as string,",
				"          {Fulfillment Location ID} as string,",
				"          {Fixed Fulfillment} as string",
				"     ),",
				"     allowSchemaDrift: false,",
				"     validateSchema: true,",
				"     ignoreNoFilesFound: false,",
				"     rowUrlColumn: 'file_name',",
				"     wildcardPaths:[($file_path)]) ~> demandforecastuxupload",
				"source(output(",
				"          id as integer,",
				"          item_code as string,",
				"          description as string,",
				"          short_description as string,",
				"          department as string,",
				"          sub_department as string,",
				"          class as string,",
				"          sub_class as string,",
				"          style as string,",
				"          color as string,",
				"          size as string,",
				"          size_second as string,",
				"          sku_lifecycle_status as integer,",
				"          product_division as string,",
				"          product_family as string,",
				"          measurement_unit as string,",
				"          unit_cost as float,",
				"          unit_volume as float,",
				"          unit_weight as float,",
				"          unit_cube as float,",
				"          units_per_pallet as float,",
				"          uom_conversion_factor as float,",
				"          distribution_channel as string,",
				"          item_handling_type as string,",
				"          item_unit_price as float,",
				"          minimum_sales_qty as float,",
				"          birth_year as short,",
				"          birth_month as short,",
				"          expiration_year as short,",
				"          expiration_month as short,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          business_unit_id as string,",
				"          organization_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> item",
				"source(output(",
				"          id as integer,",
				"          location_code as string,",
				"          name as string,",
				"          address as string,",
				"          city as string,",
				"          state as string,",
				"          zip as string,",
				"          country as string,",
				"          sub_type as string,",
				"          delivery_partners as string,",
				"          throughput as float,",
				"          capacity as float,",
				"          special_information as string,",
				"          holding_cost as float,",
				"          inbound_handling_cost as float,",
				"          outbound_handling_cost as float,",
				"          longitude as decimal(0,0),",
				"          latitude as decimal(0,0),",
				"          updated_date as date,",
				"          created_date as date,",
				"          status as string,",
				"          inbound_processing_time as decimal(0,0),",
				"          outbound_processing_time as decimal(0,0),",
				"          type as integer,",
				"          transfer_inbound_processing_time as double,",
				"          transfer_outbound_processing_time as double,",
				"          transfer_inbound_handling_cost as double,",
				"          transfer_outbound_handling_cost as double,",
				"          tenant_id as string,",
				"          organization_id as string,",
				"          business_unit_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> locations",
				"source(output(",
				"          id as integer,",
				"          micro_area_code as string,",
				"          description as string,",
				"          primary_fulfillment_location as integer,",
				"          attribute_1 as string,",
				"          attribute_2 as string,",
				"          created_date as timestamp,",
				"          updated_date as timestamp",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> microarea",
				"source(output(",
				"          id as integer,",
				"          customer_type_code as string,",
				"          type as string,",
				"          description as string,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          business_unit_id as string,",
				"          organization_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> customertypes",
				"source(output(",
				"          id as integer,",
				"          fulfillment_service_code as string,",
				"          service_name as string,",
				"          service_type as string,",
				"          delivery_speed_value as float,",
				"          delivery_speed_unit as string,",
				"          service_radius_value as float,",
				"          service_radius_unit as string,",
				"          service_charge as float,",
				"          deployment_type as string,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          business_unit_id as string,",
				"          organization_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> fulfillmentservices",
				"source(output(",
				"          id as integer,",
				"          original_file_name as string,",
				"          user_id as string,",
				"          status_enum_value_id as integer,",
				"          processed_time as timestamp,",
				"          errors as string,",
				"          business_unit_id as string,",
				"          organization_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> importhistory",
				"source(output(",
				"          id as string,",
				"          tenant_hierarchy_type as integer,",
				"          name as string,",
				"          contact_name as string,",
				"          email as string,",
				"          phone as string,",
				"          street_address_1 as string,",
				"          street_address_2 as string,",
				"          city as string,",
				"          state as string,",
				"          zip as integer,",
				"          country as string,",
				"          active as boolean,",
				"          tenant_id as string,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          parent_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> TenantHeirarychyDetail",
				"source(output(",
				"          id as integer,",
				"          item_id as integer,",
				"          area_id as integer,",
				"          customer_type as integer,",
				"          fulfillment_service as integer,",
				"          forecast_start_date as timestamp,",
				"          forecast_end_date as timestamp,",
				"          fulfillment_location as integer,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          organization_id as string,",
				"          business_unit_id as string,",
				"          low_demand_quantity as integer,",
				"          consensus_demand_quantity as integer,",
				"          high_demand_quantity as integer,",
				"          fixed_fulfillment as boolean,",
				"          area_hierarchy_id as integer",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> demandforecastcheck",
				"removeemptyrows, selectlocations, selectitems, selectmicroarea, selectcustomertypes, selectfulfillmentservice assert(expectTrue(not(isNull(mapissueroute@Item_ID))&&\r",
				"not(isNull(mapissueroute@Area_ID))&&\r",
				"not(isNull(Customer_Type))&&\r",
				"not(isNull(Fulfillment_Service))&&\r",
				"not(isNull(Fulfillment_Location_ID)), false, 'mandatoryvalues', null, 'mandatory values missing'),",
				"     expectExists(Fulfillment_Location_ID == location_code, false, 'locations', null, 'location code not found'),",
				"     expectExists(mapissueroute@Item_ID == item_code, false, 'item', null, 'item code not matching'),",
				"     expectExists(mapissueroute@Area_ID == micro_area_code, false, 'microarea', null, 'area code not matching'),",
				"     expectExists(Fulfillment_Service == service_name, false, 'fulfillmentservices', null, 'fulfillment service type not matching'),",
				"     expectExists(Customer_Type == type, false, 'customertype', null, 'customer type not matching'),",
				"     expectTrue(isNull(presence), false, 'recordisnew', null, 'record already exists'),",
				"     expectTrue(numericfieldintegrity, false, 'numericintegrity', null, 'numerical field contains non numeric values'),",
				"     expectTrue(notduplicatedrow, false, 'dataduplicated', null, 'duplicate records detected in upload')) ~> validations",
				"RenameBackwards derive(validation_errors = assertErrorMessages(),",
				"          transaction_id = toInteger($transaction_id),",
				"          sink_file_name = replace(file_name,'.xlsx','.txt'),",
				"          file_name_failed_rows = replace(file_name,'/Upload/','/FailedTransactions/'),",
				"          fixed_fulfillment = 12) ~> derivations",
				"derivations aggregate(groupBy(file_name),",
				"     errors_count = countIf(not(isNull(validation_errors)))) ~> aggregationerrors",
				"derivations, aggregationerrors join(RenameBackwards@file_name == aggregationerrors@file_name,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> join1",
				"SelectColumnsMain split(errors_count==0,",
				"     disjoint: false) ~> splitvalidationrows@(validrows, validationfailedrows)",
				"joinExistingRecErrors select(mapColumn(",
				"          Item_ID = {Item ID*},",
				"          Area_ID = {Area ID (3 Digit Zip Code)*},",
				"          Customer_Type = {Customer Type},",
				"          Fulfillment_Service = {Fulfillment Service*},",
				"          {Forecast Start Date} = {Forecast Start Date*},",
				"          {Forecast End Date} = {Forecast End Date*},",
				"          {Low Demand Quantity},",
				"          {Consensus Demand Quantity},",
				"          {High Demand Quantity},",
				"          Fulfillment_Location_ID = {Fulfillment Location ID},",
				"          {Fixed Fulfillment},",
				"          file_name,",
				"          presence,",
				"          numericfieldintegrity,",
				"          notduplicatedrow = nonduplicatedrow,",
				"          recordid = recordid@recordid",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> mapissueroute",
				"validations select(mapColumn(",
				"          {Item ID*} = mapissueroute@Item_ID,",
				"          {Area ID (3 Digit Zip Code)*} = mapissueroute@Area_ID,",
				"          {Customer Type} = Customer_Type,",
				"          {Fulfillment Service*} = Fulfillment_Service,",
				"          {Forecast Start Date*} = {Forecast Start Date},",
				"          {Forecast End Date*} = {Forecast End Date},",
				"          {Low Demand Quantity},",
				"          {Consensus Demand Quantity},",
				"          {High Demand Quantity},",
				"          {Fulfillment Location ID} = Fulfillment_Location_ID,",
				"          {Fixed Fulfillment},",
				"          file_name,",
				"          recordid",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> RenameBackwards",
				"TenantHeirarychyDetail filter(tenant_hierarchy_type==3) ~> filterthtd",
				"filtertransaction, filterthtd join(business_unit_id == TenantHeirarychyDetail@id",
				"     && organization_id == parent_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinTHTD",
				"joinTHTD select(mapColumn(",
				"          transaction_id = importhistory@id,",
				"          business_unit_id,",
				"          organization_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
				"join1 select(mapColumn(",
				"          {Item ID*},",
				"          {Area ID (3 Digit Zip Code)*},",
				"          {Customer Type},",
				"          {Fulfillment Service*},",
				"          {Forecast Start Date*},",
				"          {Forecast End Date*},",
				"          {Low Demand Quantity},",
				"          {Consensus Demand Quantity},",
				"          {High Demand Quantity},",
				"          {Fulfillment Location ID},",
				"          file_name = RenameBackwards@file_name,",
				"          validation_errors,",
				"          transaction_id,",
				"          sink_file_name,",
				"          errors_count,",
				"          recordid,",
				"          fixed_fulfillment",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> SelectColumnsMain",
				"joinImportHistoryMain, selectitems join({Item ID*} == item_code,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinitem",
				"joinitem, selectlocations join({Fulfillment Location ID} == location_code,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinlocation",
				"jointransactionuorgitem select(mapColumn(",
				"          item_id = id,",
				"          item_code",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectitems",
				"joinbuorgtransactionlocation select(mapColumn(",
				"          location_id = id,",
				"          location_code",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectlocations",
				"microarea select(mapColumn(",
				"          area_id = id,",
				"          micro_area_code",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectmicroarea",
				"jointransactionbuorgcusttype select(mapColumn(",
				"          customer_type_id = id,",
				"          customer_type_code,",
				"          type",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectcustomertypes",
				"jointransactionbuorgfservice select(mapColumn(",
				"          fulfillment_service_id = id,",
				"          fulfillment_service_code,",
				"          service_name,",
				"          service_type",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectfulfillmentservice",
				"joinlocation, selectcustomertypes join({Customer Type} == type,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joincustomertype",
				"joincustomertype, selectmicroarea join({Area ID (3 Digit Zip Code)*} == micro_area_code,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinarea",
				"joinarea, selectfulfillmentservice join({Fulfillment Service*} == service_name,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinfulfillmentservice",
				"joinfulfillmentservice, selectdemandforecasts join(selectitems@item_id == selectdemandforecasts@item_id",
				"     && selectmicroarea@area_id == selectdemandforecasts@area_id",
				"     && location_id == fulfillment_location",
				"     && customer_type_id == customer_type",
				"     && fulfillment_service_id == fulfillment_service",
				"     && {Forecast Start Date*} == forecast_start_date",
				"     && {Forecast End Date*} == forecast_end_date,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joindemandforecast",
				"filtertemp derive(presence = 'true',",
				"          forecast_start_date = toDate(toString(forecast_start_date)),",
				"          forecast_end_date = toDate(toString(forecast_end_date))) ~> deriveddemandforecast",
				"jointransactionbuorgdemandforecast filter(not(isNull(fulfillment_location))) ~> filtertemp",
				"nonnumericvalsinnumericfields, selectextrecords join(recordid@recordid == selectextrecords@recordid,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinExistingRecErrors",
				"filterrowswithvalidationerrors derive(failed_file_name = replace(replace($file_path,'/Upload/','/FailedTransactions/'),'.xlsx','.json'),",
				"          type = 'error',",
				"          message = concat('record number ',toString(recordid),' has following errors ',toString(validation_errors))) ~> outputfilenamefailed",
				"findduplicates derive(numericfieldintegrity = iif(isNull({Low Demand Quantity}),true(),not(isNull(toFloat({Low Demand Quantity})))) && iif(isNull({Consensus Demand Quantity}),true(),not(isNull(toFloat({Consensus Demand Quantity})))) && iif(isNull({High Demand Quantity}),true(),not(isNull(toFloat({High Demand Quantity})))) &&  iif(isNull({Fixed Fulfillment}),true(),not(isNull(toFloat({Fixed Fulfillment}))))) ~> nonnumericvalsinnumericfields",
				"demandforecastuxupload keyGenerate(output(recordid as long),",
				"     startAt: 1L,",
				"     stepValue: 1L) ~> recordid",
				"recordid window(over({Item ID*},",
				"          {Area ID (3 Digit Zip Code)*},",
				"          {Fulfillment Service*},",
				"          {Customer Type},",
				"          {Forecast Start Date*},",
				"          {Forecast End Date*},",
				"          {Fulfillment Location ID}),",
				"     asc(recordid, true),",
				"     nonduplicatedrow = rowNumber()==1) ~> findduplicates",
				"importhistory filter(id == toInteger($transaction_id)) ~> filtertransaction",
				"locations, selectimporthistory join(locations@business_unit_id == selectimporthistory@business_unit_id",
				"     && locations@organization_id == selectimporthistory@organization_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinbuorgtransactionlocation",
				"item, selectimporthistory join(item@business_unit_id == selectimporthistory@business_unit_id",
				"     && item@organization_id == selectimporthistory@organization_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> jointransactionuorgitem",
				"customertypes, selectimporthistory join(customertypes@business_unit_id == selectimporthistory@business_unit_id",
				"     && customertypes@organization_id == selectimporthistory@organization_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> jointransactionbuorgcusttype",
				"fulfillmentservices, selectimporthistory join(fulfillmentservices@business_unit_id == selectimporthistory@business_unit_id",
				"     && fulfillmentservices@organization_id == selectimporthistory@organization_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> jointransactionbuorgfservice",
				"demandforecastcheck, selectimporthistory join(demandforecastcheck@business_unit_id == selectimporthistory@business_unit_id",
				"     && demandforecastcheck@organization_id == selectimporthistory@organization_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> jointransactionbuorgdemandforecast",
				"joindemandforecast select(mapColumn(",
				"          recordid,",
				"          presence",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectextrecords",
				"splitvalidationrows@validationfailedrows filter(not(isNull(validation_errors))) ~> filterrowswithvalidationerrors",
				"mapissueroute filter(not(isNull(Item_ID)) || not(isNull(Area_ID)) || not(isNull(Customer_Type)) || not(isNull(Fulfillment_Service)) || not(isNull({Forecast Start Date})) || not(isNull({Forecast End Date})) || not(isNull({Low Demand Quantity})) || not(isNull({High Demand Quantity})) || not(isNull(Fulfillment_Location_ID)) || not(isNull({Fixed Fulfillment}))) ~> removeemptyrows",
				"derivedtransactionid, selectimporthistory join(derivedtransactionid@transaction_id == selectimporthistory@transaction_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinImportHistoryMain",
				"recordid derive(transaction_id = toInteger($transaction_id)) ~> derivedtransactionid",
				"deriveddemandforecast select(mapColumn(",
				"          item_id,",
				"          area_id,",
				"          customer_type,",
				"          fulfillment_service,",
				"          forecast_start_date,",
				"          forecast_end_date,",
				"          fulfillment_location,",
				"          area_hierarchy_id,",
				"          presence",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectdemandforecasts",
				"joindemandforecast select(mapColumn(",
				"          file_name,",
				"          item_id = selectitems@item_id,",
				"          recordid,",
				"          business_unit_id,",
				"          organization_id,",
				"          location_id,",
				"          customer_type_id,",
				"          area_id = selectmicroarea@area_id,",
				"          fulfillment_service_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectextrecordsload",
				"splitvalidationrows@validrows, selectextrecordsload join(splitvalidationrows@validrows@recordid == selectextrecordsload@recordid,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joinLoadValuesSelectCols",
				"joinLoadValuesSelectCols derive({Low Demand Quantity} = toInteger({Low Demand Quantity}),",
				"          {Consensus Demand Quantity} = toInteger({Consensus Demand Quantity}),",
				"          {High Demand Quantity} = toInteger({High Demand Quantity})) ~> datatypeconversions",
				"datatypeconversions sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     input(",
				"          id as integer,",
				"          item_id as integer,",
				"          area_id as integer,",
				"          customer_type as integer,",
				"          fulfillment_service as integer,",
				"          forecast_start_date as timestamp,",
				"          forecast_end_date as timestamp,",
				"          fulfillment_location as integer,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          organization_id as string,",
				"          business_unit_id as string,",
				"          low_demand_quantity as integer,",
				"          consensus_demand_quantity as integer,",
				"          high_demand_quantity as integer,",
				"          fixed_fulfillment as boolean,",
				"          area_hierarchy_id as integer",
				"     ),",
				"     deletable:false,",
				"     insertable:true,",
				"     updateable:false,",
				"     upsertable:false,",
				"     format: 'table',",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true,",
				"     mapColumn(",
				"          item_id,",
				"          area_id,",
				"          customer_type = customer_type_id,",
				"          fulfillment_service = fulfillment_service_id,",
				"          forecast_start_date = {Forecast Start Date*},",
				"          forecast_end_date = {Forecast End Date*},",
				"          fulfillment_location = location_id,",
				"          organization_id,",
				"          business_unit_id,",
				"          low_demand_quantity = {Low Demand Quantity},",
				"          consensus_demand_quantity = {Consensus Demand Quantity},",
				"          high_demand_quantity = {High Demand Quantity},",
				"          fixed_fulfillment,",
				"          area_hierarchy_id = area_id",
				"     ),",
				"     preCommands: [],",
				"     postCommands: []) ~> validdemandforecast",
				"outputfilenamefailed sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     rowUrlColumn:'failed_file_name',",
				"     umask: 0022,",
				"     preCommands: [],",
				"     postCommands: [],",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true,",
				"     mapColumn(",
				"          type,",
				"          message",
				"     )) ~> failedrows"
			]
		}
	}
}