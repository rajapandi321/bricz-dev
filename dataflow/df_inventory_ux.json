{
	"name": "df_inventory_ux",
	"properties": {
		"folder": {
			"name": "IMPORT_MANAGER_MERGED"
		},
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "tenant_heirarchy_table",
						"type": "DatasetReference"
					},
					"name": "tenanthierarchy"
				},
				{
					"dataset": {
						"referenceName": "importhistory",
						"type": "DatasetReference"
					},
					"name": "importhistory"
				},
				{
					"dataset": {
						"referenceName": "locations",
						"type": "DatasetReference"
					},
					"name": "fetchinglocations"
				},
				{
					"dataset": {
						"referenceName": "item",
						"type": "DatasetReference"
					},
					"name": "fetchingitems"
				},
				{
					"dataset": {
						"referenceName": "INVENTORY_UX",
						"type": "DatasetReference"
					},
					"name": "fetchinginventorysource"
				},
				{
					"dataset": {
						"referenceName": "inventory",
						"type": "DatasetReference"
					},
					"name": "fetchinginventory"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "inventory",
						"type": "DatasetReference"
					},
					"name": "validinventoryrows"
				},
				{
					"dataset": {
						"referenceName": "FailedInventoryRows",
						"type": "DatasetReference"
					},
					"name": "failedrows"
				}
			],
			"transformations": [
				{
					"name": "filter3"
				},
				{
					"name": "selectimportdetails"
				},
				{
					"name": "join1"
				},
				{
					"name": "choosingtenants"
				},
				{
					"name": "choosinglocations"
				},
				{
					"name": "choosingitems"
				},
				{
					"name": "addingrecordid"
				},
				{
					"name": "nonduplicate"
				},
				{
					"name": "derivedColumn1"
				},
				{
					"name": "renamesourcecolumns"
				},
				{
					"name": "joininglocations"
				},
				{
					"name": "joiningitems"
				},
				{
					"name": "derivedColumn3"
				},
				{
					"name": "selectinginventory"
				},
				{
					"name": "finaldataset"
				},
				{
					"name": "derivedColumn4"
				},
				{
					"name": "joiningTenants"
				},
				{
					"name": "selectedfields"
				},
				{
					"name": "assert1"
				},
				{
					"name": "join3"
				},
				{
					"name": "mergingds"
				},
				{
					"name": "selectrequired"
				},
				{
					"name": "select1"
				},
				{
					"name": "aggregateerrors"
				},
				{
					"name": "join4"
				},
				{
					"name": "splitingtherecordsbasedonerrors"
				},
				{
					"name": "filter4"
				},
				{
					"name": "filter5"
				},
				{
					"name": "derivedColumn5"
				},
				{
					"name": "derivedColumn6"
				},
				{
					"name": "join5"
				},
				{
					"name": "join6"
				},
				{
					"name": "changecolumntypes"
				}
			],
			"scriptLines": [
				"parameters{",
				"     transaction_id as string ('657'),",
				"     file_path as string ('DEV/Upload/Inventory/657.xlsx')",
				"}",
				"source(output(",
				"          id as string,",
				"          tenant_hierarchy_type as integer,",
				"          name as string,",
				"          contact_name as string,",
				"          email as string,",
				"          phone as string,",
				"          street_address_1 as string,",
				"          street_address_2 as string,",
				"          city as string,",
				"          state as string,",
				"          zip as integer,",
				"          country as string,",
				"          active as boolean,",
				"          tenant_id as string,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          parent_id as string,",
				"          tenant_hierarchy_code as string,",
				"          isdeleted as boolean,",
				"          updated_by_user_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> tenanthierarchy",
				"source(output(",
				"          id as integer,",
				"          original_file_name as string,",
				"          user_id as string,",
				"          status_enum_value_id as integer,",
				"          processed_time as timestamp,",
				"          errors as string,",
				"          business_unit_id as string,",
				"          organization_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> importhistory",
				"source(output(",
				"          id as integer,",
				"          location_code as string,",
				"          name as string,",
				"          address as string,",
				"          city as string,",
				"          state as string,",
				"          zip as string,",
				"          country as string,",
				"          sub_type as string,",
				"          delivery_partners as string,",
				"          throughput as float,",
				"          capacity as float,",
				"          special_information as string,",
				"          holding_cost as float,",
				"          inbound_handling_cost as float,",
				"          outbound_handling_cost as float,",
				"          longitude as double,",
				"          latitude as double,",
				"          updated_date as date,",
				"          created_date as date,",
				"          status as string,",
				"          inbound_processing_time as decimal(0,0),",
				"          outbound_processing_time as decimal(0,0),",
				"          type as integer,",
				"          transfer_inbound_processing_time as double,",
				"          transfer_outbound_processing_time as double,",
				"          transfer_inbound_handling_cost as double,",
				"          transfer_outbound_handling_cost as double,",
				"          tenant_id as string,",
				"          organization_id as string,",
				"          business_unit_id as string,",
				"          units_per_hour as float,",
				"          max_fte_regular_hours as float,",
				"          min_fte_regular_hours as float,",
				"          max_temp_regular_hours as float,",
				"          min_temp_regular_hours as float,",
				"          max_fte_overtime_hours as float,",
				"          max_temp_overtime_hours as float,",
				"          regular_fte_wage as float,",
				"          regular_temp_wage as float,",
				"          overtime_fte_wage as float,",
				"          overtime_temp_wage as float,",
				"          fte_staff_count as integer,",
				"          temp_staff_count as integer",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> fetchinglocations",
				"source(output(",
				"          id as integer,",
				"          item_code as string,",
				"          description as string,",
				"          short_description as string,",
				"          department as string,",
				"          sub_department as string,",
				"          class as string,",
				"          sub_class as string,",
				"          style as string,",
				"          color as string,",
				"          size as string,",
				"          size_second as string,",
				"          sku_lifecycle_status as integer,",
				"          product_division as string,",
				"          product_family as string,",
				"          measurement_unit as string,",
				"          unit_cost as float,",
				"          unit_volume as float,",
				"          unit_weight as float,",
				"          unit_cube as float,",
				"          units_per_pallet as float,",
				"          uom_conversion_factor as float,",
				"          distribution_channel as string,",
				"          item_handling_type as string,",
				"          item_unit_price as float,",
				"          minimum_sales_qty as float,",
				"          birth_year as short,",
				"          birth_month as short,",
				"          expiration_year as short,",
				"          expiration_month as short,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          business_unit_id as string,",
				"          organization_id as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> fetchingitems",
				"source(output(",
				"          {Item ID} as string,",
				"          {Location ID} as string,",
				"          {Stock Date} as date,",
				"          {Stock Quantity} as string,",
				"          {Reserved Quantity} as string,",
				"          {Available Quantity} as string,",
				"          {On Order ID} as string,",
				"          {On Order Due Date} as date,",
				"          {On Order Supplier Shipping Date} as date,",
				"          {On Order Promised Delivery Date} as date",
				"     ),",
				"     allowSchemaDrift: false,",
				"     validateSchema: true,",
				"     ignoreNoFilesFound: false,",
				"     rowUrlColumn: 'file_name',",
				"     wildcardPaths:[($file_path)]) ~> fetchinginventorysource",
				"source(output(",
				"          id as integer,",
				"          item_id as integer,",
				"          location_id as integer,",
				"          on_hand_stock_date as date,",
				"          on_hand_stock_quantity as float,",
				"          reserved_on_hold_stock_ as float,",
				"          available_stock as float,",
				"          lot_id as string,",
				"          on_order_due_date as date,",
				"          on_order_quantity_ as float,",
				"          purchase_order_status as float,",
				"          on_order_supplier_shipping_date as date,",
				"          on_order_promised_delivery_date as date,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          tenant_id as string,",
				"          organization_id as string,",
				"          business_unit_id as string,",
				"          stock_type_id as integer",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> fetchinginventory",
				"importhistory filter(id == toInteger($transaction_id)) ~> filter3",
				"filter3 select(mapColumn(",
				"          id,",
				"          business_unit_id,",
				"          organization_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectimportdetails",
				"tenanthierarchy, selectimportdetails join(tenanthierarchy@id == business_unit_id",
				"     && parent_id == organization_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> join1",
				"join1 select(mapColumn(",
				"          tenant_id,",
				"          import_id = selectimportdetails@id,",
				"          business_unit_id,",
				"          organization_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> choosingtenants",
				"join5 select(mapColumn(",
				"          location_id = id,",
				"          location_code,",
				"          organization_id = fetchinglocations@organization_id,",
				"          business_unit_id = fetchinglocations@business_unit_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> choosinglocations",
				"join6 select(mapColumn(",
				"          id,",
				"          item_code",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> choosingitems",
				"fetchinginventorysource keyGenerate(output(record_id as long),",
				"     startAt: 1L,",
				"     stepValue: 1L) ~> addingrecordid",
				"renamesourcecolumns window(over(Item_ID_SC,",
				"          Location_ID_SC,",
				"          Stock_Date_SC,",
				"          On_Order_Supplier_Shipping_Date_SC,",
				"          On_Order_Promised_Delivery_Date_SC,",
				"          On_Order_ID_SC),",
				"     asc(record_id, true),",
				"     nonduplicated = rowNumber() == 1) ~> nonduplicate",
				"nonduplicate derive(numericalintegrity = iif(isNull(Stock_Quantity_SC),true(),not(isNull(toFloat(Stock_Quantity_SC)))) &&  iif(isNull(Reserved_Quantity_SC),true(),not(isNull(toFloat(Reserved_Quantity_SC)))) && iif(isNull(Available_Quantity_SC),true(),not(isNull(toFloat(Available_Quantity_SC))))) ~> derivedColumn1",
				"addingrecordid select(mapColumn(",
				"          Item_ID_SC = {Item ID},",
				"          Location_ID_SC = {Location ID},",
				"          Stock_Date_SC = {Stock Date},",
				"          Stock_Quantity_SC = {Stock Quantity},",
				"          Reserved_Quantity_SC = {Reserved Quantity},",
				"          Available_Quantity_SC = {Available Quantity},",
				"          On_Order_ID_SC = {On Order ID},",
				"          On_Order_Due_Date_SC = {On Order Due Date},",
				"          On_Order_Supplier_Shipping_Date_SC = {On Order Supplier Shipping Date},",
				"          On_Order_Promised_Delivery_Date_SC = {On Order Promised Delivery Date},",
				"          record_id,",
				"          file_name",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> renamesourcecolumns",
				"joiningTenants, choosinglocations join(Location_ID_SC == location_code,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joininglocations",
				"joininglocations, choosingitems join(Item_ID_SC == item_code,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joiningitems",
				"fetchinginventory derive(presence = 'true') ~> derivedColumn3",
				"derivedColumn3 select(mapColumn(",
				"          id,",
				"          item_id,",
				"          location_id,",
				"          on_hand_stock_date,",
				"          on_hand_stock_quantity,",
				"          reserved_on_hold_stock_,",
				"          available_stock,",
				"          lot_id,",
				"          on_order_due_date,",
				"          on_order_quantity_,",
				"          purchase_order_status,",
				"          on_order_supplier_shipping_date,",
				"          on_order_promised_delivery_date,",
				"          created_date,",
				"          updated_date,",
				"          tenant_id,",
				"          organization_id,",
				"          business_unit_id,",
				"          stock_type_id,",
				"          presence",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectinginventory",
				"joiningitems select(mapColumn(",
				"          Item_ID_SC,",
				"          Location_ID_SC,",
				"          Stock_Date_SC,",
				"          Stock_Quantity_SC,",
				"          Reserved_Quantity_SC,",
				"          Available_Quantity_SC,",
				"          On_Order_ID_SC,",
				"          On_Order_Due_Date_SC,",
				"          On_Order_Supplier_Shipping_Date_SC,",
				"          On_Order_Promised_Delivery_Date_SC,",
				"          record_id,",
				"          filename = file_name,",
				"          nonduplicated,",
				"          stock_type_id,",
				"          transaction_id,",
				"          tenant_id,",
				"          location_id,",
				"          location_code,",
				"          item_id = id,",
				"          item_code,",
				"          business_unit_id = choosingtenants@business_unit_id,",
				"          organization_id = choosingtenants@organization_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> finaldataset",
				"nonduplicate derive(stock_type_id = 1,",
				"          transaction_id = toInteger($transaction_id)) ~> derivedColumn4",
				"derivedColumn4, choosingtenants join(transaction_id == import_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> joiningTenants",
				"join3 select(mapColumn(",
				"          Item_ID_SC,",
				"          Location_ID_SC,",
				"          Stock_Date_SC,",
				"          Stock_Quantity_SC,",
				"          Reserved_Quantity_SC,",
				"          Available_Quantity_SC,",
				"          On_Order_ID_SC,",
				"          On_Order_Due_Date_SC,",
				"          On_Order_Supplier_Shipping_Date_SC,",
				"          On_Order_Promised_Delivery_Date_SC,",
				"          record_id,",
				"          filename,",
				"          nonduplicated,",
				"          numericalintegrity,",
				"          stock_type_id = selectrequired@stock_type_id,",
				"          transaction_id,",
				"          tenant_id = selectrequired@tenant_id,",
				"          organization_id = selectrequired@organization_id,",
				"          business_unit_id = selectrequired@business_unit_id,",
				"          location_id = selectrequired@location_id,",
				"          location_code,",
				"          item_id = selectrequired@item_id,",
				"          item_code,",
				"          presence",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectedfields",
				"filter4, selectinginventory, choosinglocations, choosingitems assert(expectExists(Location_ID_SC == choosinglocations@location_code, false, 'checklocationexists', null, 'LOCATION ID IS NOT FOUND'),",
				"     expectExists(Item_ID_SC == choosingitems@item_code, false, 'checkitemcodeexists', null, 'ITEM CODE IS NOT FOUND'),",
				"     expectTrue(numericalintegrity, false, 'numericalintegrity', null, 'Non numerical values exist in numerical fields'),",
				"     expectTrue(nonduplicated, false, 'nonduplicate', null, 'Duplicate records found in upload'),",
				"     expectTrue(isNull(selectedfields@presence), false, 'checkrecordexists', null, 'Record Already Exists in DB')) ~> assert1",
				"selectrequired, selectinginventory join(selectrequired@location_id == selectinginventory@location_id",
				"     && selectrequired@item_id == selectinginventory@item_id",
				"     && Stock_Date_SC == on_hand_stock_date",
				"     && selectrequired@stock_type_id == selectinginventory@stock_type_id,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> join3",
				"derivedColumn1, finaldataset join(renamesourcecolumns@record_id == finaldataset@record_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> mergingds",
				"mergingds select(mapColumn(",
				"          numericalintegrity,",
				"          Item_ID_SC = finaldataset@Item_ID_SC,",
				"          Location_ID_SC = finaldataset@Location_ID_SC,",
				"          Stock_Date_SC = finaldataset@Stock_Date_SC,",
				"          Stock_Quantity_SC = finaldataset@Stock_Quantity_SC,",
				"          Reserved_Quantity_SC = finaldataset@Reserved_Quantity_SC,",
				"          Available_Quantity_SC = finaldataset@Available_Quantity_SC,",
				"          On_Order_ID_SC = finaldataset@On_Order_ID_SC,",
				"          On_Order_Due_Date_SC = finaldataset@On_Order_Due_Date_SC,",
				"          On_Order_Supplier_Shipping_Date_SC = finaldataset@On_Order_Supplier_Shipping_Date_SC,",
				"          On_Order_Promised_Delivery_Date_SC = finaldataset@On_Order_Promised_Delivery_Date_SC,",
				"          record_id = finaldataset@record_id,",
				"          filename,",
				"          nonduplicated = finaldataset@nonduplicated,",
				"          stock_type_id,",
				"          transaction_id,",
				"          tenant_id,",
				"          location_id,",
				"          location_code,",
				"          item_id,",
				"          item_code,",
				"          business_unit_id,",
				"          organization_id",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selectrequired",
				"assert1 select(mapColumn(",
				"          Item_ID_SC,",
				"          Location_ID_SC,",
				"          Stock_Date_SC,",
				"          Stock_Quantity_SC,",
				"          Reserved_Quantity_SC,",
				"          Available_Quantity_SC,",
				"          On_Order_ID_SC,",
				"          On_Order_Due_Date_SC,",
				"          On_Order_Supplier_Shipping_Date_SC,",
				"          On_Order_Promised_Delivery_Date_SC,",
				"          record_id,",
				"          filename,",
				"          stock_type_id = selectedfields@stock_type_id,",
				"          tenant_id = selectedfields@tenant_id,",
				"          organization_id = selectedfields@organization_id,",
				"          business_unit_id = selectedfields@business_unit_id,",
				"          location_id = selectedfields@location_id,",
				"          location_code = selectedfields@location_code,",
				"          item_id = selectedfields@item_id,",
				"          item_code = selectedfields@item_code,",
				"          presence = selectedfields@presence",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> select1",
				"derivedColumn5 aggregate(groupBy(filename),",
				"     error_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
				"derivedColumn5, aggregateerrors join(select1@filename == aggregateerrors@filename,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> join4",
				"join4 split(error_count == 0,",
				"     disjoint: false) ~> splitingtherecordsbasedonerrors@(validrows, invalidrows)",
				"selectedfields filter(not(isNull(Item_ID_SC)) || not(isNull(Location_ID_SC)) || not(isNull(Stock_Date_SC)) || not(isNull(Stock_Quantity_SC)) || not(isNull(Reserved_Quantity_SC)) || not(isNull(Available_Quantity_SC)) || not(isNull(On_Order_ID_SC)) || not(isNull(On_Order_Due_Date_SC)) || not(isNull(On_Order_Supplier_Shipping_Date_SC)) || not(isNull(On_Order_Promised_Delivery_Date_SC))) ~> filter4",
				"splitingtherecordsbasedonerrors@invalidrows filter(not(isNull(validation_errors))) ~> filter5",
				"select1 derive(validation_errors = assertErrorMessages(),",
				"          failed_file_name = replace(replace($file_path,'.xlsx','.json'),'/Upload','/FailedTransactions')) ~> derivedColumn5",
				"filter5 derive(type = 'error',",
				"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedColumn6",
				"fetchinglocations, choosingtenants join(fetchinglocations@organization_id == choosingtenants@organization_id",
				"     && fetchinglocations@business_unit_id == choosingtenants@business_unit_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> join5",
				"fetchingitems, choosingtenants join(fetchingitems@organization_id == choosingtenants@organization_id",
				"     && fetchingitems@business_unit_id == choosingtenants@business_unit_id,",
				"     joinType:'inner',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> join6",
				"splitingtherecordsbasedonerrors@validrows derive(Stock_Quantity_SC = toFloat(Stock_Quantity_SC),",
				"          Reserved_Quantity_SC = toFloat(Reserved_Quantity_SC),",
				"          Available_Quantity_SC = toFloat(Available_Quantity_SC)) ~> changecolumntypes",
				"changecolumntypes sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     input(",
				"          id as integer,",
				"          item_id as integer,",
				"          location_id as integer,",
				"          on_hand_stock_date as date,",
				"          on_hand_stock_quantity as float,",
				"          reserved_on_hold_stock_ as float,",
				"          available_stock as float,",
				"          lot_id as string,",
				"          on_order_due_date as date,",
				"          on_order_quantity_ as float,",
				"          purchase_order_status as float,",
				"          on_order_supplier_shipping_date as date,",
				"          on_order_promised_delivery_date as date,",
				"          created_date as timestamp,",
				"          updated_date as timestamp,",
				"          tenant_id as string,",
				"          organization_id as string,",
				"          business_unit_id as string,",
				"          stock_type_id as integer",
				"     ),",
				"     deletable:false,",
				"     insertable:true,",
				"     updateable:false,",
				"     upsertable:false,",
				"     format: 'table',",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true,",
				"     mapColumn(",
				"          item_id,",
				"          location_id,",
				"          on_hand_stock_date = Stock_Date_SC,",
				"          on_hand_stock_quantity = Stock_Quantity_SC,",
				"          reserved_on_hold_stock_ = Reserved_Quantity_SC,",
				"          available_stock = Available_Quantity_SC,",
				"          lot_id = On_Order_ID_SC,",
				"          on_order_due_date = On_Order_Due_Date_SC,",
				"          on_order_supplier_shipping_date = On_Order_Supplier_Shipping_Date_SC,",
				"          on_order_promised_delivery_date = On_Order_Promised_Delivery_Date_SC,",
				"          tenant_id,",
				"          organization_id,",
				"          business_unit_id,",
				"          stock_type_id",
				"     )) ~> validinventoryrows",
				"derivedColumn6 sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     rowUrlColumn:'failed_file_name',",
				"     umask: 0022,",
				"     preCommands: [],",
				"     postCommands: [],",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true,",
				"     mapColumn(",
				"          type,",
				"          message",
				"     )) ~> failedrows"
			]
		}
	}
}