{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "bricz-deploy-factory"
		},
		"PgSQL_LinkedService3_properties_typeProperties_connectionString_secretName": {
			"type": "string",
			"defaultValue": "ADF-DB-CONNECTIONSTRING"
		},
		"QA_Datalake_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://stqadatapipe001.dfs.core.windows.net/"
		},
		"SFTP_RADIAL_STORAGE_properties_typeProperties_host": {
			"type": "string",
			"defaultValue": "ftp.gsipartners.com"
		},
		"SFTP_RADIAL_STORAGE_properties_typeProperties_userName": {
			"type": "string",
			"defaultValue": "bricz"
		},
		"briczkeyvault_properties_typeProperties_baseUrl": {
			"type": "string",
			"defaultValue": "https://keyvault-bricz-dev-001.vault.azure.net/"
		},
		"datalakelinkedservice_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://stdevdatapipe001.dfs.core.windows.net/"
		},
		"import_manager_current_backlog_properties_CURRENT_BACKLOG_UX_parameters_quote": {
			"type": "string",
			"defaultValue": "'"
		},
		"import_manager_current_backlog_properties_CURRENT_BACKLOG_UX_parameters_folder_path": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"import_manager_current_backlog_properties_CURRENT_BACKLOG_UX_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"import_manager_current_backlog_properties_CURRENT_BACKLOG_UX_parameters_next_line": {
			"type": "string",
			"defaultValue": "\\n"
		},
		"import_manager_current_backlog_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"import_manager_demand_forecast_properties_DEMAND_FORECAST_UX_parameters_quote": {
			"type": "string",
			"defaultValue": "'"
		},
		"import_manager_demand_forecast_properties_DEMAND_FORECAST_UX_parameters_folder_path": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"import_manager_demand_forecast_properties_DEMAND_FORECAST_UX_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"import_manager_demand_forecast_properties_DEMAND_FORECAST_UX_parameters_next_line": {
			"type": "string",
			"defaultValue": "\\n"
		},
		"import_manager_demand_forecast_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"import_manager_fulfillment_forecast_properties_FULFILLMENT_FORECAST_UX_parameters_quote": {
			"type": "string",
			"defaultValue": "'"
		},
		"import_manager_fulfillment_forecast_properties_FULFILLMENT_FORECAST_UX_parameters_folder_path": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"import_manager_fulfillment_forecast_properties_FULFILLMENT_FORECAST_UX_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"import_manager_fulfillment_forecast_properties_FULFILLMENT_FORECAST_UX_parameters_next_line": {
			"type": "string",
			"defaultValue": "\\n"
		},
		"import_manager_fulfillment_forecast_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"import_manager_inventory_properties_INVENTORY_UX_parameters_quote": {
			"type": "string",
			"defaultValue": "'"
		},
		"import_manager_inventory_properties_INVENTORY_UX_parameters_folder_path": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"import_manager_inventory_properties_INVENTORY_UX_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"import_manager_inventory_properties_INVENTORY_UX_parameters_next_line": {
			"type": "string",
			"defaultValue": "\\n"
		},
		"import_manager_inventory_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"import_manager_location_properties_LOCATION_UX_parameters_quote": {
			"type": "string",
			"defaultValue": "'"
		},
		"import_manager_location_properties_LOCATION_UX_parameters_folder_path": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"import_manager_location_properties_LOCATION_UX_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"import_manager_location_properties_LOCATION_UX_parameters_next_line": {
			"type": "string",
			"defaultValue": "\\n"
		},
		"import_manager_location_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"import_manager_location_staffing_properties_LOCATION_STAFFING_parameters_quote": {
			"type": "string",
			"defaultValue": "'"
		},
		"import_manager_location_staffing_properties_LOCATION_STAFFING_parameters_folder_path": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"import_manager_location_staffing_properties_LOCATION_STAFFING_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"import_manager_location_staffing_properties_LOCATION_STAFFING_parameters_next_line": {
			"type": "string",
			"defaultValue": "\\n"
		},
		"import_manager_location_staffing_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"sftp_schedule_file_ingest_shipment_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location": {
			"type": "string",
			"defaultValue": "outbound"
		},
		"sftp_schedule_file_ingest_shipment_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory": {
			"type": "string",
			"defaultValue": "ShipmentHistory"
		},
		"sftp_schedule_file_ingest_shipment_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location": {
			"type": "string",
			"defaultValue": "main"
		},
		"sftp_schedule_file_ingest_shipment_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory": {
			"type": "string",
			"defaultValue": "Radial/ShipmentHistory"
		},
		"sftp_scheduled_file_ingest_budget_staffing_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location": {
			"type": "string",
			"defaultValue": "outbound"
		},
		"sftp_scheduled_file_ingest_budget_staffing_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory": {
			"type": "string",
			"defaultValue": "BudgetStaffing"
		},
		"sftp_scheduled_file_ingest_budget_staffing_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location": {
			"type": "string",
			"defaultValue": "main/Radial/"
		},
		"sftp_scheduled_file_ingest_budget_staffing_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory": {
			"type": "string",
			"defaultValue": "BudgetStaffing"
		},
		"sftp_scheduled_file_ingest_daily_actuals_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location": {
			"type": "string",
			"defaultValue": "outbound"
		},
		"sftp_scheduled_file_ingest_daily_actuals_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory": {
			"type": "string",
			"defaultValue": "DailyActuals"
		},
		"sftp_scheduled_file_ingest_daily_actuals_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location": {
			"type": "string",
			"defaultValue": "main/Radial/"
		},
		"sftp_scheduled_file_ingest_daily_actuals_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory": {
			"type": "string",
			"defaultValue": "DailyActuals"
		},
		"sftp_scheduled_file_ingest_fulfillment_forecasts_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location": {
			"type": "string",
			"defaultValue": "outbound"
		},
		"sftp_scheduled_file_ingest_fulfillment_forecasts_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory": {
			"type": "string",
			"defaultValue": "FulfillmentForecast"
		},
		"sftp_scheduled_file_ingest_fulfillment_forecasts_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location": {
			"type": "string",
			"defaultValue": "main/Radial/"
		},
		"sftp_scheduled_file_ingest_fulfillment_forecasts_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory": {
			"type": "string",
			"defaultValue": "FulfillmentForecast"
		},
		"sftp_scheduled_file_ingest_item_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location": {
			"type": "string",
			"defaultValue": "outbound"
		},
		"sftp_scheduled_file_ingest_item_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory": {
			"type": "string",
			"defaultValue": "ItemMaster"
		},
		"sftp_scheduled_file_ingest_item_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location": {
			"type": "string",
			"defaultValue": "main/Radial/"
		},
		"sftp_scheduled_file_ingest_item_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory": {
			"type": "string",
			"defaultValue": "ItemMaster"
		},
		"sftp_scheduled_file_ingest_location_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location": {
			"type": "string",
			"defaultValue": "outbound"
		},
		"sftp_scheduled_file_ingest_location_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory": {
			"type": "string",
			"defaultValue": "LocationMaster"
		},
		"sftp_scheduled_file_ingest_location_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location": {
			"type": "string",
			"defaultValue": "main/Radial/"
		},
		"sftp_scheduled_file_ingest_location_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory": {
			"type": "string",
			"defaultValue": "LocationMaster"
		},
		"sftp_scheduled_file_ingest_order_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location": {
			"type": "string",
			"defaultValue": "outbound"
		},
		"sftp_scheduled_file_ingest_order_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory": {
			"type": "string",
			"defaultValue": "OrderHistory"
		},
		"sftp_scheduled_file_ingest_order_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location": {
			"type": "string",
			"defaultValue": "main"
		},
		"sftp_scheduled_file_ingest_order_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory": {
			"type": "string",
			"defaultValue": "Radial/OrderHistory"
		},
		"sftp_scheduled_file_ingest_staffing_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location": {
			"type": "string",
			"defaultValue": "outbound"
		},
		"sftp_scheduled_file_ingest_staffing_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory": {
			"type": "string",
			"defaultValue": "StaffingHistory"
		},
		"sftp_scheduled_file_ingest_staffing_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location": {
			"type": "string",
			"defaultValue": "main"
		},
		"sftp_scheduled_file_ingest_staffing_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory": {
			"type": "string",
			"defaultValue": "Radial/StaffingHistory"
		},
		"sftp_upload_budget_staffing_properties_BUDGET_STAFFING_parameters_folder_path": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"sftp_upload_budget_staffing_properties_BUDGET_STAFFING_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"sftp_upload_budget_staffing_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"sftp_upload_daily_actuals_properties_DAILY_ACTUALS_parameters_folder_path": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"sftp_upload_daily_actuals_properties_DAILY_ACTUALS_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"sftp_upload_daily_actuals_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"sftp_upload_file_ingest_all_pipelines_properties_SFTP_REDIRECT_BLOB_SINGLE_parameters_folder_path": {
			"type": "string",
			"defaultValue": "outbound"
		},
		"sftp_upload_file_ingest_all_pipelines_properties_SFTP_REDIRECT_BLOB_SINGLE_parameters_container": {
			"type": "string",
			"defaultValue": "main"
		},
		"sftp_upload_fulfillment_forecast_properties_FULFILLMENT_FORECAST_parameters_folder_path": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"sftp_upload_fulfillment_forecast_properties_FULFILLMENT_FORECAST_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"sftp_upload_fulfillment_forecast_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"sftp_upload_item_master_properties_ITEM_MASTER_DATALAKE_parameters_filename": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"sftp_upload_item_master_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"sftp_upload_location_master_properties_LOCATION_MASTER_parameters_folder_path": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"sftp_upload_location_master_properties_LOCATION_MASTER_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"sftp_upload_location_master_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"sftp_upload_order_history_properties_ORDER_HISTORY_COPY_parameters_filename": {
			"type": "string",
			"defaultValue": "@triggerBody().filename"
		},
		"sftp_upload_order_history_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"sftp_upload_shipment_history_properties_SHIPMENT_HISTORY_COPY_parameters_filename": {
			"type": "string",
			"defaultValue": "@triggerBody().filename"
		},
		"sftp_upload_shipment_history_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		},
		"sftp_upload_staffing_history_properties_STAFFING_HISTORY_parameters_file_name": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"sftp_upload_staffing_history_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/c061dde2-a728-4240-8f3d-15ccff95ec4d/resourceGroups/appsvc_linux_centralus/providers/Microsoft.Storage/storageAccounts/stdevdatapipe001"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/BUDGET_STAFFING')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_budget_staffing",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_budget_staffing",
								"type": "DataFlowReference",
								"parameters": {
									"file_path": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'main','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"staffing": {},
									"TenantHeirarchyTable": {},
									"LocationsTable": {},
									"EnumTypeDB": {},
									"EnumValue": {},
									"operationalprofile": {},
									"WriteToDatabase": {},
									"sinkfailedrows": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"folder_path": {
						"type": "string",
						"defaultValue": "Radial/BudgetStaffing"
					},
					"file_name": {
						"type": "string",
						"defaultValue": "20240718T050000-BudgetStaffingPlan.csv"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-20T09:45:00Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_budget_staffing')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/CSV2TSV')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "copy_csv2tsv",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": "LocationMaster",
									"wildcardFileName": "*",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "PreserveHierarchy"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".tsv"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "Location Code",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Location Code",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "name",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Name",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "address",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Address",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "zip",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Zip",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "inbound_handling_cost",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Inbound Handling Cost",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "outbound_handling_cost",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Outbound Handling Cost",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "status",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Status",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "inbound_processing_time",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Inbound Processing Time",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "outbound_processing_time",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Outbound Processing Time",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "type",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Type",
											"physicalType": "String"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "CSVFILE",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "TSVFILE",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "UTILITY_PIPELINES"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-16T10:33:14Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/CSVFILE')]",
				"[concat(variables('factoryId'), '/datasets/TSVFILE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/CURRENT_BACKLOG')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_activity_current_backlog",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_current_backlog",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"currentbacklog": {},
									"tenantheirarchydetail": {},
									"locationsjoin": {},
									"fulfillmentservices": {},
									"currentbacklogtable": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "d274d239-0ecc-4f5a-8334-5b71f5b09c36"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_current_backlog')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/CURRENT_BACKLOG_UX')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "validation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "setting_status_inprogress",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_validation_current_backlog",
								"type": "DataFlowReference",
								"parameters": {
									"file_path": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'staging','')}'",
										"type": "Expression"
									},
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"currentbackloguxuploadstaging": {},
									"locations": {},
									"fulfillmentservices": {},
									"currentbacklog": {},
									"importhistory": {},
									"ValidCurrentBacklog": {},
									"failedrows": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "runtimeerrorvalidation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "validation",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "runtimefailurecapture",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"runtime_error": {
										"value": "'@{replace(replace(replace(string(json(replace(activity('validation').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {},
									"notifications": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "setting_status_inprogress",
						"type": "ExecuteDataFlow",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "importhistorystatusinprogress",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "rows_failed",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "validation",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "rows_failed",
							"value": {
								"value": "@activity('validation').output.runstatus.metrics.failedrows.rowsWritten",
								"type": "Expression"
							}
						}
					},
					{
						"name": "failedrowscountcheck",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "rows_failed",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('rows_failed'),0)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "dferrorvalidation",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "dffailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"single_quote": "'\\''",
												"file_path": {
													"value": "'@{concat(replace(pipeline().parameters.folder_path,'staging',''),'/',pipeline().parameters.file_name)}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"failure": {},
												"importhistorylookup": {},
												"importhistory": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "transform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "df_transform_current_backlog",
											"type": "DataFlowReference",
											"parameters": {
												"file_path": {
													"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',replace(pipeline().parameters.file_name,'.xlsx',''),'.txt'),'staging','')}'",
													"type": "Expression"
												},
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"currentbacklogmain": {},
												"importhistory": {},
												"locations": {},
												"fulfillmentservices": {},
												"sinkcurrentbacklog": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "runtimeerrortransform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [
										{
											"activity": "transform",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "runtimefailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"runtime_error": {
													"value": "'@{replace(replace(replace(string(json(replace(activity('transform').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
													"type": "Expression"
												},
												"quote": "'\\''"
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notifications": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "StatusComplete",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "importhistorystatusupdate",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"quote": "'\\''",
												"status_value_id": {
													"value": "'@{'2'}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"quote": {
						"type": "string",
						"defaultValue": "'"
					},
					"folder_path": {
						"type": "string",
						"defaultValue": "/DEV/Upload/CurrentBacklog"
					},
					"file_name": {
						"type": "string",
						"defaultValue": "25.xlsx"
					},
					"next_line": {
						"type": "string",
						"defaultValue": "\\n"
					}
				},
				"variables": {
					"transaction_id": {
						"type": "String"
					},
					"rows_failed": {
						"type": "Integer"
					}
				},
				"folder": {
					"name": "IMPORT_MANAGER"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_validation_current_backlog')]",
				"[concat(variables('factoryId'), '/dataflows/runtimefailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusinprogress')]",
				"[concat(variables('factoryId'), '/dataflows/dffailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/df_transform_current_backlog')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusupdate')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/DAILY_ACTUALS')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Daily Actuals Data Load",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_daily_actuals",
								"type": "DataFlowReference",
								"parameters": {
									"file_path": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'main','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"dailyactuals": {},
									"tenantheirarchydetail": {},
									"locationsjoin": {},
									"fulfillmentservices": {},
									"currentbacklogtable": {},
									"failedrowssinkdailyactuals": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"folder_path": {
						"type": "string",
						"defaultValue": "Radial/DailyActuals"
					},
					"file_name": {
						"type": "string",
						"defaultValue": "sample_file.csv"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_daily_actuals')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/DEMAND_FORECAST_UX')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "dataflow_demand_forecast_validation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "StatusInProgress",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_demand_forecast_validation",
								"type": "DataFlowReference",
								"parameters": {
									"file_path": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'staging','')}'",
										"type": "Expression"
									},
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"demandforecastuxupload": {},
									"item": {},
									"locations": {},
									"microarea": {},
									"customertypes": {},
									"fulfillmentservices": {},
									"importhistory": {},
									"TenantHeirarychyDetail": {},
									"demandforecastcheck": {},
									"validdemandforecast": {},
									"failedrows": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "runtimeerrorvalidation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "dataflow_demand_forecast_validation",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "runtimefailurecapture",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"runtime_error": {
										"value": "'@{replace(replace(replace(string(json(replace(activity('dataflow_demand_forecast_validation').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {},
									"notifications": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "StatusInProgress",
						"type": "ExecuteDataFlow",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "importhistorystatusinprogress",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 32,
								"computeType": "MemoryOptimized"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "rows_failed",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "dataflow_demand_forecast_validation",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "rows_failed",
							"value": {
								"value": "@activity('dataflow_demand_forecast_validation').output.runstatus.metrics.failedrows.rowsWritten",
								"type": "Expression"
							}
						}
					},
					{
						"name": "failedrowscountcheck",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "rows_failed",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('rows_failed'),0)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "dferrorvalidation",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "dffailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"single_quote": "'\\''",
												"file_path": {
													"value": "'@{concat(replace(pipeline().parameters.folder_path,'staging',''),'/',pipeline().parameters.file_name)}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"failure": {},
												"importhistorylookup": {},
												"importhistory": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "transform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "df_demand_forecast_core",
											"type": "DataFlowReference",
											"parameters": {
												"file_path": {
													"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',replace(pipeline().parameters.file_name,'.xlsx',''),'.txt'),'staging','')}'",
													"type": "Expression"
												},
												"mode": {
													"value": "'@{'UX-Upload'}'",
													"type": "Expression"
												},
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"demandforecastraw": {},
												"item": {},
												"locations": {},
												"microarea": {},
												"customertype": {},
												"fulfillmentservices": {},
												"tenantheirarchydetail": {},
												"importhistory": {},
												"forecast": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "runtimeerrortransform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [
										{
											"activity": "transform",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "runtimefailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"runtime_error": {
													"value": "'@{replace(replace(replace(string(json(replace(activity('transform').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
													"type": "Expression"
												},
												"quote": "'\\''"
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notifications": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "StatusComplete",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "importhistorystatusupdate",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"quote": "'\\''",
												"status_value_id": {
													"value": "'@{'2'}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"quote": {
						"type": "string",
						"defaultValue": "'"
					},
					"folder_path": {
						"type": "string",
						"defaultValue": "/TEST/Upload/DemandForecast"
					},
					"file_name": {
						"type": "string",
						"defaultValue": "464.xlsx"
					},
					"next_line": {
						"type": "string",
						"defaultValue": "\\n"
					}
				},
				"variables": {
					"transaction_id": {
						"type": "String"
					},
					"rows_failed": {
						"type": "Integer"
					}
				},
				"folder": {
					"name": "IMPORT_MANAGER"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_demand_forecast_validation')]",
				"[concat(variables('factoryId'), '/dataflows/runtimefailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusinprogress')]",
				"[concat(variables('factoryId'), '/dataflows/dffailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/df_demand_forecast_core')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusupdate')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/EDA')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "dataflow_eda",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "dataflow_EDA",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "7d4ec7d9-56b7-4455-ade7-d54704c72f4d"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "UTILITY_PIPELINES"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/dataflow_EDA')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FULFILLMENT_FORECAST')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_activity_fulfillment_forecast",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_fulfillment_forecast",
								"type": "DataFlowReference",
								"parameters": {
									"filename": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'main','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"fulfillmentforecast": {},
									"TenantHeirarchyDetail": {},
									"LocationMaster": {},
									"sinkfullfillmentforecast": {},
									"sinkfailedftpfiles": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"folder_path": {
						"type": "string",
						"defaultValue": "Radial/FulfillmentForecast"
					},
					"file_name": {
						"type": "string",
						"defaultValue": "sample_file_ff_20240624.csv"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-16T10:33:14Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_fulfillment_forecast')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FULFILLMENT_FORECAST_UX')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "validation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "setting_status_inprogress",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_fulfillment_forcast_ux",
								"type": "DataFlowReference",
								"parameters": {
									"file_path": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'staging','')}'",
										"type": "Expression"
									},
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"FulfillmentSource": {},
									"importHistory": {},
									"importLocations": {},
									"fulfillmentservices": {},
									"fulfillmentforecast": {},
									"validfulfillmentforecast": {},
									"failedrows": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "runtimeerrorvalidation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "validation",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "runtimefailurecapture",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"runtime_error": {
										"value": "'@{replace(replace(replace(string(json(replace(activity('validation').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {},
									"notifications": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "setting_status_inprogress",
						"type": "ExecuteDataFlow",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "importhistorystatusinprogress",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "rows_failed",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "validation",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "rows_failed",
							"value": {
								"value": "@activity('validation').output.runstatus.metrics.failedrows.rowsWritten",
								"type": "Expression"
							}
						}
					},
					{
						"name": "failedrowscountcheck",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "rows_failed",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('rows_failed'),0)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "dferrorvalidation",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "dffailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"single_quote": "'\\''",
												"file_path": {
													"value": "'@{concat(replace(pipeline().parameters.folder_path,'staging',''),'/',pipeline().parameters.file_name)}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"failure": {},
												"importhistorylookup": {},
												"importhistory": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "transform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "df_transform_fulfillment_forecast_ux",
											"type": "DataFlowReference",
											"parameters": {
												"file_path": {
													"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',replace(pipeline().parameters.file_name,'.xlsx',''),'.txt'),'staging','')}'",
													"type": "Expression"
												},
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"fulfillmentforecastmain": {},
												"importhistory": {},
												"locations": {},
												"fulfillmentservices": {},
												"sinkfulfillmentforecast": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "runtimeerrortransform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [
										{
											"activity": "transform",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "runtimefailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"runtime_error": {
													"value": "'@{replace(replace(replace(string(json(replace(activity('transform').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
													"type": "Expression"
												},
												"quote": "'\\''"
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notifications": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "StatusComplete",
									"type": "ExecuteDataFlow",
									"dependsOn": [
										{
											"activity": "transform",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "importhistorystatusupdate",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"quote": "'\\''",
												"status_value_id": {
													"value": "'@{'2'}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"quote": {
						"type": "string",
						"defaultValue": "'"
					},
					"folder_path": {
						"type": "string"
					},
					"file_name": {
						"type": "string"
					},
					"next_line": {
						"type": "string",
						"defaultValue": "\\n"
					}
				},
				"variables": {
					"transaction_id": {
						"type": "String"
					},
					"rows_failed": {
						"type": "Integer"
					}
				},
				"folder": {
					"name": "IMPORT_MANAGER"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_fulfillment_forcast_ux')]",
				"[concat(variables('factoryId'), '/dataflows/runtimefailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusinprogress')]",
				"[concat(variables('factoryId'), '/dataflows/dffailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/df_transform_fulfillment_forecast_ux')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusupdate')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/INVENTORY')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_activity_inventory",
						"description": "test publish test",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_inventory",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"inventory": {},
									"ItemMaster": {},
									"LocationMaster": {},
									"TenantHeirarchyTable": {},
									"EnumType": {},
									"EnumValues": {},
									"Write2Inventory": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "37682b5c-5f39-47c5-97e5-ebbed3aa67bf"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-09T13:11:24Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_inventory')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/INVENTORY_UX')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "validation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "setting_status_inprogress",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_inventory_ux",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"file_path": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'staging','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"tenanthierarchy": {},
									"importhistory": {},
									"fetchinglocations": {},
									"fetchingitems": {},
									"fetchinginventorysource": {},
									"fetchinginventory": {},
									"validinventoryrows": {},
									"failedrows": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "runtimeerrorvalidation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "validation",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "runtimefailurecapture",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"runtime_error": {
										"value": "'@{replace(replace(replace(string(json(replace(activity('validation').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {},
									"notifications": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "setting_status_inprogress",
						"type": "ExecuteDataFlow",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "importhistorystatusinprogress",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "rows_failed",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "validation",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "rows_failed",
							"value": {
								"value": "@activity('validation').output.runstatus.metrics.failedrows.rowsWritten",
								"type": "Expression"
							}
						}
					},
					{
						"name": "failedrowscountcheck",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "rows_failed",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('rows_failed'),0)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "dferrorvalidation",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "dffailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"single_quote": "'\\''",
												"file_path": {
													"value": "'@{concat(replace(pipeline().parameters.folder_path,'staging',''),'/',pipeline().parameters.file_name)}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"failure": {},
												"importhistorylookup": {},
												"importhistory": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "transform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "df_transform_inventory",
											"type": "DataFlowReference",
											"parameters": {
												"file_path": {
													"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',replace(pipeline().parameters.file_name,'.xlsx',''),'.txt'),'staging','')}'",
													"type": "Expression"
												},
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"inventorymain": {},
												"importhistory": {},
												"locations": {},
												"item": {},
												"tenantheirarchydetail": {},
												"sinkinventory": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "runtimeerrortransform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [
										{
											"activity": "transform",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "runtimefailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"runtime_error": {
													"value": "'@{replace(replace(replace(string(json(replace(activity('transform').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
													"type": "Expression"
												},
												"quote": "'\\''"
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notifications": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "StatusComplete",
									"type": "ExecuteDataFlow",
									"dependsOn": [
										{
											"activity": "transform",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "importhistorystatusupdate",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"quote": "'\\''",
												"status_value_id": {
													"value": "'@{'2'}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"quote": {
						"type": "string",
						"defaultValue": "'"
					},
					"folder_path": {
						"type": "string",
						"defaultValue": "DEV/Upload/Inventory"
					},
					"file_name": {
						"type": "string",
						"defaultValue": "272.xlsx"
					},
					"next_line": {
						"type": "string",
						"defaultValue": "\\n"
					}
				},
				"variables": {
					"transaction_id": {
						"type": "String"
					},
					"rows_failed": {
						"type": "Integer"
					}
				},
				"folder": {
					"name": "IMPORT_MANAGER"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_inventory_ux')]",
				"[concat(variables('factoryId'), '/dataflows/runtimefailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusinprogress')]",
				"[concat(variables('factoryId'), '/dataflows/dffailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/df_transform_inventory')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusupdate')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ITEM_MASTER')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_activity_item_master",
						"description": "dataflow activity transforming data from storage account and populate it to inventory table",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_item_master",
								"type": "DataFlowReference",
								"parameters": {
									"filepath": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'main','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"ItemMasterRaw": {},
									"ItemHeirarchyDetail": {},
									"TenantHeirarchyDetail": {},
									"LifecycleStatus": {},
									"TemporaryOutput": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"folder_path": {
						"type": "string",
						"defaultValue": "main/Radial/ItemMaster"
					},
					"file_name": {
						"type": "string",
						"defaultValue": "sample_file.csv"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-09T13:33:42Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_item_master')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ITEM_MASTER_DATALAKE')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Item Master Files Copy To Datalake",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": "Radial/ItemMaster",
									"wildcardFileName": {
										"value": "@pipeline().parameters.filename",
										"type": "Expression"
									},
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "PreserveHierarchy"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ITEM_MASTER_RAW",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ITEM_MASTER_DL_STORE",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"filename": {
						"type": "string",
						"defaultValue": "sample_file.csv"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ITEM_MASTER_RAW')]",
				"[concat(variables('factoryId'), '/datasets/ITEM_MASTER_DL_STORE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LANE_RATES')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_activity_lane_rates",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_lane_rates",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"LaneRateForGround": {},
									"HeirarchyTable": {},
									"LaneRateForNDA": {},
									"LaneRateFor2DA": {},
									"tempoutput": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-09T14:08:01Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_lane_rates')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LOCATION_MASTER')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_activity_location_master",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_location_master",
								"type": "DataFlowReference",
								"parameters": {
									"file_path": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'main','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"LocationMasterRaw": {},
									"TenantHeirarchyDetail": {},
									"TenantHierarchyDetail": {},
									"WriteToLocationsTable": {},
									"failedrowslocationmaster": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "07bf77db-08a7-4725-afab-425dfbda5236"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"folder_path": {
						"type": "string",
						"defaultValue": "Radial/LocationMaster"
					},
					"file_name": {
						"type": "String",
						"defaultValue": "data_107e2644-2ce0-4274-abb8-2ad1ea4d944d_d6b001c9-e396-41a1-ad43-b5f3d1aebeae.csv"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-10T12:18:39Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_location_master')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LOCATION_STAFFING')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "validation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "setting_status_inprogress",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_validation_location_staffing",
								"type": "DataFlowReference",
								"parameters": {
									"file_path": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'staging','')}'",
										"type": "Expression"
									},
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"locationstaffingux": {},
									"locations": {},
									"operationalprofile": {},
									"enumvalues": {},
									"operationalcalendar": {},
									"importhistory": {},
									"ValidLocationStaffingRows": {},
									"failedrows": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "runtimeerrorvalidation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "validation",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "runtimefailurecapture",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"runtime_error": {
										"value": "'@{replace(replace(replace(string(json(replace(activity('validation').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {},
									"notifications": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "setting_status_inprogress",
						"type": "ExecuteDataFlow",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "importhistorystatusinprogress",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "rows_failed",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "validation",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "rows_failed",
							"value": {
								"value": "@activity('validation').output.runstatus.metrics.failedrows.rowsWritten",
								"type": "Expression"
							}
						}
					},
					{
						"name": "failedrowscountcheck",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "rows_failed",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('rows_failed'),0)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "dferrorvalidation",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "dffailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"single_quote": "'\\''",
												"file_path": {
													"value": "'@{concat(replace(pipeline().parameters.folder_path,'staging',''),'/',pipeline().parameters.file_name)}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"failure": {},
												"importhistorylookup": {},
												"importhistory": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "transform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "df_transform_location_staffing",
											"type": "DataFlowReference",
											"parameters": {
												"file_path": {
													"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',replace(pipeline().parameters.file_name,'.xlsx',''),'.txt'),'staging','')}'",
													"type": "Expression"
												},
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"locationstaffingmain": {},
												"importhistory": {},
												"locations": {},
												"enumvalue": {},
												"operationalprofile": {},
												"sinkopeartionalcalendar": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "runtimeerrortransform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [
										{
											"activity": "transform",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "runtimefailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"runtime_error": {
													"value": "'@{replace(replace(replace(string(json(replace(activity('transform').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
													"type": "Expression"
												},
												"quote": "'\\''"
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notifications": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "StatusComplete",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "importhistorystatusupdate",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"quote": "'\\''",
												"status_value_id": {
													"value": "'@{'2'}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"quote": {
						"type": "string",
						"defaultValue": "'"
					},
					"folder_path": {
						"type": "string",
						"defaultValue": "/TEST/Upload/LocationStaffing"
					},
					"file_name": {
						"type": "string",
						"defaultValue": "16.xlsx"
					},
					"next_line": {
						"type": "string",
						"defaultValue": "\\n"
					}
				},
				"variables": {
					"transaction_id": {
						"type": "String"
					},
					"rows_failed": {
						"type": "Integer"
					}
				},
				"folder": {
					"name": "IMPORT_MANAGER"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_validation_location_staffing')]",
				"[concat(variables('factoryId'), '/dataflows/runtimefailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusinprogress')]",
				"[concat(variables('factoryId'), '/dataflows/dffailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/df_transform_location_staffing')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusupdate')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LOCATION_UX')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "validation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "setting_status_inprogress",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_locations_ux",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"file_path": {
										"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',pipeline().parameters.file_name),'staging','')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"FetchingLocations": {},
									"importHistory": {},
									"ExcelSource": {},
									"source1": {},
									"fetchingtenentdetails": {},
									"loadlocationsdatadb": {},
									"failedrows": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "runtimeerrorvalidation",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "validation",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "runtimefailurecapture",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"runtime_error": {
										"value": "'@{replace(replace(replace(string(json(replace(activity('validation').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {},
									"notifications": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "setting_status_inprogress",
						"type": "ExecuteDataFlow",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "importhistorystatusinprogress",
								"type": "DataFlowReference",
								"parameters": {
									"transaction_id": {
										"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
										"type": "Expression"
									},
									"quote": "'\\''"
								},
								"datasetParameters": {
									"importhistory": {},
									"importhistorysink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "rows_failed",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "validation",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "rows_failed",
							"value": {
								"value": "@activity('validation').output.runstatus.metrics.failedrows.rowsWritten",
								"type": "Expression"
							}
						}
					},
					{
						"name": "failedrowscountcheck",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "rows_failed",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('rows_failed'),0)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "dferrorvalidation",
									"type": "ExecuteDataFlow",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "dffailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"single_quote": "'\\''",
												"file_path": {
													"value": "'@{concat(replace(pipeline().parameters.folder_path,'staging',''),'/',pipeline().parameters.file_name)}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"failure": {},
												"importhistorylookup": {},
												"importhistory": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "transform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "df_transform_location_ux",
											"type": "DataFlowReference",
											"parameters": {
												"file_path": {
													"value": "'@{replace(concat(pipeline().parameters.folder_path,'/',replace(pipeline().parameters.file_name,'.xlsx',''),'.txt'),'staging','')}'",
													"type": "Expression"
												},
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"locationmain": {},
												"importhistory": {},
												"locationtype": {},
												"tenantheirarchydetail": {},
												"sinklocation": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "runtimeerrortransform",
									"type": "ExecuteDataFlow",
									"state": "Inactive",
									"onInactiveMarkAs": "Succeeded",
									"dependsOn": [
										{
											"activity": "transform",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "runtimefailurecapture",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"runtime_error": {
													"value": "'@{replace(replace(replace(string(json(replace(activity('transform').error.message,'\\n',' ')).Message),pipeline().parameters.quote,' '),'\"',''),pipeline().parameters.next_line,' ')}'",
													"type": "Expression"
												},
												"quote": "'\\''"
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notifications": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								},
								{
									"name": "StatusComplete",
									"type": "ExecuteDataFlow",
									"dependsOn": [
										{
											"activity": "transform",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataflow": {
											"referenceName": "importhistorystatusupdate",
											"type": "DataFlowReference",
											"parameters": {
												"transaction_id": {
													"value": "'@{replace(pipeline().parameters.file_name,'.xlsx','')}'",
													"type": "Expression"
												},
												"quote": "'\\''",
												"status_value_id": {
													"value": "'@{'2'}'",
													"type": "Expression"
												}
											},
											"datasetParameters": {
												"importhistory": {},
												"importhistorysink": {},
												"notification": {}
											}
										},
										"staging": {},
										"compute": {
											"coreCount": 8,
											"computeType": "General"
										},
										"traceLevel": "Fine"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"quote": {
						"type": "string",
						"defaultValue": "'"
					},
					"folder_path": {
						"type": "string",
						"defaultValue": "DEV/Upload/Location"
					},
					"file_name": {
						"type": "string",
						"defaultValue": "36.xlsx"
					},
					"next_line": {
						"type": "string",
						"defaultValue": "\\n"
					}
				},
				"variables": {
					"transaction_id": {
						"type": "String"
					},
					"rows_failed": {
						"type": "Integer"
					}
				},
				"folder": {
					"name": "IMPORT_MANAGER"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_locations_ux')]",
				"[concat(variables('factoryId'), '/dataflows/runtimefailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusinprogress')]",
				"[concat(variables('factoryId'), '/dataflows/dffailurecapture')]",
				"[concat(variables('factoryId'), '/dataflows/df_transform_location_ux')]",
				"[concat(variables('factoryId'), '/dataflows/importhistorystatusupdate')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/MOVE_FILES_FOR_PROCESSING')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "SFTP2STAGING",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "BinarySource",
								"storeSettings": {
									"type": "SftpReadSettings",
									"recursive": true,
									"wildcardFolderPath": "outbound",
									"wildcardFileName": "*.csv",
									"deleteFilesAfterCompletion": true,
									"disableChunking": false
								},
								"formatSettings": {
									"type": "BinaryReadSettings"
								}
							},
							"sink": {
								"type": "BinarySink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "PreserveHierarchy"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "sftp_files_binary",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "STAGING_BINARY_FILES",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "REMOTE"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/sftp_files_binary')]",
				"[concat(variables('factoryId'), '/datasets/STAGING_BINARY_FILES')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/MOVE_STAGGING_MAIN')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_validation_location_staffing",
								"type": "DataFlowReference",
								"parameters": {
									"file_path": {
										"value": "'@{pipeline().parameters.file_path}'",
										"type": "Expression"
									},
									"transaction_id": {
										"value": "'@{pipeline().parameters.transaction_id}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"locationstaffingux": {},
									"locations": {},
									"operationalprofile": {},
									"enumvalues": {},
									"operationalcalendar": {},
									"importhistory": {},
									"ValidLocationStaffingRows": {},
									"failedrows": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"file_path": {
						"type": "string",
						"defaultValue": "DEV/Upload/LocationStaffing/17.xlsx"
					},
					"transaction_id": {
						"type": "string",
						"defaultValue": "17"
					}
				},
				"folder": {
					"name": "REMOTE"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_validation_location_staffing')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ORDER_HISTORY')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_order_history",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_order_history",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"orderhistoryraw": {},
									"TenantHeirarchyDetail": {},
									"OrderHistory": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 32,
								"computeType": "MemoryOptimized"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "bd83f014-f182-4d2c-8f76-89b0fa32937d"
							}
						}
					},
					{
						"name": "Notify Mail",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "df_order_status_history",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {},
							"url": "https://prod-69.eastus.logic.azure.com:443/workflows/0755ac6ab8ba4359b56ea72ce6dc03e9/triggers/manual/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=j4Y5kxvgBtB_wNtZkEsXV79Asm4Ct1qzmlV9R7zf8uc",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "{\n\"datafactoryname\" : \"@{pipeline().DataFactory}\", \n\"pipelineName\" : \"@{pipeline().Pipeline}\", \n\"runID\" : \"@{pipeline().RunId}\",\n\"records_read_from_file\" : \"@{activity('df_order_history').output.runStatus.metrics.OrderHistory.sources.orderhistoryraw.rowsRead}\",\n\"records_written_order_history\" : \"@{activity('df_order_history').output.runStatus.metrics.OrderHistory.rowsWritten}\",\n\"records_written_order_line_history\" : \"@{activity('df_order_line_history').output.runStatus.metrics.OrderLineHistory.rowsWritten}\",\n\"records_written_order_status_history\" : \"@{activity('df_order_status_history').output.runStatus.metrics.OrderStatusHistory.rowsWritten}\" ,\"time_taken_order_history\":\"@{activity('df_order_history').Duration}\",\n\"time_taken_order_line_history\":\"@{activity('df_order_line_history').Duration}\",\n\"time_taken_order_status_history\":\"@{activity('df_order_status_history').Duration}\"\n}",
								"type": "Expression"
							}
						}
					},
					{
						"name": "df_order_line_history",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "df_order_history",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_order_line_history",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"orderhistoryraw": {},
									"TenantHeirarchyDetail": {},
									"OrderHistory": {},
									"OrderLineHistory": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 32,
								"computeType": "MemoryOptimized"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "15bce445-52eb-4c37-9bcf-1b6d6720d802"
							}
						}
					},
					{
						"name": "df_order_status_history",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "df_order_line_history",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_order_status_history",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"orderhistoryraw": {},
									"TenantHeirarchyDetail": {},
									"OrderHistory": {},
									"OrderStatusHistory": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 32,
								"computeType": "MemoryOptimized"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "9a27ee55-a57e-4214-9863-64ee1eea9dc9"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "REMOTE"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_order_history')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('factoryId'), '/dataflows/df_order_line_history')]",
				"[concat(variables('factoryId'), '/dataflows/df_order_status_history')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ORDER_HISTORY_COPY')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "orderhistorycopy2datalake",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": "Radial/OrderHistory",
									"wildcardFileName": {
										"value": "@pipeline().parameters.filename",
										"type": "Expression"
									},
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "PreserveHierarchy"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ORDER_HISTORY_RAW",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "orderhistory_mllake",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"filename": {
						"type": "string",
						"defaultValue": "2021B1_WMS_ORDER_HISTORY.csv"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ORDER_HISTORY_RAW')]",
				"[concat(variables('factoryId'), '/datasets/orderhistory_mllake')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SAMPLE_SFTP_PUSH')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "samplefilepush",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "BinarySource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"modifiedDatetimeStart": "2024-06-23T00:00:00.000Z",
									"deleteFilesAfterCompletion": false
								},
								"formatSettings": {
									"type": "BinaryReadSettings"
								}
							},
							"sink": {
								"type": "BinarySink",
								"storeSettings": {
									"type": "SftpWriteSettings",
									"copyBehavior": "PreserveHierarchy",
									"operationTimeout": "01:00:00",
									"useTempFileRename": true
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "temp_binary_sample_files",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "sftp_files_binary",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "UTILITY_PIPELINES"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/temp_binary_sample_files')]",
				"[concat(variables('factoryId'), '/datasets/sftp_files_binary')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SFTP_REDIRECT_BLOB_SINGLE')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Fetchallrecords",
						"type": "GetMetadata",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "BinaryOutbound",
								"type": "DatasetReference",
								"parameters": {
									"folder_name": {
										"value": "@pipeline().parameters.folder_path",
										"type": "Expression"
									}
								}
							},
							"fieldList": [
								"childItems"
							],
							"storeSettings": {
								"type": "SftpReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false,
								"disableChunking": false
							},
							"formatSettings": {
								"type": "BinaryReadSettings"
							}
						}
					},
					{
						"name": "Filter1",
						"type": "Filter",
						"dependsOn": [
							{
								"activity": "Fetchallrecords",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Fetchallrecords').output.childItems",
								"type": "Expression"
							},
							"condition": {
								"value": "@equals(item().type,'File')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Filter1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Filter1').output.Value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "copymultiplefiles",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Set variable1",
											"dependencyConditions": [
												"Completed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "BinarySource",
											"storeSettings": {
												"type": "SftpReadSettings",
												"recursive": true,
												"deleteFilesAfterCompletion": false,
												"disableChunking": false
											},
											"formatSettings": {
												"type": "BinaryReadSettings"
											}
										},
										"sink": {
											"type": "BinarySink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings",
												"copyBehavior": "PreserveHierarchy"
											}
										},
										"enableStaging": false
									},
									"inputs": [
										{
											"referenceName": "BinaryOutbound_FetchFiles",
											"type": "DatasetReference",
											"parameters": {
												"folder_name": {
													"value": "@pipeline().parameters.folder_path",
													"type": "Expression"
												},
												"file_name": {
													"value": "@item().name",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "BinaryDataDestination",
											"type": "DatasetReference",
											"parameters": {
												"Container": {
													"value": "@pipeline().parameters.container",
													"type": "Expression"
												},
												"Directory": {
													"value": "@variables('output_path')[0]",
													"type": "Expression"
												},
												"filename": {
													"value": "@item().name",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "deletemultiplefiles",
									"type": "Delete",
									"dependsOn": [
										{
											"activity": "copymultiplefiles",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "BinaryOutbound_FetchFiles",
											"type": "DatasetReference",
											"parameters": {
												"folder_name": {
													"value": "@pipeline().parameters.folder_path",
													"type": "Expression"
												},
												"file_name": {
													"value": "@item().name",
													"type": "Expression"
												}
											}
										},
										"enableLogging": false,
										"storeSettings": {
											"type": "SftpReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false,
											"disableChunking": false
										}
									}
								},
								{
									"name": "Set variable1",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "output_path",
										"value": {
											"value": "@if(\n    contains(toLower(item().name), 'order'),\n    json('[\"Radial/OrderHistory\"]'),\n    if(\n        contains(toLower(item().name), 'shipment'),\n        json('[\"Radial/ShipmentHistory\"]'),\n        if(\n            contains(toLower(item().name), 'budget'),\n            json('[\"Radial/BudgetStaffing\"]'),\n            if(\n                contains(toLower(item().name), 'daily'),\n                json('[\"Radial/DailyActuals\"]'),\n                if(\n                    contains(toLower(item().name), 'fulfillment'),\n                    json('[\"Radial/FulfillmentForecast\"]'),\n                    if(\n                        contains(toLower(item().name), 'item'),\n                        json('[\"Radial/ItemMaster\"]'),\n                        if(\n                            contains(toLower(item().name), 'location'),\n                            json('[\"Radial/LocationMaster\"]'),\n                            if(\n                                contains(toLower(item().name), 'staffing'),\n                                json('[\"Radial/StaffingHistory\"]'),\n                                json('[\"C\"]')\n                            )\n                        )\n                    )\n                )\n            )\n        )\n    )\n)",
											"type": "Expression"
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"folder_path": {
						"type": "string",
						"defaultValue": "outbound"
					},
					"container": {
						"type": "string",
						"defaultValue": "main"
					}
				},
				"variables": {
					"file_path": {
						"type": "Array"
					},
					"output_path": {
						"type": "Array"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/BinaryOutbound')]",
				"[concat(variables('factoryId'), '/datasets/BinaryOutbound_FetchFiles')]",
				"[concat(variables('factoryId'), '/datasets/BinaryDataDestination')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SFTP_TO_MAIN_FOR_PROCESSING')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Move files from one folder to another folder",
				"activities": [
					{
						"name": "GetFileList",
						"description": "Get the list of file",
						"type": "GetMetadata",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "BinaryDataSource_Folder",
								"type": "DatasetReference",
								"parameters": {
									"FolderPath": {
										"value": "@pipeline().parameters.SourceStore_Location",
										"type": "Expression"
									},
									"Directory": {
										"value": "@pipeline().parameters.SourceStore_Directory",
										"type": "Expression"
									}
								}
							},
							"fieldList": [
								"childItems"
							],
							"storeSettings": {
								"type": "SftpReadSettings",
								"recursive": true
							},
							"formatSettings": {
								"type": "BinaryReadSettings"
							}
						}
					},
					{
						"name": "ForEachFile",
						"description": "Iterate each file, and move them one by one.",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "FilterFiles",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('FilterFiles').output.value",
								"type": "Expression"
							},
							"batchCount": 20,
							"activities": [
								{
									"name": "CopyAFile",
									"description": "Copy a file from the source store to the destination store.",
									"type": "Copy",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "BinarySource",
											"storeSettings": {
												"type": "SftpReadSettings",
												"recursive": true
											},
											"formatSettings": {
												"type": "BinaryReadSettings"
											},
											"recursive": false
										},
										"sink": {
											"type": "BinarySink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings",
												"copyBehavior": "PreserveHierarchy"
											}
										},
										"enableStaging": false,
										"dataIntegrationUnits": 0
									},
									"inputs": [
										{
											"referenceName": "BinaryDataSource_File",
											"type": "DatasetReference",
											"parameters": {
												"FolderPath": {
													"value": "@pipeline().parameters.SourceStore_Location",
													"type": "Expression"
												},
												"Directory": {
													"value": "@pipeline().parameters.SourceStore_Directory",
													"type": "Expression"
												},
												"filename": {
													"value": "@item().name",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "BinaryDataDestination",
											"type": "DatasetReference",
											"parameters": {
												"Container": {
													"value": "@pipeline().parameters.DestinationStore_Location",
													"type": "Expression"
												},
												"Directory": {
													"value": "@pipeline().parameters.DestinationStore_Directory",
													"type": "Expression"
												},
												"filename": {
													"value": "@item().name",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "DeleteAFile",
									"description": "Delete a file from the source store",
									"type": "Delete",
									"dependsOn": [
										{
											"activity": "CopyAFile",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "BinaryDataSource_File",
											"type": "DatasetReference",
											"parameters": {
												"FolderPath": {
													"value": "@pipeline().parameters.SourceStore_Location",
													"type": "Expression"
												},
												"Directory": {
													"value": "@pipeline().parameters.SourceStore_Directory",
													"type": "Expression"
												},
												"filename": {
													"value": "@item().name",
													"type": "Expression"
												}
											}
										},
										"enableLogging": false,
										"storeSettings": {
											"type": "SftpReadSettings",
											"recursive": true
										}
									}
								}
							]
						}
					},
					{
						"name": "FilterFiles",
						"description": "Only files will be selected, the source-folders will not be selected.",
						"type": "Filter",
						"dependsOn": [
							{
								"activity": "GetFileList",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('GetFileList').output.childItems",
								"type": "Expression"
							},
							"condition": {
								"value": "@equals(item().type, 'File')",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"SourceStore_Location": {
						"type": "String",
						"defaultValue": "outbound"
					},
					"SourceStore_Directory": {
						"type": "String",
						"defaultValue": "StaffingHistory"
					},
					"DestinationStore_Location": {
						"type": "String",
						"defaultValue": "main"
					},
					"DestinationStore_Directory": {
						"type": "String",
						"defaultValue": "Radial/StaffingHistory"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/BinaryDataSource_Folder')]",
				"[concat(variables('factoryId'), '/datasets/BinaryDataSource_File')]",
				"[concat(variables('factoryId'), '/datasets/BinaryDataDestination')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SFTP_TO_STORAGE')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": "Radial/OrderHistory/OH",
									"wildcardFileName": "2021B*",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "PreserveHierarchy"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".csv"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "Order ID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order ID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order Line ID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Line ID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Location ID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Location ID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Channel",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Channel",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order date",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Date",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order Original Ship date",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Original Ship Date",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order Actual Ship date",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Actual Ship Date",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order due date",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Due Date",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order Received (in Warehouse) Date and time",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Received Date and Time",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order Completed (in Warehouse) Date and time",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Completed Date and Time",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Destination zip code (Ship to)",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Destination Zip Code",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Item code",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Item Code",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order quantity",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Quantity",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Quantity (UOM) Picked",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Quantity (UOM) Picked",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order Status",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Status",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Carrier",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Carrier",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Service Type",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Service Type",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Shipment Fees",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Shipment Fees",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order Value",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Value",
											"type": "String",
											"physicalType": "String"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ORDER_HISTORY_SFTP",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ORDER_HISTORY_RAW",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "REMOTE"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ORDER_HISTORY_SFTP')]",
				"[concat(variables('factoryId'), '/datasets/ORDER_HISTORY_RAW')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SHIPMENT_HISTORY')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_shipment_history",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_shipment_history",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"shipmenthistoryraw": {},
									"tenantheirarchydetail": {},
									"orderlinetable": {},
									"orderhistory": {},
									"orderstatushistory": {},
									"ShipmentHistory": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "4dfa84a5-86d5-4909-82ce-972c39e64017"
							}
						}
					},
					{
						"name": "df_shipment_line_history",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "df_shipment_history",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_shipment_line_history",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"shipmenthistoryraw": {},
									"tenantheirarchytable": {},
									"orderlinehistory": {},
									"shipmenthistory": {},
									"ShipmentLineHistory": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "b14fc32f-e468-4b0b-b227-ccfd1ec5562a"
							}
						}
					},
					{
						"name": "Notify_shipment_history",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "df_shipment_line_history",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {},
							"url": "https://prod-24.eastus.logic.azure.com:443/workflows/3f1f036d9abd4a62b2bc78fb3b8d2d28/triggers/manual/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=En5Cc4PP9vYZHA_L0IiC9QO75q-a5sSAn08HSO_fU_s",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "{\n\"datafactoryname\" : \"@{pipeline().DataFactory}\", \n\"pipelineName\" : \"@{pipeline().Pipeline}\", \n\"runID\" : \"@{pipeline().RunId}\",\n\"records_read_from_file\" : \"@{activity('df_shipment_history').output.runStatus.metrics.ShipmentHistory.sources.shipmenthistoryraw.rowsRead}\",\n\"records_written_shipment_history\" : \"@{activity('df_shipment_history').output.runStatus.metrics.ShipmentHistory.rowsWritten}\",\n\"records_written_shipment_line_history\" : \"@{activity('df_shipment_line_history').output.runStatus.metrics.ShipmentLineHistory.rowsWritten}\",\n\"time_taken_shipment_history\":\"@{activity('df_shipment_history').Duration}\",\n\"time_taken_shipment_line_history\":\"@{activity('df_shipment_line_history').Duration}\"\n}",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "REMOTE"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_shipment_history')]",
				"[concat(variables('factoryId'), '/dataflows/df_shipment_line_history')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SHIPMENT_HISTORY_COPY')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "loadtodatalakeshipmenthistory",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": "Radial/ShipmentHistory",
									"wildcardFileName": {
										"value": "@pipeline().parameters.filename",
										"type": "Expression"
									},
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "PreserveHierarchy"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "SHIPMENT_HISTORY_RAW",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "shipment_history_mldatalake",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"filename": {
						"type": "string",
						"defaultValue": "2021B1_WMS_SHIPMENT_HISTORY.csv"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/SHIPMENT_HISTORY_RAW')]",
				"[concat(variables('factoryId'), '/datasets/shipment_history_mldatalake')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SHIPMENT_HISTORY_STAGING_TO_MAIN')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "SFTP_TO_MAIN",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": "Radial/OrderHistory/SH",
									"wildcardFileName": "*SHIPMENT_HISTORY.csv",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "PreserveHierarchy"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".csv"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "Shipment ID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Shipment ID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Order Line ID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Order Line ID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Location ID",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Location ID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Carrier Name",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Carrier Name",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Mode",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Mode",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Total Units",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Total Units",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Total Shipment Weight",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Total Shipment Weight",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Total Shipment Volume",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Total Shipment Volume",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Total Shipment Cost",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Total Shipment Cost",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Total Shipment Value",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Total Shipment Value",
											"type": "String",
											"physicalType": "String"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "SHIPMENT_HISTORY_STAGING",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "SHIPMENT_HISTORY_RAW",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "REMOTE"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/SHIPMENT_HISTORY_STAGING')]",
				"[concat(variables('factoryId'), '/datasets/SHIPMENT_HISTORY_RAW')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/STAFFING_HISTORY')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "CopyingStaffingHistory",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": false,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "PreserveHierarchy"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "STAFFING_HISTORY_RAW",
								"type": "DatasetReference",
								"parameters": {
									"file_name": {
										"value": "@pipeline().parameters.file_name",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "staffing_history_mldatalake",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"file_name": {
						"type": "string"
					}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/STAFFING_HISTORY_RAW')]",
				"[concat(variables('factoryId'), '/datasets/staffing_history_mldatalake')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/THROUGHPUT_PREDICTIONS')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_activity_throughput",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_throughput_predictions",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"throughtputoutput": {},
									"TenantHeirarchyTable": {},
									"LocationsTable": {},
									"EnumTypeDB": {},
									"EnumValue": {},
									"WriteToDatabase": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "REMOTE"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-10T12:18:39Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_throughput_predictions')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/TRANSPORTATION_LANES')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_activity_transportation_lanes",
						"description": "Dataflow actvity to transform data to transportation_lane table",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_transportation_lane",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"RawDataForZone": {},
									"TenantHeirarchyTable": {},
									"TransitTimeTable": {},
									"LocationsTable": {},
									"WriteToDatabase": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "d32679e3-42d6-41a0-861e-373bbc45824b"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-10T12:18:39Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_transportation_lane')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ZONE')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Pipeline built on 2023-08-08",
				"activities": [
					{
						"name": "df_activity_zone",
						"description": "Dataflow activity for zone table",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_zone",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"RawDataForZone": {},
									"TenantHeirarchyTable": {},
									"WriteToDatabase": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine",
							"continuationSettings": {
								"customizedCheckpointKey": "1c7e1575-29b2-429d-b3e5-04524c8d01b6"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "FTP"
				},
				"annotations": [],
				"lastPublishTime": "2023-10-09T13:03:57Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_zone')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/BUDGET_STAFFING_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/BudgetStaffing",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Organization ID",
						"type": "String"
					},
					{
						"name": "Business ID",
						"type": "String"
					},
					{
						"name": "Location Code",
						"type": "String"
					},
					{
						"name": "Staffing Profile",
						"type": "String"
					},
					{
						"name": "Date",
						"type": "String"
					},
					{
						"name": "Units per Hour",
						"type": "String"
					},
					{
						"name": "Max FTE Regular Hours",
						"type": "String"
					},
					{
						"name": "Min FTE Regular Hours",
						"type": "String"
					},
					{
						"name": "Max Temp Regular Hours",
						"type": "String"
					},
					{
						"name": "Min Temp Regular Hours",
						"type": "String"
					},
					{
						"name": "Max FTE Overtime Hours",
						"type": "String"
					},
					{
						"name": "Max Temp Overtime Hours",
						"type": "String"
					},
					{
						"name": "Regular FTE Wage",
						"type": "String"
					},
					{
						"name": "Regular Temp Wage",
						"type": "String"
					},
					{
						"name": "Overtime FTE Wage",
						"type": "String"
					},
					{
						"name": "Overtime Temp Wage",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/BinaryDataDestination')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "It describes the destination store.",
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Container": {
						"type": "String"
					},
					"Directory": {
						"type": "String"
					},
					"filename": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@{dataset().Directory}",
							"type": "Expression"
						},
						"fileSystem": {
							"value": "@{dataset().Container}",
							"type": "Expression"
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/BinaryDataSource_File')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "It describes the file in the data source store.",
				"linkedServiceName": {
					"referenceName": "SFTP_RADIAL_STORAGE",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"FolderPath": {
						"type": "String"
					},
					"Directory": {
						"type": "String"
					},
					"filename": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "SftpLocation",
						"fileName": {
							"value": "@dataset().filename",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@concat(dataset().FolderPath,'/',dataset().Directory)",
							"type": "Expression"
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/SFTP_RADIAL_STORAGE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/BinaryDataSource_Folder')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "It describes the folder in the data source store.",
				"linkedServiceName": {
					"referenceName": "SFTP_RADIAL_STORAGE",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"FolderPath": {
						"type": "String"
					},
					"Directory": {
						"type": "String"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "SftpLocation",
						"folderPath": {
							"value": "@concat(dataset().FolderPath,'/',dataset().Directory)",
							"type": "Expression"
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/SFTP_RADIAL_STORAGE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/BinaryOutbound')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SFTP_RADIAL_STORAGE",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"folder_name": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "SftpLocation",
						"folderPath": {
							"value": "@dataset().folder_name",
							"type": "Expression"
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/SFTP_RADIAL_STORAGE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/BinaryOutbound_FetchFiles')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SFTP_RADIAL_STORAGE",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"folder_name": {
						"type": "string"
					},
					"file_name": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "SftpLocation",
						"fileName": {
							"value": "@dataset().file_name",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().folder_name",
							"type": "Expression"
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/SFTP_RADIAL_STORAGE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/CSVFILE')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "LocationMaster",
						"fileSystem": "staging"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Location Code",
						"type": "String"
					},
					{
						"name": "name",
						"type": "String"
					},
					{
						"name": "address",
						"type": "String"
					},
					{
						"name": "zip",
						"type": "String"
					},
					{
						"name": "inbound_handling_cost",
						"type": "String"
					},
					{
						"name": "outbound_handling_cost",
						"type": "String"
					},
					{
						"name": "status",
						"type": "String"
					},
					{
						"name": "inbound_processing_time",
						"type": "String"
					},
					{
						"name": "outbound_processing_time",
						"type": "String"
					},
					{
						"name": "type",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/CURRENT_BACKLOG_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/CurrentBacklog",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Brand",
						"type": "String"
					},
					{
						"name": "Fulfillment Location",
						"type": "String"
					},
					{
						"name": "Backlog Date",
						"type": "String"
					},
					{
						"name": "Open Backlog Units",
						"type": "String"
					},
					{
						"name": "Open Backlog Orders",
						"type": "String"
					},
					{
						"name": "Average UPO",
						"type": "String"
					},
					{
						"name": "Ship Via",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/CURRENT_BACKLOG_UX_STAGING')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "Current Backlog Import Template",
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "25.xlsx",
						"folderPath": "DEV/Upload/CurrentBacklog",
						"fileSystem": "staging"
					},
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"name": "Fulfillment Location ID*",
						"type": "String"
					},
					{
						"name": "Fulfillment Service*",
						"type": "String"
					},
					{
						"name": "Backlog Date*",
						"type": "String"
					},
					{
						"name": "Backlog Units",
						"type": "String"
					},
					{
						"name": "Backlog Orders",
						"type": "String"
					},
					{
						"name": "Units per Order",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/CurrentBacklogMain')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "DEV/Upload/CurrentBacklog",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Fulfillment Location ID*",
						"type": "String"
					},
					{
						"name": "Fulfillment Service*",
						"type": "String"
					},
					{
						"name": "Backlog Date*",
						"type": "String"
					},
					{
						"name": "Backlog Units",
						"type": "String"
					},
					{
						"name": "Backlog Orders",
						"type": "String"
					},
					{
						"name": "Units per Order",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/DAILY_ACTUALS_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "sample_file.csv",
						"folderPath": "Radial/DailyActuals",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Organization ID",
						"type": "String"
					},
					{
						"name": "Business ID",
						"type": "String"
					},
					{
						"name": "Location Code",
						"type": "String"
					},
					{
						"name": "Fulfillment Service",
						"type": "String"
					},
					{
						"name": "Date",
						"type": "String"
					},
					{
						"name": "Actual Units Received",
						"type": "String"
					},
					{
						"name": "Actual Orders Received",
						"type": "String"
					},
					{
						"name": "Actual Units Shipped",
						"type": "String"
					},
					{
						"name": "Actual Orders Shipped",
						"type": "String"
					},
					{
						"name": "Actual Packages Shipped",
						"type": "String"
					},
					{
						"name": "Open Backlog Units",
						"type": "String"
					},
					{
						"name": "Open Backlog Orders",
						"type": "String"
					},
					{
						"name": "Average Open UPO",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/DEMAND_FORECAST_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Upload/DemandForecast",
						"fileSystem": "main"
					},
					"columnDelimiter": "\t",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Item ID*",
						"type": "String"
					},
					{
						"name": "Area ID (3 Digit Zip Code)*",
						"type": "String"
					},
					{
						"name": "Customer Type",
						"type": "String"
					},
					{
						"name": "Fulfillment Service*",
						"type": "String"
					},
					{
						"name": "Forecast Start Date*",
						"type": "String"
					},
					{
						"name": "Forecast End Date*",
						"type": "String"
					},
					{
						"name": "Low Demand Quantity",
						"type": "String"
					},
					{
						"name": "Consensus Demand Quantity",
						"type": "String"
					},
					{
						"name": "High Demand Quantity",
						"type": "String"
					},
					{
						"name": "Fulfillment Location ID",
						"type": "String"
					},
					{
						"name": "Fixed Fulfillment",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/DEMAND_FORECAST_UX_UPLOAD')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "10.xlsx",
						"folderPath": "DEV/Upload/DemandForecast",
						"fileSystem": "staging"
					},
					"sheetIndex": 0,
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"name": "Item ID*",
						"type": "String"
					},
					{
						"name": "Area ID (3 Digit Zip Code)*",
						"type": "String"
					},
					{
						"name": "Customer Type",
						"type": "String"
					},
					{
						"name": "Fulfillment Service*",
						"type": "String"
					},
					{
						"name": "Forecast Start Date*",
						"type": "String"
					},
					{
						"name": "Forecast End Date*",
						"type": "String"
					},
					{
						"name": "Low Demand Quantity",
						"type": "String"
					},
					{
						"name": "Consensus Demand Quantity",
						"type": "String"
					},
					{
						"name": "High Demand Quantity",
						"type": "String"
					},
					{
						"name": "Fulfillment Location ID",
						"type": "String"
					},
					{
						"name": "Fixed Fulfillment",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/DelimitedText1')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/LocationMaster",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Location Code",
						"type": "String"
					},
					{
						"name": "Name",
						"type": "String"
					},
					{
						"name": "Address",
						"type": "String"
					},
					{
						"name": "Zip",
						"type": "String"
					},
					{
						"name": "Throughput",
						"type": "String"
					},
					{
						"name": "Capacity",
						"type": "String"
					},
					{
						"name": "Inbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Outbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Status",
						"type": "String"
					},
					{
						"name": "Inbound Processing Time",
						"type": "String"
					},
					{
						"name": "Outbound Processing Time",
						"type": "String"
					},
					{
						"name": "Type",
						"type": "String"
					},
					{
						"name": "Transfer Inbound Processing Time",
						"type": "String"
					},
					{
						"name": "Transfer Outbound Processing Time",
						"type": "String"
					},
					{
						"name": "Transfer Inbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Transfer Outbound Handling Cost",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/EDA_Temp')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/EDA_RADIAL",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/Error_Json')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "DEV/FailedTransactions/FulfillmentForecast",
						"fileSystem": "main"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FAILED_LOCATION_MASTER_ROWS_SFTP')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SFTP_RADIAL_STORAGE",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "SftpLocation",
						"folderPath": "/faileduploads/LocationMaster"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/SFTP_RADIAL_STORAGE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FTP_FILES')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "QA_Datalake",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial",
						"fileSystem": "staging"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/QA_Datalake')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FULFILLMENT_FORECAST_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "sample_file.csv",
						"folderPath": "Radial/FulfillmentForecast",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Organization ID",
						"type": "String"
					},
					{
						"name": "Business ID",
						"type": "String"
					},
					{
						"name": "Location Code",
						"type": "String"
					},
					{
						"name": "Fulfillment Service",
						"type": "String"
					},
					{
						"name": "Forecast Date",
						"type": "String"
					},
					{
						"name": "Locked Forecast Units",
						"type": "String"
					},
					{
						"name": "Current Forecast Units",
						"type": "String"
					},
					{
						"name": "Forecast 3 Units",
						"type": "String"
					},
					{
						"name": "Average Locked UPO",
						"type": "String"
					},
					{
						"name": "Locked Forecast Orders",
						"type": "String"
					},
					{
						"name": "Current Forecast Orders",
						"type": "String"
					},
					{
						"name": "Forecast 3 Orders",
						"type": "String"
					},
					{
						"name": "Forecast Locked Date",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FULFILLMENT_FORECAST_UX_STAGING')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "Fulfillment Forecast Import Tem",
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "338.xlsx",
						"folderPath": "DEV/Upload/FulfillmentForecast",
						"fileSystem": "staging"
					},
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"name": "Forecast Date*",
						"type": "String"
					},
					{
						"name": "Forecast 1 Units",
						"type": "String"
					},
					{
						"name": "Forecast 1 Orders",
						"type": "String"
					},
					{
						"name": "Forecast 2 Units",
						"type": "String"
					},
					{
						"name": "Units per Order",
						"type": "String"
					},
					{
						"name": "Forecast Locked Date",
						"type": "String"
					},
					{
						"name": "Fulfillment Service*",
						"type": "String"
					},
					{
						"name": "Fulfillment Location ID*",
						"type": "String"
					},
					{
						"name": "Forecast 2 Orders",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FailedDemandForecastRows')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"filename": {
						"type": "string",
						"defaultValue": "sample"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().filename",
							"type": "Expression"
						},
						"folderPath": "FailedTransactions/DemandForecast",
						"fileSystem": "main"
					},
					"columnDelimiter": "|",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FailedFulfillementRowsJson')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "DEV/FailedTransactions/FulfillmentForecast",
						"fileSystem": "main"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FailedInventoryRows')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "DEV/FailedTransactions/Inventory",
						"fileSystem": "main"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FailedLocationMasterRows')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "FailedTransactions/LocationMaster",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FailedLocationStaffing')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "DEV/FailedTransactions/LocationStaffing",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FailedLocationStaffingJson')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "DEV/FailedTransactions/LocationStaffing",
						"fileSystem": "main"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FailedRowsItemMaster')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "FailedTransactions/ItemMaster",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FailedRowsLocation')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "DEV/FailedTransactions/Location",
						"fileSystem": "main"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FailedUXUploadDemandForecast')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "FailedTransactions/DemandForecast",
						"fileSystem": "main"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FailedValidationRowsCurrentBacklog')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "DEV/FailedTransactions/CurrentBacklog",
						"fileSystem": "main"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/FulfillmentForecastMain')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "338.txt",
						"folderPath": "DEV/Upload/FulfillmentForecast",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Fulfillment Location ID*",
						"type": "String"
					},
					{
						"name": "Fulfillment Service*",
						"type": "String"
					},
					{
						"name": "Forecast Date*",
						"type": "String"
					},
					{
						"name": "Forecast 1 Units",
						"type": "String"
					},
					{
						"name": "Forecast 1 Orders",
						"type": "String"
					},
					{
						"name": "Forecast 2 Units",
						"type": "String"
					},
					{
						"name": "Forecast 2 Orders",
						"type": "String"
					},
					{
						"name": "Units per Order",
						"type": "String"
					},
					{
						"name": "Forecast Locked Date",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/INVENTORY_MAIN_UX')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "DEV/Upload/Inventory",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Item ID",
						"type": "String"
					},
					{
						"name": "Location ID",
						"type": "String"
					},
					{
						"name": "Stock Date",
						"type": "String"
					},
					{
						"name": "Stock Quantity",
						"type": "String"
					},
					{
						"name": "Reserved Quantity",
						"type": "String"
					},
					{
						"name": "Available Quantity",
						"type": "String"
					},
					{
						"name": "On Order ID",
						"type": "String"
					},
					{
						"name": "On Order Due Date",
						"type": "String"
					},
					{
						"name": "On Order Supplier Shipping Date",
						"type": "String"
					},
					{
						"name": "On Order Promised Delivery Date",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/INVENTORY_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/Inventory",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Item ID",
						"type": "String"
					},
					{
						"name": "Location ID",
						"type": "String"
					},
					{
						"name": "On Hand Stock Date",
						"type": "String"
					},
					{
						"name": "On Hand Stock Quantity",
						"type": "String"
					},
					{
						"name": "Reserved On Hold Stock",
						"type": "String"
					},
					{
						"name": "Available Stock",
						"type": "String"
					},
					{
						"name": "Lot ID",
						"type": "String"
					},
					{
						"name": "On Order Due Date",
						"type": "String"
					},
					{
						"name": "On Order Quantity",
						"type": "String"
					},
					{
						"name": "Purchase Order Status",
						"type": "String"
					},
					{
						"name": "On Order Supplier Shipping Date",
						"type": "String"
					},
					{
						"name": "On Order Promised Delivery Date",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/INVENTORY_UX')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "Inventory Import Template",
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "211.xlsx",
						"folderPath": "DEV/Upload/Inventory",
						"fileSystem": "staging"
					},
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"name": "Item ID",
						"type": "String"
					},
					{
						"name": "Location ID",
						"type": "String"
					},
					{
						"name": "Stock Date",
						"type": "String"
					},
					{
						"name": "Stock Quantity",
						"type": "String"
					},
					{
						"name": "Reserved Quantity",
						"type": "String"
					},
					{
						"name": "Available Quantity",
						"type": "String"
					},
					{
						"name": "On Order ID",
						"type": "String"
					},
					{
						"name": "On Order Due Date",
						"type": "String"
					},
					{
						"name": "On Order Supplier Shipping Date",
						"type": "String"
					},
					{
						"name": "On Order Promised Delivery Date",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ITEM_MASTER_DL_STORE')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "ItemMaster",
						"fileSystem": "mldatalake"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ITEM_MASTER_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "sample_file.csv",
						"folderPath": "Radial/ItemMaster",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Organization ID",
						"type": "String"
					},
					{
						"name": "Business ID",
						"type": "String"
					},
					{
						"name": "Location Code",
						"type": "String"
					},
					{
						"name": "Item Code",
						"type": "String"
					},
					{
						"name": "Description",
						"type": "String"
					},
					{
						"name": "Lifecycle Status",
						"type": "String"
					},
					{
						"name": "Department",
						"type": "String"
					},
					{
						"name": "Sub_Department",
						"type": "String"
					},
					{
						"name": "Product Division",
						"type": "String"
					},
					{
						"name": "Product Category",
						"type": "String"
					},
					{
						"name": "Measurement Unit",
						"type": "String"
					},
					{
						"name": "Unit Cost",
						"type": "String"
					},
					{
						"name": "Unit Volume",
						"type": "String"
					},
					{
						"name": "Unit Weight",
						"type": "String"
					},
					{
						"name": "Item Unit Price",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LANE_RATES_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "lane_rates/raw",
						"fileSystem": "radial-demo-data"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Zones",
						"type": "String"
					},
					{
						"name": "2",
						"type": "String"
					},
					{
						"name": "3",
						"type": "String"
					},
					{
						"name": "4",
						"type": "String"
					},
					{
						"name": "5",
						"type": "String"
					},
					{
						"name": "6",
						"type": "String"
					},
					{
						"name": "7",
						"type": "String"
					},
					{
						"name": "8",
						"type": "String"
					},
					{
						"name": "44",
						"type": "String"
					},
					{
						"name": "45",
						"type": "String"
					},
					{
						"name": "46",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LANE_RATE_2DAY_AIR_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/LaneRates/UPS/2DayAir",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Zones",
						"type": "String"
					},
					{
						"name": "202.0",
						"type": "String"
					},
					{
						"name": "203.0",
						"type": "String"
					},
					{
						"name": "204.0",
						"type": "String"
					},
					{
						"name": "205.0",
						"type": "String"
					},
					{
						"name": "206.0",
						"type": "String"
					},
					{
						"name": "207.0",
						"type": "String"
					},
					{
						"name": "208.0",
						"type": "String"
					},
					{
						"name": "224.0",
						"type": "String"
					},
					{
						"name": "225.0",
						"type": "String"
					},
					{
						"name": "226",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LANE_RATE_GROUND_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/LaneRates/UPS/Ground",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Zones",
						"type": "String"
					},
					{
						"name": "2",
						"type": "String"
					},
					{
						"name": "3",
						"type": "String"
					},
					{
						"name": "4",
						"type": "String"
					},
					{
						"name": "5",
						"type": "String"
					},
					{
						"name": "6",
						"type": "String"
					},
					{
						"name": "7",
						"type": "String"
					},
					{
						"name": "8",
						"type": "String"
					},
					{
						"name": "44",
						"type": "String"
					},
					{
						"name": "45",
						"type": "String"
					},
					{
						"name": "46",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LANE_RATE_NEXTDAY_AIR_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/LaneRates/UPS/NextDayAir",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LOCATION_MASTER_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "new_file_location_master.csv",
						"folderPath": "Radial/LocationMaster",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Organization ID",
						"type": "String"
					},
					{
						"name": "Business ID",
						"type": "String"
					},
					{
						"name": "Location Code",
						"type": "String"
					},
					{
						"name": "Name",
						"type": "String"
					},
					{
						"name": "Address",
						"type": "String"
					},
					{
						"name": "City",
						"type": "String"
					},
					{
						"name": "State",
						"type": "String"
					},
					{
						"name": "Zip",
						"type": "String"
					},
					{
						"name": "Country",
						"type": "String"
					},
					{
						"name": "Latitude",
						"type": "String"
					},
					{
						"name": "Longitude",
						"type": "String"
					},
					{
						"name": "Location Status",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LOCATION_STAFFING_UX')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "Location Staffing Import Templa",
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "18.xlsx",
						"folderPath": "DEV/Upload/LocationStaffing",
						"fileSystem": "staging"
					},
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"name": "Profile Name*",
						"type": "String"
					},
					{
						"name": "Location ID*",
						"type": "String"
					},
					{
						"name": "Date*",
						"type": "String"
					},
					{
						"name": "Metric Name*",
						"type": "String"
					},
					{
						"name": "Value*",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LOCATION_UX_STAGING')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "Location Import Template",
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "36.xlsx",
						"folderPath": "DEV/Upload/Location",
						"fileSystem": "staging"
					},
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"name": "Location ID*",
						"type": "String"
					},
					{
						"name": "Location Name",
						"type": "String"
					},
					{
						"name": "Address",
						"type": "String"
					},
					{
						"name": "City",
						"type": "String"
					},
					{
						"name": "State",
						"type": "String"
					},
					{
						"name": "Zip",
						"type": "String"
					},
					{
						"name": "Country",
						"type": "String"
					},
					{
						"name": "Longitude",
						"type": "String"
					},
					{
						"name": "Latitude",
						"type": "String"
					},
					{
						"name": "Location Status",
						"type": "String"
					},
					{
						"name": "Location Type",
						"type": "String"
					},
					{
						"name": "Daily Throughput",
						"type": "String"
					},
					{
						"name": "Storage Capacity",
						"type": "String"
					},
					{
						"name": "Inbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Outbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Inbound Processing Time",
						"type": "String"
					},
					{
						"name": "Outbound Processing Time",
						"type": "String"
					},
					{
						"name": "Transfer Inbound Processing Time",
						"type": "String"
					},
					{
						"name": "Transfer Outbound Processing Time",
						"type": "String"
					},
					{
						"name": "Transfer Inbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Transfer Outbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Units per Hour",
						"type": "String"
					},
					{
						"name": "Max FTE Regular Hours",
						"type": "String"
					},
					{
						"name": "Min FTE Regular Hours",
						"type": "String"
					},
					{
						"name": "Max Temp Regular Hours",
						"type": "String"
					},
					{
						"name": "Min Temp Regular Hours",
						"type": "String"
					},
					{
						"name": "Max FTE Overtime Hours",
						"type": "String"
					},
					{
						"name": "Regular FTE Wage",
						"type": "String"
					},
					{
						"name": "Regular Temp Wage",
						"type": "String"
					},
					{
						"name": "Overtime FTE Wage",
						"type": "String"
					},
					{
						"name": "Overtime Temp Wage",
						"type": "String"
					},
					{
						"name": "FTE Staff Count",
						"type": "String"
					},
					{
						"name": "Temp Staff Count",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LocationStaffingMain')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "17.txt",
						"folderPath": "DEV/Upload/LocationStaffing",
						"fileSystem": "main"
					},
					"columnDelimiter": "\t",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/LocationsMain')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "DEV/Upload/Location",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Location ID*",
						"type": "String"
					},
					{
						"name": "Location Name",
						"type": "String"
					},
					{
						"name": "Address",
						"type": "String"
					},
					{
						"name": "City",
						"type": "String"
					},
					{
						"name": "State",
						"type": "String"
					},
					{
						"name": "Zip",
						"type": "String"
					},
					{
						"name": "Country",
						"type": "String"
					},
					{
						"name": "Longitude",
						"type": "String"
					},
					{
						"name": "Latitude",
						"type": "String"
					},
					{
						"name": "Location Status",
						"type": "String"
					},
					{
						"name": "Location Type",
						"type": "String"
					},
					{
						"name": "Daily Throughput",
						"type": "String"
					},
					{
						"name": "Storage Capacity",
						"type": "String"
					},
					{
						"name": "Inbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Outbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Inbound Processing Time",
						"type": "String"
					},
					{
						"name": "Outbound Processing Time",
						"type": "String"
					},
					{
						"name": "Transfer Inbound Processing Time",
						"type": "String"
					},
					{
						"name": "Transfer Outbound Processing Time",
						"type": "String"
					},
					{
						"name": "Transfer Inbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Transfer Outbound Handling Cost",
						"type": "String"
					},
					{
						"name": "Units per Hour",
						"type": "String"
					},
					{
						"name": "Max FTE Regular Hours",
						"type": "String"
					},
					{
						"name": "Min FTE Regular Hours",
						"type": "String"
					},
					{
						"name": "Max Temp Regular Hours",
						"type": "String"
					},
					{
						"name": "Min Temp Regular Hours",
						"type": "String"
					},
					{
						"name": "Regular FTE Wage",
						"type": "String"
					},
					{
						"name": "Regular Temp Wage",
						"type": "String"
					},
					{
						"name": "Overtime FTE Wage",
						"type": "String"
					},
					{
						"name": "Overtime Temp Wage",
						"type": "String"
					},
					{
						"name": "FTE Staff Count",
						"type": "String"
					},
					{
						"name": "Temp Staff Count",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ORDER_HISTORY_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/OrderHistory",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Order ID",
						"type": "String"
					},
					{
						"name": "Order Line ID",
						"type": "String"
					},
					{
						"name": "Location ID",
						"type": "String"
					},
					{
						"name": "Channel",
						"type": "String"
					},
					{
						"name": "Order Date",
						"type": "String"
					},
					{
						"name": "Order Original Ship Date",
						"type": "String"
					},
					{
						"name": "Order Actual Ship Date",
						"type": "String"
					},
					{
						"name": "Order Due Date",
						"type": "String"
					},
					{
						"name": "Order Received Date and Time",
						"type": "String"
					},
					{
						"name": "Order Completed Date and Time",
						"type": "String"
					},
					{
						"name": "Destination Zip Code",
						"type": "String"
					},
					{
						"name": "Item Code",
						"type": "String"
					},
					{
						"name": "Order Quantity",
						"type": "String"
					},
					{
						"name": "Quantity (UOM) Picked",
						"type": "String"
					},
					{
						"name": "Order Status",
						"type": "String"
					},
					{
						"name": "Carrier",
						"type": "String"
					},
					{
						"name": "Service Type",
						"type": "String"
					},
					{
						"name": "Shipment Fees",
						"type": "String"
					},
					{
						"name": "Order Value",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ORDER_HISTORY_SFTP')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "QA_Datalake",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/OrderHistory/OH",
						"fileSystem": "staging"
					},
					"columnDelimiter": "|",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Order ID",
						"type": "String"
					},
					{
						"name": "Order Line ID",
						"type": "String"
					},
					{
						"name": "Location ID",
						"type": "String"
					},
					{
						"name": "Channel",
						"type": "String"
					},
					{
						"name": "Order date",
						"type": "String"
					},
					{
						"name": "Order Original Ship date",
						"type": "String"
					},
					{
						"name": "Order Actual Ship date",
						"type": "String"
					},
					{
						"name": "Order due date",
						"type": "String"
					},
					{
						"name": "Order Received (in Warehouse) Date and time",
						"type": "String"
					},
					{
						"name": "Order Completed (in Warehouse) Date and time",
						"type": "String"
					},
					{
						"name": "Destination zip code (Ship to)",
						"type": "String"
					},
					{
						"name": "Item code",
						"type": "String"
					},
					{
						"name": "Order quantity",
						"type": "String"
					},
					{
						"name": "Quantity (UOM) Picked",
						"type": "String"
					},
					{
						"name": "Order Status",
						"type": "String"
					},
					{
						"name": "Carrier",
						"type": "String"
					},
					{
						"name": "Service Type",
						"type": "String"
					},
					{
						"name": "Shipment Fees",
						"type": "String"
					},
					{
						"name": "Order Value",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/QA_Datalake')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SFTP_Failed_FulfillmentForecast')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SFTP_RADIAL_STORAGE",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "SftpLocation",
						"folderPath": "/faileduploads/FulfillmentForecast"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/SFTP_RADIAL_STORAGE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SHIPMENT_HISTORY_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/ShipmentHistory",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Shipment ID",
						"type": "String"
					},
					{
						"name": "Order Line ID",
						"type": "String"
					},
					{
						"name": "Location ID",
						"type": "String"
					},
					{
						"name": "Carrier Name",
						"type": "String"
					},
					{
						"name": "Mode",
						"type": "String"
					},
					{
						"name": "Total Units",
						"type": "String"
					},
					{
						"name": "Total Shipment Weight",
						"type": "String"
					},
					{
						"name": "Total Shipment Volume",
						"type": "String"
					},
					{
						"name": "Total Shipment Cost",
						"type": "String"
					},
					{
						"name": "Total Shipment Value",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SHIPMENT_HISTORY_STAGING')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "QA_Datalake",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/OrderHistory",
						"fileSystem": "staging"
					},
					"columnDelimiter": "|",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Order ID|Order Line ID|Channel|Order date|Order Original Ship date|Order Actual Ship date|Order due date|Order Received (in Warehouse) Date and time|Order Completed (in Warehouse) Date and time|Destination zip code (Ship to)|Item code|Order quantity|Quantity (UOM) Picked|Order Status|Carrier|Service Type|Shipment Fees|Order Value",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/QA_Datalake')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/STAFFING_HISTORY_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"file_name": {
						"type": "string"
					}
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().file_name",
							"type": "Expression"
						},
						"folderPath": "Radial/StaffingHistory",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Organization ID",
						"type": "String"
					},
					{
						"name": "Business ID",
						"type": "String"
					},
					{
						"name": "Location Code",
						"type": "String"
					},
					{
						"name": "Date",
						"type": "String"
					},
					{
						"name": "Plan Type",
						"type": "String"
					},
					{
						"name": "Staff Type",
						"type": "String"
					},
					{
						"name": "Staff Count",
						"type": "String"
					},
					{
						"name": "Average Tenure",
						"type": "String"
					},
					{
						"name": "Regular Hours",
						"type": "String"
					},
					{
						"name": "OT Hours",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/STAGINGFILES')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/STAGING_BINARY_FILES')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial",
						"fileSystem": "main"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/THROUGHPUT_PREDICTIONS_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/ThroughputPredictions",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Prop_0",
						"type": "String"
					},
					{
						"name": "date",
						"type": "String"
					},
					{
						"name": "unit_volume",
						"type": "String"
					},
					{
						"name": "capacity",
						"type": "String"
					},
					{
						"name": "picker_capacity",
						"type": "String"
					},
					{
						"name": "packer_capacity",
						"type": "String"
					},
					{
						"name": "total_work_hours",
						"type": "String"
					},
					{
						"name": "inventory_level",
						"type": "String"
					},
					{
						"name": "throughput_preds",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/TRANSIT_TIME_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/TransitTime",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Zones",
						"type": "String"
					},
					{
						"name": "Transit Time",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/TSVFILE')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/LocationMaster",
						"fileSystem": "main"
					},
					"columnDelimiter": "\t",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ZONE_RAW')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "src_files"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "Radial/Zone",
						"fileSystem": "main"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"nullValue": "Account key",
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Dest. ZIP",
						"type": "String"
					},
					{
						"name": "Ground - ZONE",
						"type": "String"
					},
					{
						"name": "3 Day Select",
						"type": "String"
					},
					{
						"name": "2nd Day Air",
						"type": "String"
					},
					{
						"name": "2nd Day Air A.M.",
						"type": "String"
					},
					{
						"name": "Next Day Air Saver",
						"type": "String"
					},
					{
						"name": "Next Day Air",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/current_backlog_table')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "fulfillment_service_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "backlog_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "open_backlog_units",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "open_backlog_orders",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "average_upo",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "current_backlog_table"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/customertypes')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "customer_type_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "description",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "customer_type"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/enum_types')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "enum_type"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/enum_values')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "enum_type_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "value_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "value",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "enum_value"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/failedrowsdailyactualssftp')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SFTP_RADIAL_STORAGE",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "SftpLocation",
						"folderPath": "/faileduploads/DailyActuals"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/SFTP_RADIAL_STORAGE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/failedvalidationrowsbudgetstaffing')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SFTP_RADIAL_STORAGE",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "SftpLocation",
						"folderPath": "/faileduploads/BudgetStaffing"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/SFTP_RADIAL_STORAGE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/failurestringdemandforecast')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "1.txt",
						"folderPath": "FailedTransactions/DemandForecast",
						"fileSystem": "main"
					},
					"columnDelimiter": "",
					"rowDelimiter": "",
					"escapeChar": "\\",
					"firstRowAsHeader": false,
					"quoteChar": "\""
				},
				"schema": [
					{
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/forecast')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "area_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "customer_type",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "fulfillment_service",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "forecast_start_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "forecast_end_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "fulfillment_location",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "low_demand_quantity",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "consensus_demand_quantity",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "high_demand_quantity",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "fixed_fulfillment",
						"type": "boolean",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "area_hierarchy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "forecast"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/fulfillment_forecast')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "fulfillment_service_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "forecast_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "locked_forecast_units",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "current_forecast_units",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "average_upo",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "locked_forecast_orders",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "current_forecast_orders",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "forecast_locked_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "forecast_3_units",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "forecast_3_orders",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "fulfillment_forecast"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/fulfillment_services')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "fulfillment_service_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "service_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "service_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "delivery_speed_value",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "delivery_speed_unit",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "service_radius_value",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "service_radius_unit",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "service_charge",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "deployment_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "fulfillment_services"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/gis_zip')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "geom",
						"type": "USER-DEFINED",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "zcta5ce10",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "geoid10",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "classfp10",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "mtfcc10",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "funcstat10",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "aland10",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "awater10",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "intptlat10",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "intptlon10",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "gis",
					"table": "tl_2019_us_zcta510"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/importhistory')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "original_file_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "user_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "status_enum_value_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "processed_time",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "errors",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "import_history"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/inventory')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "on_hand_stock_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "on_hand_stock_quantity",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "reserved_on_hold_stock_",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "available_stock",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "lot_id",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "on_order_due_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "on_order_quantity_",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "purchase_order_status",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "on_order_supplier_shipping_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "on_order_promised_delivery_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tenant_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "stock_type_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "inventory"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/item')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "description",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "short_description",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "department",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "sub_department",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "class",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "sub_class",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "style",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "color",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "size",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "size_second",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "sku_lifecycle_status",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "product_division",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "product_family",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "measurement_unit",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "unit_cost",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "unit_volume",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "unit_weight",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "unit_cube",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "units_per_pallet",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "uom_conversion_factor",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "distribution_channel",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_handling_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_unit_price",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "minimum_sales_qty",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "birth_year",
						"type": "smallint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "birth_month",
						"type": "smallint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "expiration_year",
						"type": "smallint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "expiration_month",
						"type": "smallint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "item"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/item_heirarchy_detail')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "description",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "category",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "record_creation_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "record_updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "item_hierarchy_detail"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/lane_rate')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "rate_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "break1_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "break1_start",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "break1_end",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "rate_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "rate",
						"type": "double precision",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "rate_minimum",
						"type": "double precision",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "rate_maximum",
						"type": "double precision",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "lane_rate"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/lifecycle_status')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "status",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "lifecycle_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "lifecycle_status"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/location_type')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "description",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "display_icon",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "location_types"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/locations')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "address",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "city",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "state",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "zip",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "country",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "sub_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "delivery_partners",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "throughput",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "capacity",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "special_information",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "holding_cost",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "inbound_handling_cost",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "outbound_handling_cost",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "longitude",
						"type": "double precision",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "latitude",
						"type": "double precision",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "status",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "inbound_processing_time",
						"type": "numeric",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "outbound_processing_time",
						"type": "numeric",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "type",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "transfer_inbound_processing_time",
						"type": "double precision",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "transfer_outbound_processing_time",
						"type": "double precision",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "transfer_inbound_handling_cost",
						"type": "double precision",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "transfer_outbound_handling_cost",
						"type": "double precision",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tenant_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "units_per_hour",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "max_fte_regular_hours",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "min_fte_regular_hours",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "max_temp_regular_hours",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "min_temp_regular_hours",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "max_fte_overtime_hours",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "max_temp_overtime_hours",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "regular_fte_wage",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "regular_temp_wage",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "overtime_fte_wage",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "overtime_temp_wage",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "fte_staff_count",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "temp_staff_count",
						"type": "integer",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "locations"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/micro_area')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "micro_area_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "description",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "primary_fulfillment_location",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "attribute_1",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "attribute_2",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "micro_area"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/notification')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "run_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "run_status",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "description",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "user_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "notification_status",
						"type": "USER-DEFINED",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "notification_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "feature_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_at",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_at",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "notification"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/operational_calendar')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "date",
						"type": "date",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_metric_value",
						"type": "numeric",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "enum_value_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "enum_type_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "operational_profile_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "operational_calendar"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/operationalprofile')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "operational_profile"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_history')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "order_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "channel",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "order_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "must_ship_by_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "must_deliver_by_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_city",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_state",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_postal_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_country",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "status",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "delivery_partner_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "service_level_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "fulfillment_service",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "total_units",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "total_shipping_charge",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "total_order_value",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "import_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "order_history"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_line_history')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "order_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "order_line_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_description",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "order_quantity",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "ship_quantity",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "line_status",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_price",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "order_line_history"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_status_history')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "order_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "status",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "status_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "order_status_history"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/orderhistory_mllake')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "OrderHistory",
						"fileSystem": "mldatalake"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_files_binary')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SFTP_RADIAL_STORAGE",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "SftpLocation",
						"folderPath": "/outbound/"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/SFTP_RADIAL_STORAGE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_files_radial')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SFTP_RADIAL_STORAGE",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "SftpLocation",
						"folderPath": "/outbound"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/SFTP_RADIAL_STORAGE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/shipment_history')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "shipment_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "order_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "delivery_partner_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "service_level",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "status",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "shipment_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "total_units",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "total_weight",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "total_volume",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "total_cost",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "import_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "shipment_history"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/shipment_history_mldatalake')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "ShipmentHistory",
						"fileSystem": "mldatalake"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/shipment_line_history')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "shipment_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "shipment_line_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "order_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "order_line_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "item_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "units",
						"type": "real",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "shipment_line_history"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/staffing_history_mldatalake')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "StaffingHistory",
						"fileSystem": "mldatalake"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/temp_binary_sample_files')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "datalakelinkedservice",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "temp",
						"fileSystem": "staging"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/tenant_heirarchy_table')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tenant_hierarchy_type",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "contact_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "email",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "phone",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "street_address_1",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "street_address_2",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "city",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "state",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "zip",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "country",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "active",
						"type": "boolean",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tenant_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "parent_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "tenant_hierarchy_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "isdeleted",
						"type": "boolean",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_by_user_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "tenant_hierarchy_detail"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/transportation_lane')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "delivery_partner_id",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "rate_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "fulfillment_service_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "service_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "origin_location_code",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "origin_address",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "origin_city",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "origin_state",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "origin_zip",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "origin_country",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_location_code",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_address",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_city",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_state",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_zip",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_country",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "transit_time",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "zone",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "transportation_lane"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/zone')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "PgSQL_LinkedService3",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "db_tables"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "zone",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "delivery_partner_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "origin_start",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "origin_end",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_start",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "destination_end",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_date",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "business_unit_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "organization_id",
						"type": "uuid",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "pfp",
					"table": "zone"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/PgSQL_LinkedService3')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/PgSQL_LinkedService3')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzurePostgreSql",
				"typeProperties": {
					"connectionString": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "briczkeyvault",
							"type": "LinkedServiceReference"
						},
						"secretName": "[parameters('PgSQL_LinkedService3_properties_typeProperties_connectionString_secretName')]"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('factoryId'), '/linkedServices/briczkeyvault')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/QA_Datalake')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('QA_Datalake_properties_typeProperties_url')]",
					"accountKey": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "briczkeyvault",
							"type": "LinkedServiceReference"
						},
						"secretName": "SFTP-STORAGE-KEY"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('factoryId'), '/linkedServices/briczkeyvault')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/SFTP_RADIAL_STORAGE')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "Sftp",
				"typeProperties": {
					"host": "[parameters('SFTP_RADIAL_STORAGE_properties_typeProperties_host')]",
					"port": 22,
					"skipHostKeyValidation": true,
					"authenticationType": "Basic",
					"userName": "[parameters('SFTP_RADIAL_STORAGE_properties_typeProperties_userName')]",
					"password": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "briczkeyvault",
							"type": "LinkedServiceReference"
						},
						"secretName": "SFTP-PASSWORD",
						"secretVersion": "623aa48f57e54062bf4fd768fcb2a2b2"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('factoryId'), '/linkedServices/briczkeyvault')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/briczkeyvault')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureKeyVault",
				"typeProperties": {
					"baseUrl": "[parameters('briczkeyvault_properties_typeProperties_baseUrl')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/datalakelinkedservice')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "linked service to connect to datalake storage gen 2 account. Specially built for migrating and transforming data from radial",
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('datalakelinkedservice_properties_typeProperties_url')]",
					"accountKey": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "briczkeyvault",
							"type": "LinkedServiceReference"
						},
						"secretName": "ADF-STORAGE-KEY"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('factoryId'), '/linkedServices/briczkeyvault')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/import_manager_current_backlog')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "CURRENT_BACKLOG_UX",
							"type": "PipelineReference"
						},
						"parameters": {
							"quote": "[parameters('import_manager_current_backlog_properties_CURRENT_BACKLOG_UX_parameters_quote')]",
							"folder_path": "[parameters('import_manager_current_backlog_properties_CURRENT_BACKLOG_UX_parameters_folder_path')]",
							"file_name": "[parameters('import_manager_current_backlog_properties_CURRENT_BACKLOG_UX_parameters_file_name')]",
							"next_line": "[parameters('import_manager_current_backlog_properties_CURRENT_BACKLOG_UX_parameters_next_line')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/staging/blobs/DEV/Upload/CurrentBacklog",
					"blobPathEndsWith": ".xlsx",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('import_manager_current_backlog_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/CURRENT_BACKLOG_UX')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/import_manager_demand_forecast')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "DEMAND_FORECAST_UX",
							"type": "PipelineReference"
						},
						"parameters": {
							"quote": "[parameters('import_manager_demand_forecast_properties_DEMAND_FORECAST_UX_parameters_quote')]",
							"folder_path": "[parameters('import_manager_demand_forecast_properties_DEMAND_FORECAST_UX_parameters_folder_path')]",
							"file_name": "[parameters('import_manager_demand_forecast_properties_DEMAND_FORECAST_UX_parameters_file_name')]",
							"next_line": "[parameters('import_manager_demand_forecast_properties_DEMAND_FORECAST_UX_parameters_next_line')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/staging/blobs/DEV/Upload/DemandForecast/",
					"blobPathEndsWith": ".xlsx",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('import_manager_demand_forecast_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/DEMAND_FORECAST_UX')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/import_manager_fulfillment_forecast')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "FULFILLMENT_FORECAST_UX",
							"type": "PipelineReference"
						},
						"parameters": {
							"quote": "[parameters('import_manager_fulfillment_forecast_properties_FULFILLMENT_FORECAST_UX_parameters_quote')]",
							"folder_path": "[parameters('import_manager_fulfillment_forecast_properties_FULFILLMENT_FORECAST_UX_parameters_folder_path')]",
							"file_name": "[parameters('import_manager_fulfillment_forecast_properties_FULFILLMENT_FORECAST_UX_parameters_file_name')]",
							"next_line": "[parameters('import_manager_fulfillment_forecast_properties_FULFILLMENT_FORECAST_UX_parameters_next_line')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/staging/blobs/DEV/Upload/FulfillmentForecast/",
					"blobPathEndsWith": ".xlsx",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('import_manager_fulfillment_forecast_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/FULFILLMENT_FORECAST_UX')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/import_manager_inventory')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "INVENTORY_UX",
							"type": "PipelineReference"
						},
						"parameters": {
							"quote": "[parameters('import_manager_inventory_properties_INVENTORY_UX_parameters_quote')]",
							"folder_path": "[parameters('import_manager_inventory_properties_INVENTORY_UX_parameters_folder_path')]",
							"file_name": "[parameters('import_manager_inventory_properties_INVENTORY_UX_parameters_file_name')]",
							"next_line": "[parameters('import_manager_inventory_properties_INVENTORY_UX_parameters_next_line')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/staging/blobs/DEV/Upload/Inventory/",
					"blobPathEndsWith": ".xlsx",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('import_manager_inventory_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/INVENTORY_UX')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/import_manager_location')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "LOCATION_UX",
							"type": "PipelineReference"
						},
						"parameters": {
							"quote": "[parameters('import_manager_location_properties_LOCATION_UX_parameters_quote')]",
							"folder_path": "[parameters('import_manager_location_properties_LOCATION_UX_parameters_folder_path')]",
							"file_name": "[parameters('import_manager_location_properties_LOCATION_UX_parameters_file_name')]",
							"next_line": "[parameters('import_manager_location_properties_LOCATION_UX_parameters_next_line')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/staging/blobs/DEV/Upload/Location/",
					"blobPathEndsWith": ".xlsx",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('import_manager_location_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/LOCATION_UX')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/import_manager_location_staffing')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "LOCATION_STAFFING",
							"type": "PipelineReference"
						},
						"parameters": {
							"quote": "[parameters('import_manager_location_staffing_properties_LOCATION_STAFFING_parameters_quote')]",
							"folder_path": "[parameters('import_manager_location_staffing_properties_LOCATION_STAFFING_parameters_folder_path')]",
							"file_name": "[parameters('import_manager_location_staffing_properties_LOCATION_STAFFING_parameters_file_name')]",
							"next_line": "[parameters('import_manager_location_staffing_properties_LOCATION_STAFFING_parameters_next_line')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/staging/blobs/DEV/Upload/LocationStaffing/",
					"blobPathEndsWith": ".xlsx",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('import_manager_location_staffing_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/LOCATION_STAFFING')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_schedule_file_ingest_shipment_history')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "SFTP_TO_MAIN_FOR_PROCESSING",
							"type": "PipelineReference"
						},
						"parameters": {
							"SourceStore_Location": "[parameters('sftp_schedule_file_ingest_shipment_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location')]",
							"SourceStore_Directory": "[parameters('sftp_schedule_file_ingest_shipment_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory')]",
							"DestinationStore_Location": "[parameters('sftp_schedule_file_ingest_shipment_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location')]",
							"DestinationStore_Directory": "[parameters('sftp_schedule_file_ingest_shipment_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory')]"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-07-09T05:05:00",
						"timeZone": "Central Standard Time"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/SFTP_TO_MAIN_FOR_PROCESSING')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_scheduled_file_ingest_budget_staffing')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "SFTP_TO_MAIN_FOR_PROCESSING",
							"type": "PipelineReference"
						},
						"parameters": {
							"SourceStore_Location": "[parameters('sftp_scheduled_file_ingest_budget_staffing_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location')]",
							"SourceStore_Directory": "[parameters('sftp_scheduled_file_ingest_budget_staffing_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory')]",
							"DestinationStore_Location": "[parameters('sftp_scheduled_file_ingest_budget_staffing_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location')]",
							"DestinationStore_Directory": "[parameters('sftp_scheduled_file_ingest_budget_staffing_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory')]"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-07-06T05:00:00",
						"timeZone": "Central Standard Time"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/SFTP_TO_MAIN_FOR_PROCESSING')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_scheduled_file_ingest_daily_actuals')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "SFTP_TO_MAIN_FOR_PROCESSING",
							"type": "PipelineReference"
						},
						"parameters": {
							"SourceStore_Location": "[parameters('sftp_scheduled_file_ingest_daily_actuals_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location')]",
							"SourceStore_Directory": "[parameters('sftp_scheduled_file_ingest_daily_actuals_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory')]",
							"DestinationStore_Location": "[parameters('sftp_scheduled_file_ingest_daily_actuals_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location')]",
							"DestinationStore_Directory": "[parameters('sftp_scheduled_file_ingest_daily_actuals_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory')]"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-07-06T05:00:00",
						"timeZone": "Central Standard Time"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/SFTP_TO_MAIN_FOR_PROCESSING')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_scheduled_file_ingest_fulfillment_forecasts')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "SFTP_TO_MAIN_FOR_PROCESSING",
							"type": "PipelineReference"
						},
						"parameters": {
							"SourceStore_Location": "[parameters('sftp_scheduled_file_ingest_fulfillment_forecasts_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location')]",
							"SourceStore_Directory": "[parameters('sftp_scheduled_file_ingest_fulfillment_forecasts_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory')]",
							"DestinationStore_Location": "[parameters('sftp_scheduled_file_ingest_fulfillment_forecasts_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location')]",
							"DestinationStore_Directory": "[parameters('sftp_scheduled_file_ingest_fulfillment_forecasts_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory')]"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-07-04T05:00:00",
						"timeZone": "Central Standard Time"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/SFTP_TO_MAIN_FOR_PROCESSING')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_scheduled_file_ingest_item_master')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "SFTP_TO_MAIN_FOR_PROCESSING",
							"type": "PipelineReference"
						},
						"parameters": {
							"SourceStore_Location": "[parameters('sftp_scheduled_file_ingest_item_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location')]",
							"SourceStore_Directory": "[parameters('sftp_scheduled_file_ingest_item_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory')]",
							"DestinationStore_Location": "[parameters('sftp_scheduled_file_ingest_item_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location')]",
							"DestinationStore_Directory": "[parameters('sftp_scheduled_file_ingest_item_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory')]"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-07-04T05:10:00",
						"timeZone": "Central Standard Time"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/SFTP_TO_MAIN_FOR_PROCESSING')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_scheduled_file_ingest_location_master')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "SFTP_TO_MAIN_FOR_PROCESSING",
							"type": "PipelineReference"
						},
						"parameters": {
							"SourceStore_Location": "[parameters('sftp_scheduled_file_ingest_location_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location')]",
							"SourceStore_Directory": "[parameters('sftp_scheduled_file_ingest_location_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory')]",
							"DestinationStore_Location": "[parameters('sftp_scheduled_file_ingest_location_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location')]",
							"DestinationStore_Directory": "[parameters('sftp_scheduled_file_ingest_location_master_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory')]"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-07-04T05:30:00",
						"timeZone": "Central Standard Time"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/SFTP_TO_MAIN_FOR_PROCESSING')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_scheduled_file_ingest_order_history')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "SFTP_TO_MAIN_FOR_PROCESSING",
							"type": "PipelineReference"
						},
						"parameters": {
							"SourceStore_Location": "[parameters('sftp_scheduled_file_ingest_order_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location')]",
							"SourceStore_Directory": "[parameters('sftp_scheduled_file_ingest_order_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory')]",
							"DestinationStore_Location": "[parameters('sftp_scheduled_file_ingest_order_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location')]",
							"DestinationStore_Directory": "[parameters('sftp_scheduled_file_ingest_order_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory')]"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-07-09T05:02:00",
						"timeZone": "Central Standard Time"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/SFTP_TO_MAIN_FOR_PROCESSING')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_scheduled_file_ingest_staffing_history')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "SFTP_TO_MAIN_FOR_PROCESSING",
							"type": "PipelineReference"
						},
						"parameters": {
							"SourceStore_Location": "[parameters('sftp_scheduled_file_ingest_staffing_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Location')]",
							"SourceStore_Directory": "[parameters('sftp_scheduled_file_ingest_staffing_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_SourceStore_Directory')]",
							"DestinationStore_Location": "[parameters('sftp_scheduled_file_ingest_staffing_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Location')]",
							"DestinationStore_Directory": "[parameters('sftp_scheduled_file_ingest_staffing_history_properties_SFTP_TO_MAIN_FOR_PROCESSING_parameters_DestinationStore_Directory')]"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-07-09T05:00:00",
						"timeZone": "Central Standard Time"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/SFTP_TO_MAIN_FOR_PROCESSING')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_upload_budget_staffing')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "BUDGET_STAFFING",
							"type": "PipelineReference"
						},
						"parameters": {
							"folder_path": "[parameters('sftp_upload_budget_staffing_properties_BUDGET_STAFFING_parameters_folder_path')]",
							"file_name": "[parameters('sftp_upload_budget_staffing_properties_BUDGET_STAFFING_parameters_file_name')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/main/blobs/Radial/BudgetStaffing",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('sftp_upload_budget_staffing_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/BUDGET_STAFFING')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_upload_daily_actuals')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "DAILY_ACTUALS",
							"type": "PipelineReference"
						},
						"parameters": {
							"folder_path": "[parameters('sftp_upload_daily_actuals_properties_DAILY_ACTUALS_parameters_folder_path')]",
							"file_name": "[parameters('sftp_upload_daily_actuals_properties_DAILY_ACTUALS_parameters_file_name')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/main/blobs/Radial/DailyActuals",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('sftp_upload_daily_actuals_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/DAILY_ACTUALS')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_upload_file_ingest_all_pipelines')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "SFTP_REDIRECT_BLOB_SINGLE",
							"type": "PipelineReference"
						},
						"parameters": {
							"folder_path": "[parameters('sftp_upload_file_ingest_all_pipelines_properties_SFTP_REDIRECT_BLOB_SINGLE_parameters_folder_path')]",
							"container": "[parameters('sftp_upload_file_ingest_all_pipelines_properties_SFTP_REDIRECT_BLOB_SINGLE_parameters_container')]"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-07-22T05:00:00",
						"timeZone": "Central Standard Time"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/SFTP_REDIRECT_BLOB_SINGLE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_upload_fulfillment_forecast')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "FULFILLMENT_FORECAST",
							"type": "PipelineReference"
						},
						"parameters": {
							"folder_path": "[parameters('sftp_upload_fulfillment_forecast_properties_FULFILLMENT_FORECAST_parameters_folder_path')]",
							"file_name": "[parameters('sftp_upload_fulfillment_forecast_properties_FULFILLMENT_FORECAST_parameters_file_name')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/main/blobs/Radial/FulfillmentForecast",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('sftp_upload_fulfillment_forecast_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/FULFILLMENT_FORECAST')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_upload_item_master')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "ITEM_MASTER_DATALAKE",
							"type": "PipelineReference"
						},
						"parameters": {
							"filename": "[parameters('sftp_upload_item_master_properties_ITEM_MASTER_DATALAKE_parameters_filename')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/main/blobs/Radial/ItemMaster",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('sftp_upload_item_master_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/ITEM_MASTER_DATALAKE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_upload_location_master')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "LOCATION_MASTER",
							"type": "PipelineReference"
						},
						"parameters": {
							"folder_path": "[parameters('sftp_upload_location_master_properties_LOCATION_MASTER_parameters_folder_path')]",
							"file_name": "[parameters('sftp_upload_location_master_properties_LOCATION_MASTER_parameters_file_name')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/main/blobs/Radial/LocationMaster",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('sftp_upload_location_master_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/LOCATION_MASTER')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_upload_order_history')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "ORDER_HISTORY_COPY",
							"type": "PipelineReference"
						},
						"parameters": {
							"filename": "[parameters('sftp_upload_order_history_properties_ORDER_HISTORY_COPY_parameters_filename')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/main/blobs/Radial/OrderHistory",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('sftp_upload_order_history_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/ORDER_HISTORY_COPY')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_upload_shipment_history')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "SHIPMENT_HISTORY_COPY",
							"type": "PipelineReference"
						},
						"parameters": {
							"filename": "[parameters('sftp_upload_shipment_history_properties_SHIPMENT_HISTORY_COPY_parameters_filename')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/main/blobs/Radial/ShipmentHistory",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('sftp_upload_shipment_history_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/SHIPMENT_HISTORY_COPY')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sftp_upload_staffing_history')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "STAFFING_HISTORY",
							"type": "PipelineReference"
						},
						"parameters": {
							"file_name": "[parameters('sftp_upload_staffing_history_properties_STAFFING_HISTORY_parameters_file_name')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/main/blobs/Radial/StaffingHistory",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('sftp_upload_staffing_history_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/STAFFING_HISTORY')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/AutoResolveIntegrationRuntime')]",
			"type": "Microsoft.DataFactory/factories/integrationRuntimes",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "AutoResolve",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 0,
							"cleanup": true
						},
						"pipelineExternalComputeScaleProperties": {
							"timeToLive": 60
						}
					}
				},
				"managedVirtualNetwork": {
					"type": "ManagedVirtualNetworkReference",
					"referenceName": "default"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/managedVirtualNetworks/default')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow_EDA')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ORDER_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "EDA_Temp",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "AGGOrders"
						},
						{
							"name": "sort1"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Order ID} as string,",
						"          {Order Line ID} as string,",
						"          Channel as string,",
						"          {Order Date} as date,",
						"          {Order Original Ship Date} as string,",
						"          {Order Actual Ship Date} as string,",
						"          {Order Due Date} as string,",
						"          {Order Received Date And Time} as string,",
						"          {Order Completed Date and Time} as string,",
						"          {Destination Zip Code} as string,",
						"          {Item Code} as string,",
						"          {Order Quantity} as float,",
						"          {Quantity (UOM) Picked} as string,",
						"          {Order Status} as string,",
						"          Carrier as string,",
						"          {Service Type} as string,",
						"          {Shipment Fees} as string,",
						"          {Order Value} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: true) ~> source1",
						"filter1 aggregate(groupBy({Order Date}),",
						"     Orders = count({Order ID}),",
						"          {Order Quantity} = sum({Order Quantity})) ~> AGGOrders",
						"AGGOrders sort(asc({Order Date}, true)) ~> sort1",
						"source1 filter({Order Date}>=toDate('2023-01-01')) ~> filter1",
						"sort1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0777,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ORDER_HISTORY_RAW')]",
				"[concat(variables('factoryId'), '/datasets/EDA_Temp')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_budget_staffing')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "BUDGET_STAFFING_RAW",
								"type": "DatasetReference"
							},
							"name": "staffing"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyTable"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "LocationsTable"
						},
						{
							"dataset": {
								"referenceName": "enum_types",
								"type": "DatasetReference"
							},
							"name": "EnumTypeDB"
						},
						{
							"dataset": {
								"referenceName": "enum_values",
								"type": "DatasetReference"
							},
							"name": "EnumValue"
						},
						{
							"dataset": {
								"referenceName": "operationalprofile",
								"type": "DatasetReference"
							},
							"name": "operationalprofile"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "operational_calendar",
								"type": "DatasetReference"
							},
							"name": "WriteToDatabase"
						},
						{
							"dataset": {
								"referenceName": "failedvalidationrowsbudgetstaffing",
								"type": "DatasetReference"
							},
							"name": "sinkfailedrows"
						}
					],
					"transformations": [
						{
							"name": "THTSelected"
						},
						{
							"name": "JoinTHT"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "LocationsSelected"
						},
						{
							"name": "JoinLocationsTable"
						},
						{
							"name": "JoinEnumLocationMetricType"
						},
						{
							"name": "FilterEnumLocationMetricType"
						},
						{
							"name": "JoinLocationMetricTypeEnum"
						},
						{
							"name": "FilterBusinessUnit"
						},
						{
							"name": "Unpivot"
						},
						{
							"name": "selectoperationalprofile"
						},
						{
							"name": "joinoperationalprofile"
						},
						{
							"name": "FIlterOrgRecords"
						},
						{
							"name": "selectOrgRecords"
						},
						{
							"name": "joinORGTHTD"
						},
						{
							"name": "assertBudgetStaffing"
						},
						{
							"name": "selectpivotcolumns"
						},
						{
							"name": "splitValidationRows"
						},
						{
							"name": "deriveErrors"
						},
						{
							"name": "pivot1"
						},
						{
							"name": "selectvalidrowcols"
						},
						{
							"name": "RenameEnumBranches"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "MapDrifted1",
							"description": "Creates an explicit mapping for each drifted column"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('Radial/BudgetStaffing/20240718T050000-BudgetStaffingPlan.csv')",
						"}",
						"source(output(",
						"          {Organization ID} as string,",
						"          {Business ID} as string,",
						"          {Location Code} as string,",
						"          {Staffing Profile} as string,",
						"          Date as date,",
						"          {Units per Hour} as float,",
						"          {Max FTE Regular Hours} as float,",
						"          {Min FTE Regular Hours} as float,",
						"          {Max Temp Regular Hours} as float,",
						"          {Min Temp Regular Hours} as float,",
						"          {Max FTE Overtime Hours} as float,",
						"          {Max Temp Overtime Hours} as float,",
						"          {Regular FTE Wage} as float,",
						"          {Regular Temp Wage} as float,",
						"          {Overtime FTE Wage} as float,",
						"          {Overtime Temp Wage} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: true,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)],",
						"     mode: 'read') ~> staffing",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyTable",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> LocationsTable",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EnumTypeDB",
						"source(output(",
						"          id as integer,",
						"          enum_type_id as integer,",
						"          value_id as integer,",
						"          value as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EnumValue",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> operationalprofile",
						"FilterBusinessUnit select(mapColumn(",
						"          business_unit_id = id,",
						"          tenant_id,",
						"          organization_id = parent_id,",
						"          bu_tenant_hierarchy_code = tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> THTSelected",
						"selectpivotcolumns, joinORGTHTD join({Business ID} == bu_tenant_hierarchy_code",
						"     && {Organization ID} == org_tenant_hierarchy_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHT",
						"selectvalidrowcols alterRow(upsertIf(true())) ~> AlterRow1",
						"LocationsTable select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          name,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LocationsSelected",
						"JoinTHT, LocationsSelected join({Location Code} == location_code",
						"     && THTSelected@business_unit_id == LocationsSelected@business_unit_id",
						"     && THTSelected@organization_id == LocationsSelected@organization_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocationsTable",
						"FilterEnumLocationMetricType, EnumValue join(EnumTypeDB@id == enum_type_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinEnumLocationMetricType",
						"EnumTypeDB filter(name=='location_staffing') ~> FilterEnumLocationMetricType",
						"JoinLocationsTable, RenameEnumBranches join(location_metric_type == value,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocationMetricTypeEnum",
						"TenantHeirarchyTable filter(tenant_hierarchy_type==3) ~> FilterBusinessUnit",
						"staffing unpivot(output(",
						"          location_metric_type as string,",
						"          {Units per Hour} as float,",
						"          {Max FTE Regular Hours} as float,",
						"          {Min FTE Regular Hours} as float,",
						"          {Max Temp Regular Hours} as float,",
						"          {Min Temp Regular Hours} as float,",
						"          {Max FTE Overtime Hours} as float,",
						"          {Max Temp Overtime Hours} as float,",
						"          {Regular FTE Wage} as float,",
						"          {Regular Temp Wage} as float,",
						"          {Overtime FTE Wage} as float,",
						"          {Overtime Temp Wage} as float",
						"     ),",
						"     ungroupBy(Date,",
						"          {Organization ID},",
						"          {Business ID},",
						"          {Location Code},",
						"          {Staffing Profile},",
						"          file_name),",
						"     lateral: true,",
						"     ignoreNullPivots: false) ~> Unpivot",
						"operationalprofile select(mapColumn(",
						"          profile_id = id,",
						"          name,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectoperationalprofile",
						"JoinLocationMetricTypeEnum, selectoperationalprofile join({Staffing Profile} == selectoperationalprofile@name",
						"     && THTSelected@organization_id == selectoperationalprofile@organization_id",
						"     && THTSelected@business_unit_id == selectoperationalprofile@business_unit_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinoperationalprofile",
						"TenantHeirarchyTable filter(tenant_hierarchy_type==2) ~> FIlterOrgRecords",
						"FIlterOrgRecords select(mapColumn(",
						"          org_id = id,",
						"          org_tenant_hierarchy_code = tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectOrgRecords",
						"THTSelected, selectOrgRecords join(organization_id == org_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinORGTHTD",
						"joinoperationalprofile assert(expectTrue(not(isNull(THTSelected@organization_id)) && not(isNull(THTSelected@business_unit_id)), false, 'ORGBUNOTEXISTS', null, 'organization and business unit id doesnt match with existing records'),",
						"     expectTrue(not(isNull(location_id)), false, 'LocationNotExists', not(isNull(THTSelected@business_unit_id)), 'Location Code Not Matching With Existing Records'),",
						"     expectTrue(not(isNull(profile_id)), false, 'ProfileNotExists', not(isNull(THTSelected@business_unit_id)), 'Operational Profile DOesn'),",
						"     expectTrue(not(isNull(enum_value_id)), false, 'EnumValueError', not(isNull(THTSelected@business_unit_id))),",
						"     expectTrue(iif(isNull(location_metric_value),true(),not(isNull(toFloat(location_metric_value)))), false, 'NonNumericValuesFound')) ~> assertBudgetStaffing",
						"Unpivot select(mapColumn(",
						"          Date,",
						"          {Organization ID},",
						"          {Business ID},",
						"          {Location Code},",
						"          {Staffing Profile},",
						"          file_name,",
						"          location_metric_type,",
						"          location_metric_value = {Units per Hour}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectpivotcolumns",
						"deriveErrors split(isNull(validation_errors),",
						"     disjoint: false) ~> splitValidationRows@(ValidRows, ValidationFailedRows)",
						"assertBudgetStaffing derive(validation_errors = assertErrorMessages(),",
						"          failedfilename = replace($file_path,'Radial','faileduploads')) ~> deriveErrors",
						"derivedColumn1 pivot(groupBy({Organization ID},",
						"          Date,",
						"          {Business ID},",
						"          {Location Code},",
						"          {Staffing Profile},",
						"          validation_errors,",
						"          failedfilename),",
						"     pivotBy(value),",
						"     {} = sum(location_metric_value),",
						"     columnNaming: '$N$V',",
						"     lateral: true) ~> pivot1",
						"splitValidationRows@ValidRows select(mapColumn(",
						"          Date,",
						"          location_metric_type,",
						"          location_metric_value,",
						"          business_unit_id = splitValidationRows@ValidRows@business_unit_id,",
						"          tenant_id,",
						"          organization_id = splitValidationRows@ValidRows@organization_id,",
						"          location_id,",
						"          enum_type_id,",
						"          operational_profile_id = profile_id,",
						"          validation_errors,",
						"          enum_value_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectvalidrowcols",
						"JoinEnumLocationMetricType select(mapColumn(",
						"          enum_type_id = EnumTypeDB@id,",
						"          name,",
						"          enum_value_id = EnumValue@id,",
						"          value_id,",
						"          value",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RenameEnumBranches",
						"splitValidationRows@ValidationFailedRows derive(validation_errors = toString(validation_errors)) ~> derivedColumn1",
						"pivot1 derive({Max FTE Overtime Hours} = toDouble(byName('Max FTE Overtime Hours')),",
						"          {Max FTE Regular Hours} = toDouble(byName('Max FTE Regular Hours')),",
						"          {Max Temp Overtime Hours} = toDouble(byName('Max Temp Overtime Hours')),",
						"          {Max Temp Regular Hours} = toDouble(byName('Max Temp Regular Hours')),",
						"          {Min FTE Regular Hours} = toDouble(byName('Min FTE Regular Hours')),",
						"          {Min Temp Regular Hours} = toDouble(byName('Min Temp Regular Hours')),",
						"          {Overtime FTE Wage} = toDouble(byName('Overtime FTE Wage')),",
						"          {Overtime Temp Wage} = toDouble(byName('Overtime Temp Wage')),",
						"          {Regular FTE Wage} = toDouble(byName('Regular FTE Wage')),",
						"          {Regular Temp Wage} = toDouble(byName('Regular Temp Wage')),",
						"          {Units per Hour} = toDouble(byName('Units per Hour'))) ~> MapDrifted1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          location_id as integer,",
						"          date as date,",
						"          location_metric_value as decimal(0,0),",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          enum_value_id as integer,",
						"          enum_type_id as integer,",
						"          operational_profile_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['location_id','date','enum_value_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          business_unit_id,",
						"          organization_id,",
						"          location_id,",
						"          date = Date,",
						"          location_metric_value,",
						"          enum_value_id,",
						"          enum_type_id,",
						"          operational_profile_id",
						"     )) ~> WriteToDatabase",
						"MapDrifted1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failedfilename',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sinkfailedrows"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/BUDGET_STAFFING_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/enum_types')]",
				"[concat(variables('factoryId'), '/datasets/enum_values')]",
				"[concat(variables('factoryId'), '/datasets/operationalprofile')]",
				"[concat(variables('factoryId'), '/datasets/operational_calendar')]",
				"[concat(variables('factoryId'), '/datasets/failedvalidationrowsbudgetstaffing')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_current_backlog')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CURRENT_BACKLOG_RAW",
								"type": "DatasetReference"
							},
							"name": "currentbacklog"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchydetail"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locationsjoin"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "current_backlog_table",
								"type": "DatasetReference"
							},
							"name": "currentbacklogtable"
						}
					],
					"transformations": [
						{
							"name": "derivebuname"
						},
						{
							"name": "filteractiverows"
						},
						{
							"name": "selectthd"
						},
						{
							"name": "jointhdselect"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "joinlocationsselected"
						},
						{
							"name": "fulfillmentserviceselected"
						},
						{
							"name": "joinfulfillmentservicesselected"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterActive"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Brand as string,",
						"          {Fulfillment Location} as string,",
						"          {Backlog Date} as date,",
						"          {Open Backlog Units} as long,",
						"          {Open Backlog Orders} as long,",
						"          {Average UPO} as float,",
						"          {Ship Via} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> currentbacklog",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchydetail",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locationsjoin",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"currentbacklog derive(business_unit_name = split(split(split(file_name,'/')[4],'.')[1],'_')[1],",
						"          testregex = regexReplace(upper({Fulfillment Location}),'[^0-9A-Z]','')) ~> derivebuname",
						"tenantheirarchydetail filter(tenant_hierarchy_type==3) ~> filteractiverows",
						"filteractiverows select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectthd",
						"derivebuname, selectthd join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointhdselect",
						"FilterActive select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          name,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"jointhdselect, selectlocations join(regexReplace(upper({Fulfillment Location}), '[^A-Z0-9]','') == regexReplace(upper(selectlocations@name),'[^0-9A-Z]','')",
						"     && selectthd@business_unit_id == selectlocations@business_unit_id",
						"     && selectthd@organization_id == selectlocations@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocationsselected",
						"fulfillmentservices select(mapColumn(",
						"          fulfillment_service_id = id,",
						"          service_name,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> fulfillmentserviceselected",
						"joinlocationsselected, fulfillmentserviceselected join(concat(upper({Ship Via}),'_RADIAL') == upper(service_name),",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinfulfillmentservicesselected",
						"joinfulfillmentservicesselected alterRow(upsertIf(true())) ~> AlterRow1",
						"locationsjoin filter(status=='Active') ~> FilterActive",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          backlog_date as date,",
						"          open_backlog_units as long,",
						"          open_backlog_orders as long,",
						"          average_upo as float,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['location_id','backlog_date','fulfillment_service_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          organization_id = selectthd@organization_id,",
						"          business_unit_id = selectthd@business_unit_id,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          backlog_date = {Backlog Date},",
						"          open_backlog_units = {Open Backlog Units},",
						"          open_backlog_orders = {Open Backlog Orders},",
						"          average_upo = {Average UPO}",
						"     )) ~> currentbacklogtable"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/CURRENT_BACKLOG_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_services')]",
				"[concat(variables('factoryId'), '/datasets/current_backlog_table')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_daily_actuals')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DAILY_ACTUALS_RAW",
								"type": "DatasetReference"
							},
							"name": "dailyactuals"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchydetail"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locationsjoin"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "current_backlog_table",
								"type": "DatasetReference"
							},
							"name": "currentbacklogtable"
						},
						{
							"dataset": {
								"referenceName": "failedrowsdailyactualssftp",
								"type": "DatasetReference"
							},
							"name": "failedrowssinkdailyactuals"
						}
					],
					"transformations": [
						{
							"name": "filteractiverows"
						},
						{
							"name": "selectthd"
						},
						{
							"name": "jointhdselect"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "joinlocationsselected"
						},
						{
							"name": "fulfillmentserviceselected"
						},
						{
							"name": "joinfulfillmentservicesselected"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "filterordrecords"
						},
						{
							"name": "selectorgcols"
						},
						{
							"name": "joinTHTDBranches"
						},
						{
							"name": "validationrows"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "splitvalidationrows"
						},
						{
							"name": "select2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('Radial/DailyActuals/sample_file.csv')",
						"}",
						"source(output(",
						"          {Organization ID} as string,",
						"          {Business ID} as string,",
						"          {Location Code} as string,",
						"          {Fulfillment Service} as string,",
						"          Date as date 'MM/dd/yyyy',",
						"          {Actual Units Received} as string,",
						"          {Actual Orders Received} as string,",
						"          {Actual Units Shipped} as string,",
						"          {Actual Orders Shipped} as string,",
						"          {Actual Packages Shipped} as string,",
						"          {Open Backlog Units} as double '###,###,000.###',",
						"          {Open Backlog Orders} as double '###,###,000.###',",
						"          {Average Open UPO} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)],",
						"     mode: 'read') ~> dailyactuals",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchydetail",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locationsjoin",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"tenantheirarchydetail filter(tenant_hierarchy_type==3) ~> filteractiverows",
						"filteractiverows select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          parent_id,",
						"          bu_tenant_hierarchy_code = tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectthd",
						"dailyactuals, joinTHTDBranches join({Business ID} == bu_tenant_hierarchy_code",
						"     && {Organization ID} == org_tenant_hierarchy_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointhdselect",
						"locationsjoin select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          name,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"jointhdselect, selectlocations join({Location Code} == location_code",
						"     && selectthd@business_unit_id == selectlocations@business_unit_id",
						"     && parent_id == selectlocations@organization_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocationsselected",
						"fulfillmentservices select(mapColumn(",
						"          fulfillment_service_id = id,",
						"          service_name,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> fulfillmentserviceselected",
						"joinlocationsselected, fulfillmentserviceselected join({Fulfillment Service} == service_name",
						"     && selectlocations@business_unit_id == fulfillmentserviceselected@business_unit_id",
						"     && parent_id == fulfillmentserviceselected@organization_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinfulfillmentservicesselected",
						"splitvalidationrows@validrows alterRow(upsertIf(true())) ~> AlterRow1",
						"tenantheirarchydetail filter(tenant_hierarchy_type ==2) ~> filterordrecords",
						"filterordrecords select(mapColumn(",
						"          organization_id = id,",
						"          contact_name,",
						"          tenant_id,",
						"          org_tenant_hierarchy_code = tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectorgcols",
						"selectthd, selectorgcols join(parent_id == organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinTHTDBranches",
						"joinfulfillmentservicesselected assert(expectTrue(not(isNull(selectthd@business_unit_id)) && not(isNull(selectorgcols@organization_id)), false, 'buordnotexists', null, 'Business Unit ID and Org ID doesnot match with existing records'),",
						"     expectTrue(not(isNull(location_id)), false, 'locationnotexists', not(isNull(selectthd@business_unit_id)) && not(isNull(selectorgcols@organization_id)), 'location code doesnt match with existing records'),",
						"     expectTrue(not(isNull(fulfillment_service_id)), false, 'fulfillmentservicenotexists', not(isNull(selectthd@business_unit_id)) && not(isNull(selectorgcols@organization_id)), 'fulfillment services doesnt exist')) ~> validationrows",
						"validationrows derive(validation_errors = assertErrorMessages(),",
						"          failed_file_name = replace($file_path,'Radial','faileduploads')) ~> derivedColumn1",
						"select2 split(isNull(validation_errors),",
						"     disjoint: false) ~> splitvalidationrows@(validrows, validationfailedrows)",
						"derivedColumn1 select(mapColumn(",
						"          {Organization ID},",
						"          {Business ID},",
						"          {Location Code},",
						"          {Fulfillment Service},",
						"          Date,",
						"          {Actual Units Received},",
						"          {Actual Orders Received},",
						"          {Actual Units Shipped},",
						"          {Actual Orders Shipped},",
						"          {Actual Packages Shipped},",
						"          {Open Backlog Units},",
						"          {Open Backlog Orders},",
						"          {Average Open UPO},",
						"          file_name,",
						"          business_unit_id = selectthd@business_unit_id,",
						"          tenant_id = selectthd@tenant_id,",
						"          organization_id = selectorgcols@organization_id,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          validation_errors,",
						"          failed_file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          backlog_date as date,",
						"          open_backlog_units as long,",
						"          open_backlog_orders as long,",
						"          average_upo as float,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['location_id','backlog_date','fulfillment_service_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          organization_id,",
						"          business_unit_id,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          backlog_date = Date,",
						"          open_backlog_units = {Open Backlog Units},",
						"          open_backlog_orders = {Open Backlog Orders},",
						"          average_upo = {Average Open UPO}",
						"     )) ~> currentbacklogtable",
						"splitvalidationrows@validationfailedrows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> failedrowssinkdailyactuals"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/DAILY_ACTUALS_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_services')]",
				"[concat(variables('factoryId'), '/datasets/current_backlog_table')]",
				"[concat(variables('factoryId'), '/datasets/failedrowsdailyactualssftp')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_demand_forecast_core')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DEMAND_FORECAST_RAW",
								"type": "DatasetReference"
							},
							"name": "demandforecastraw"
						},
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "item"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "micro_area",
								"type": "DatasetReference"
							},
							"name": "microarea"
						},
						{
							"dataset": {
								"referenceName": "customertypes",
								"type": "DatasetReference"
							},
							"name": "customertype"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchydetail"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "forecast",
								"type": "DatasetReference"
							},
							"name": "forecast"
						}
					],
					"transformations": [
						{
							"name": "derivebu"
						},
						{
							"name": "joinitems"
						},
						{
							"name": "selectitems"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "selectmicroarea"
						},
						{
							"name": "selectcustomertype"
						},
						{
							"name": "selectfulfillmentservicetype"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "joinmicroarea"
						},
						{
							"name": "joincustomertypes"
						},
						{
							"name": "joinfulfillmentservice"
						},
						{
							"name": "jointhtd"
						},
						{
							"name": "selectTHTD"
						},
						{
							"name": "filterbu"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "derivebuandorg"
						},
						{
							"name": "filtertransaction"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/DemandForecast/10.txt'),",
						"     mode as string ('UX-Upload'),",
						"     transaction_id as string ('10')",
						"}",
						"source(output(",
						"          {Item ID*} as string,",
						"          {Area ID (3 Digit Zip Code)*} as string,",
						"          {Customer Type} as string,",
						"          {Fulfillment Service*} as string,",
						"          {Forecast Start Date*} as date 'yyyy-MM-dd',",
						"          {Forecast End Date*} as date 'yyyy-MM-dd',",
						"          {Low Demand Quantity} as string,",
						"          {Consensus Demand Quantity} as string,",
						"          {High Demand Quantity} as string,",
						"          {Fulfillment Location ID} as string,",
						"          {Fixed Fulfillment} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> demandforecastraw",
						"source(output(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> item",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          micro_area_code as string,",
						"          description as string,",
						"          primary_fulfillment_location as integer,",
						"          attribute_1 as string,",
						"          attribute_2 as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> microarea",
						"source(output(",
						"          id as integer,",
						"          customer_type_code as string,",
						"          type as string,",
						"          description as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> customertype",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchydetail",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"demandforecastraw derive(business_unit_name = split(split($file_path,\"/\")[5],'_')[1],",
						"          fixed_fulfillment = 12,",
						"          transaction_id = iif($mode=='UX-Upload', toInteger(split(split($file_path,'/')[5],'.')[1]), 0)) ~> derivebu",
						"derivebuandorg, selectitems join({Item ID*} == item_code",
						"     && derivebuandorg@business_unit_id == selectitems@business_unit_id",
						"     && derivebuandorg@organization_id == selectitems@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinitems",
						"item select(mapColumn(",
						"          item_id = id,",
						"          item_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectitems",
						"locations select(mapColumn(",
						"          fulfillment_location = id,",
						"          location_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"microarea select(mapColumn(",
						"          area_id = id,",
						"          micro_area_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectmicroarea",
						"customertype select(mapColumn(",
						"          customer_type = id,",
						"          customer_type_code = type,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcustomertype",
						"fulfillmentservices select(mapColumn(",
						"          fulfillment_service = id,",
						"          service_name,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectfulfillmentservicetype",
						"joinitems, selectlocations join({Fulfillment Location ID} == location_code",
						"     && derivebuandorg@business_unit_id == selectlocations@business_unit_id",
						"     && derivebuandorg@organization_id == selectlocations@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"joinlocations, selectmicroarea join({Area ID (3 Digit Zip Code)*} == micro_area_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinmicroarea",
						"joinmicroarea, selectcustomertype join({Customer Type} == customer_type_code",
						"     && derivebuandorg@business_unit_id == selectcustomertype@business_unit_id",
						"     && derivebuandorg@organization_id == selectcustomertype@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joincustomertypes",
						"joincustomertypes, selectfulfillmentservicetype join({Fulfillment Service*} == service_name",
						"     && derivebuandorg@business_unit_id == selectfulfillmentservicetype@business_unit_id",
						"     && derivebuandorg@organization_id == selectfulfillmentservicetype@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinfulfillmentservice",
						"derivebu, selectTHTD join(business_unit_name == bu_name,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointhtd",
						"filterbu select(mapColumn(",
						"          ftp_bu_id = id,",
						"          bu_name = name,",
						"          tenant_id,",
						"          ftp_organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectTHTD",
						"tenantheirarchydetail filter(tenant_hierarchy_type==3) ~> filterbu",
						"filtertransaction select(mapColumn(",
						"          ih_id = id,",
						"          ih_business_unit_id = business_unit_id,",
						"          ih_organization_id = organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"jointhtd, selectimporthistory join(transaction_id == ih_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory derive(business_unit_id = iif($mode=='UX-Upload',ih_business_unit_id,ftp_bu_id),",
						"          organization_id = iif($mode=='UX-Upload',ih_organization_id,ftp_organization_id),",
						"          area_hierarchy_id = 1) ~> derivebuandorg",
						"importhistory filter(id == toInteger($transaction_id)) ~> filtertransaction",
						"joinfulfillmentservice sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          item_id as integer,",
						"          area_id as integer,",
						"          customer_type as integer,",
						"          fulfillment_service as integer,",
						"          forecast_start_date as timestamp,",
						"          forecast_end_date as timestamp,",
						"          fulfillment_location as integer,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          low_demand_quantity as integer,",
						"          consensus_demand_quantity as integer,",
						"          high_demand_quantity as integer,",
						"          fixed_fulfillment as boolean,",
						"          area_hierarchy_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     postSQLs:['\\n'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          item_id,",
						"          area_id,",
						"          customer_type,",
						"          fulfillment_service,",
						"          forecast_start_date = {Forecast Start Date*},",
						"          forecast_end_date = {Forecast End Date*},",
						"          fulfillment_location,",
						"          organization_id,",
						"          business_unit_id,",
						"          low_demand_quantity = {Low Demand Quantity},",
						"          consensus_demand_quantity = {Consensus Demand Quantity},",
						"          high_demand_quantity = {High Demand Quantity},",
						"          fixed_fulfillment,",
						"          area_hierarchy_id",
						"     )) ~> forecast"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/DEMAND_FORECAST_RAW')]",
				"[concat(variables('factoryId'), '/datasets/item')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/micro_area')]",
				"[concat(variables('factoryId'), '/datasets/customertypes')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_services')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/forecast')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_demand_forecast_validation')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DEMAND_FORECAST_UX_UPLOAD",
								"type": "DatasetReference"
							},
							"name": "demandforecastuxupload"
						},
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "item"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "micro_area",
								"type": "DatasetReference"
							},
							"name": "microarea"
						},
						{
							"dataset": {
								"referenceName": "customertypes",
								"type": "DatasetReference"
							},
							"name": "customertypes"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarychyDetail"
						},
						{
							"dataset": {
								"referenceName": "forecast",
								"type": "DatasetReference"
							},
							"name": "demandforecastcheck"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "forecast",
								"type": "DatasetReference"
							},
							"name": "validdemandforecast"
						},
						{
							"dataset": {
								"referenceName": "FailedUXUploadDemandForecast",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "validations"
						},
						{
							"name": "derivations"
						},
						{
							"name": "aggregationerrors"
						},
						{
							"name": "join1"
						},
						{
							"name": "splitvalidationrows"
						},
						{
							"name": "mapissueroute"
						},
						{
							"name": "RenameBackwards"
						},
						{
							"name": "filterthtd"
						},
						{
							"name": "joinTHTD"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "SelectColumnsMain"
						},
						{
							"name": "joinitem"
						},
						{
							"name": "joinlocation"
						},
						{
							"name": "selectitems"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "selectmicroarea"
						},
						{
							"name": "selectcustomertypes"
						},
						{
							"name": "selectfulfillmentservice"
						},
						{
							"name": "joincustomertype"
						},
						{
							"name": "joinarea"
						},
						{
							"name": "joinfulfillmentservice"
						},
						{
							"name": "joindemandforecast"
						},
						{
							"name": "deriveddemandforecast"
						},
						{
							"name": "filtertemp"
						},
						{
							"name": "joinExistingRecErrors"
						},
						{
							"name": "outputfilenamefailed"
						},
						{
							"name": "nonnumericvalsinnumericfields"
						},
						{
							"name": "recordid"
						},
						{
							"name": "findduplicates"
						},
						{
							"name": "filtertransaction"
						},
						{
							"name": "joinbuorgtransactionlocation"
						},
						{
							"name": "jointransactionuorgitem"
						},
						{
							"name": "jointransactionbuorgcusttype"
						},
						{
							"name": "jointransactionbuorgfservice"
						},
						{
							"name": "jointransactionbuorgdemandforecast"
						},
						{
							"name": "selectextrecords"
						},
						{
							"name": "filterrowswithvalidationerrors"
						},
						{
							"name": "removeemptyrows"
						},
						{
							"name": "joinImportHistoryMain"
						},
						{
							"name": "derivedtransactionid"
						},
						{
							"name": "selectdemandforecasts"
						},
						{
							"name": "selectextrecordsload"
						},
						{
							"name": "joinLoadValuesSelectCols"
						},
						{
							"name": "datatypeconversions"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/TEST/Upload/DemandForecast/464.xlsx'),",
						"     transaction_id as string ('464')",
						"}",
						"source(output(",
						"          {Item ID*} as string,",
						"          {Area ID (3 Digit Zip Code)*} as string,",
						"          {Customer Type} as string,",
						"          {Fulfillment Service*} as string,",
						"          {Forecast Start Date*} as date 'yyyy-MM-dd',",
						"          {Forecast End Date*} as date 'yyyy-MM-dd',",
						"          {Low Demand Quantity} as string,",
						"          {Consensus Demand Quantity} as string,",
						"          {High Demand Quantity} as string,",
						"          {Fulfillment Location ID} as string,",
						"          {Fixed Fulfillment} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> demandforecastuxupload",
						"source(output(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> item",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          micro_area_code as string,",
						"          description as string,",
						"          primary_fulfillment_location as integer,",
						"          attribute_1 as string,",
						"          attribute_2 as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> microarea",
						"source(output(",
						"          id as integer,",
						"          customer_type_code as string,",
						"          type as string,",
						"          description as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> customertypes",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarychyDetail",
						"source(output(",
						"          id as integer,",
						"          item_id as integer,",
						"          area_id as integer,",
						"          customer_type as integer,",
						"          fulfillment_service as integer,",
						"          forecast_start_date as timestamp,",
						"          forecast_end_date as timestamp,",
						"          fulfillment_location as integer,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          low_demand_quantity as integer,",
						"          consensus_demand_quantity as integer,",
						"          high_demand_quantity as integer,",
						"          fixed_fulfillment as boolean,",
						"          area_hierarchy_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> demandforecastcheck",
						"removeemptyrows, selectlocations, selectitems, selectmicroarea, selectcustomertypes, selectfulfillmentservice assert(expectTrue(not(isNull(mapissueroute@Item_ID))&&\r",
						"not(isNull(mapissueroute@Area_ID))&&\r",
						"not(isNull(Customer_Type))&&\r",
						"not(isNull(Fulfillment_Service))&&\r",
						"not(isNull(Fulfillment_Location_ID)), false, 'mandatoryvalues', null, 'mandatory values missing'),",
						"     expectExists(Fulfillment_Location_ID == location_code, false, 'locations', null, 'location code not found'),",
						"     expectExists(mapissueroute@Item_ID == item_code, false, 'item', null, 'item code not matching'),",
						"     expectExists(mapissueroute@Area_ID == micro_area_code, false, 'microarea', null, 'area code not matching'),",
						"     expectExists(Fulfillment_Service == service_name, false, 'fulfillmentservices', null, 'fulfillment service type not matching'),",
						"     expectExists(Customer_Type == type, false, 'customertype', null, 'customer type not matching'),",
						"     expectTrue(isNull(presence), false, 'recordisnew', null, 'record already exists'),",
						"     expectTrue(numericfieldintegrity, false, 'numericintegrity', null, 'numerical field contains non numeric values'),",
						"     expectTrue(notduplicatedrow, false, 'dataduplicated', null, 'duplicate records detected in upload')) ~> validations",
						"RenameBackwards derive(validation_errors = assertErrorMessages(),",
						"          transaction_id = toInteger($transaction_id),",
						"          sink_file_name = replace(file_name,'.xlsx','.txt'),",
						"          file_name_failed_rows = replace(file_name,'/Upload/','/FailedTransactions/'),",
						"          fixed_fulfillment = 12) ~> derivations",
						"derivations aggregate(groupBy(file_name),",
						"     errors_count = countIf(not(isNull(validation_errors)))) ~> aggregationerrors",
						"derivations, aggregationerrors join(RenameBackwards@file_name == aggregationerrors@file_name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"SelectColumnsMain split(errors_count==0,",
						"     disjoint: false) ~> splitvalidationrows@(validrows, validationfailedrows)",
						"joinExistingRecErrors select(mapColumn(",
						"          Item_ID = {Item ID*},",
						"          Area_ID = {Area ID (3 Digit Zip Code)*},",
						"          Customer_Type = {Customer Type},",
						"          Fulfillment_Service = {Fulfillment Service*},",
						"          {Forecast Start Date} = {Forecast Start Date*},",
						"          {Forecast End Date} = {Forecast End Date*},",
						"          {Low Demand Quantity},",
						"          {Consensus Demand Quantity},",
						"          {High Demand Quantity},",
						"          Fulfillment_Location_ID = {Fulfillment Location ID},",
						"          {Fixed Fulfillment},",
						"          file_name,",
						"          presence,",
						"          numericfieldintegrity,",
						"          notduplicatedrow = nonduplicatedrow,",
						"          recordid = recordid@recordid",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> mapissueroute",
						"validations select(mapColumn(",
						"          {Item ID*} = mapissueroute@Item_ID,",
						"          {Area ID (3 Digit Zip Code)*} = mapissueroute@Area_ID,",
						"          {Customer Type} = Customer_Type,",
						"          {Fulfillment Service*} = Fulfillment_Service,",
						"          {Forecast Start Date*} = {Forecast Start Date},",
						"          {Forecast End Date*} = {Forecast End Date},",
						"          {Low Demand Quantity},",
						"          {Consensus Demand Quantity},",
						"          {High Demand Quantity},",
						"          {Fulfillment Location ID} = Fulfillment_Location_ID,",
						"          {Fixed Fulfillment},",
						"          file_name,",
						"          recordid",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RenameBackwards",
						"TenantHeirarychyDetail filter(tenant_hierarchy_type==3) ~> filterthtd",
						"filtertransaction, filterthtd join(business_unit_id == TenantHeirarychyDetail@id",
						"     && organization_id == parent_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinTHTD",
						"joinTHTD select(mapColumn(",
						"          transaction_id = importhistory@id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"join1 select(mapColumn(",
						"          {Item ID*},",
						"          {Area ID (3 Digit Zip Code)*},",
						"          {Customer Type},",
						"          {Fulfillment Service*},",
						"          {Forecast Start Date*},",
						"          {Forecast End Date*},",
						"          {Low Demand Quantity},",
						"          {Consensus Demand Quantity},",
						"          {High Demand Quantity},",
						"          {Fulfillment Location ID},",
						"          file_name = RenameBackwards@file_name,",
						"          validation_errors,",
						"          transaction_id,",
						"          sink_file_name,",
						"          errors_count,",
						"          recordid,",
						"          fixed_fulfillment",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumnsMain",
						"joinImportHistoryMain, selectitems join({Item ID*} == item_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinitem",
						"joinitem, selectlocations join({Fulfillment Location ID} == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocation",
						"jointransactionuorgitem select(mapColumn(",
						"          item_id = id,",
						"          item_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectitems",
						"joinbuorgtransactionlocation select(mapColumn(",
						"          location_id = id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"microarea select(mapColumn(",
						"          area_id = id,",
						"          micro_area_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectmicroarea",
						"jointransactionbuorgcusttype select(mapColumn(",
						"          customer_type_id = id,",
						"          customer_type_code,",
						"          type",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcustomertypes",
						"jointransactionbuorgfservice select(mapColumn(",
						"          fulfillment_service_id = id,",
						"          fulfillment_service_code,",
						"          service_name,",
						"          service_type",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectfulfillmentservice",
						"joinlocation, selectcustomertypes join({Customer Type} == type,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joincustomertype",
						"joincustomertype, selectmicroarea join({Area ID (3 Digit Zip Code)*} == micro_area_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinarea",
						"joinarea, selectfulfillmentservice join({Fulfillment Service*} == service_name,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinfulfillmentservice",
						"joinfulfillmentservice, selectdemandforecasts join(selectitems@item_id == selectdemandforecasts@item_id",
						"     && selectmicroarea@area_id == selectdemandforecasts@area_id",
						"     && location_id == fulfillment_location",
						"     && customer_type_id == customer_type",
						"     && fulfillment_service_id == fulfillment_service",
						"     && {Forecast Start Date*} == forecast_start_date",
						"     && {Forecast End Date*} == forecast_end_date,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joindemandforecast",
						"filtertemp derive(presence = 'true',",
						"          forecast_start_date = toDate(toString(forecast_start_date)),",
						"          forecast_end_date = toDate(toString(forecast_end_date))) ~> deriveddemandforecast",
						"jointransactionbuorgdemandforecast filter(not(isNull(fulfillment_location))) ~> filtertemp",
						"nonnumericvalsinnumericfields, selectextrecords join(recordid@recordid == selectextrecords@recordid,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinExistingRecErrors",
						"filterrowswithvalidationerrors derive(failed_file_name = replace(replace($file_path,'/Upload/','/FailedTransactions/'),'.xlsx','.json'),",
						"          type = 'error',",
						"          message = concat('record number ',toString(recordid),' has following errors ',toString(validation_errors))) ~> outputfilenamefailed",
						"findduplicates derive(numericfieldintegrity = iif(isNull({Low Demand Quantity}),true(),not(isNull(toFloat({Low Demand Quantity})))) && iif(isNull({Consensus Demand Quantity}),true(),not(isNull(toFloat({Consensus Demand Quantity})))) && iif(isNull({High Demand Quantity}),true(),not(isNull(toFloat({High Demand Quantity})))) &&  iif(isNull({Fixed Fulfillment}),true(),not(isNull(toFloat({Fixed Fulfillment}))))) ~> nonnumericvalsinnumericfields",
						"demandforecastuxupload keyGenerate(output(recordid as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> recordid",
						"recordid window(over({Item ID*},",
						"          {Area ID (3 Digit Zip Code)*},",
						"          {Fulfillment Service*},",
						"          {Customer Type},",
						"          {Forecast Start Date*},",
						"          {Forecast End Date*},",
						"          {Fulfillment Location ID}),",
						"     asc(recordid, true),",
						"     nonduplicatedrow = rowNumber()==1) ~> findduplicates",
						"importhistory filter(id == toInteger($transaction_id)) ~> filtertransaction",
						"locations, selectimporthistory join(locations@business_unit_id == selectimporthistory@business_unit_id",
						"     && locations@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinbuorgtransactionlocation",
						"item, selectimporthistory join(item@business_unit_id == selectimporthistory@business_unit_id",
						"     && item@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransactionuorgitem",
						"customertypes, selectimporthistory join(customertypes@business_unit_id == selectimporthistory@business_unit_id",
						"     && customertypes@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransactionbuorgcusttype",
						"fulfillmentservices, selectimporthistory join(fulfillmentservices@business_unit_id == selectimporthistory@business_unit_id",
						"     && fulfillmentservices@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransactionbuorgfservice",
						"demandforecastcheck, selectimporthistory join(demandforecastcheck@business_unit_id == selectimporthistory@business_unit_id",
						"     && demandforecastcheck@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransactionbuorgdemandforecast",
						"joindemandforecast select(mapColumn(",
						"          recordid,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectextrecords",
						"splitvalidationrows@validationfailedrows filter(not(isNull(validation_errors))) ~> filterrowswithvalidationerrors",
						"mapissueroute filter(not(isNull(Item_ID)) || not(isNull(Area_ID)) || not(isNull(Customer_Type)) || not(isNull(Fulfillment_Service)) || not(isNull({Forecast Start Date})) || not(isNull({Forecast End Date})) || not(isNull({Low Demand Quantity})) || not(isNull({High Demand Quantity})) || not(isNull(Fulfillment_Location_ID)) || not(isNull({Fixed Fulfillment}))) ~> removeemptyrows",
						"derivedtransactionid, selectimporthistory join(derivedtransactionid@transaction_id == selectimporthistory@transaction_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinImportHistoryMain",
						"recordid derive(transaction_id = toInteger($transaction_id)) ~> derivedtransactionid",
						"deriveddemandforecast select(mapColumn(",
						"          item_id,",
						"          area_id,",
						"          customer_type,",
						"          fulfillment_service,",
						"          forecast_start_date,",
						"          forecast_end_date,",
						"          fulfillment_location,",
						"          area_hierarchy_id,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectdemandforecasts",
						"joindemandforecast select(mapColumn(",
						"          file_name,",
						"          item_id = selectitems@item_id,",
						"          recordid,",
						"          business_unit_id,",
						"          organization_id,",
						"          location_id,",
						"          customer_type_id,",
						"          area_id = selectmicroarea@area_id,",
						"          fulfillment_service_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectextrecordsload",
						"splitvalidationrows@validrows, selectextrecordsload join(splitvalidationrows@validrows@recordid == selectextrecordsload@recordid,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinLoadValuesSelectCols",
						"joinLoadValuesSelectCols derive({Low Demand Quantity} = toInteger({Low Demand Quantity}),",
						"          {Consensus Demand Quantity} = toInteger({Consensus Demand Quantity}),",
						"          {High Demand Quantity} = toInteger({High Demand Quantity})) ~> datatypeconversions",
						"datatypeconversions sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          item_id as integer,",
						"          area_id as integer,",
						"          customer_type as integer,",
						"          fulfillment_service as integer,",
						"          forecast_start_date as timestamp,",
						"          forecast_end_date as timestamp,",
						"          fulfillment_location as integer,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          low_demand_quantity as integer,",
						"          consensus_demand_quantity as integer,",
						"          high_demand_quantity as integer,",
						"          fixed_fulfillment as boolean,",
						"          area_hierarchy_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          item_id,",
						"          area_id,",
						"          customer_type = customer_type_id,",
						"          fulfillment_service = fulfillment_service_id,",
						"          forecast_start_date = {Forecast Start Date*},",
						"          forecast_end_date = {Forecast End Date*},",
						"          fulfillment_location = location_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          low_demand_quantity = {Low Demand Quantity},",
						"          consensus_demand_quantity = {Consensus Demand Quantity},",
						"          high_demand_quantity = {High Demand Quantity},",
						"          fixed_fulfillment,",
						"          area_hierarchy_id = area_id",
						"     ),",
						"     preCommands: [],",
						"     postCommands: []) ~> validdemandforecast",
						"outputfilenamefailed sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/DEMAND_FORECAST_UX_UPLOAD')]",
				"[concat(variables('factoryId'), '/datasets/item')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/micro_area')]",
				"[concat(variables('factoryId'), '/datasets/customertypes')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_services')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/forecast')]",
				"[concat(variables('factoryId'), '/datasets/FailedUXUploadDemandForecast')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_fulfillment_forcast_ux')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "IMPORT_MANAGER_MERGED"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "FULFILLMENT_FORECAST_UX_STAGING",
								"type": "DatasetReference"
							},
							"name": "FulfillmentSource"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importHistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "importLocations"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_forecast",
								"type": "DatasetReference"
							},
							"name": "fulfillmentforecast"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "fulfillment_forecast",
								"type": "DatasetReference"
							},
							"name": "validfulfillmentforecast"
						},
						{
							"dataset": {
								"referenceName": "Error_Json",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "NewRecordID"
						},
						{
							"name": "TransactionID"
						},
						{
							"name": "selectimportdetails"
						},
						{
							"name": "JoiningIDs"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "joinLocations"
						},
						{
							"name": "selectfulfillmentidandname"
						},
						{
							"name": "joinFullfillments"
						},
						{
							"name": "elemenateUnwantedColumns"
						},
						{
							"name": "nonduplicate"
						},
						{
							"name": "numericalintegrity"
						},
						{
							"name": "deriverrors"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "join1"
						},
						{
							"name": "filter2"
						},
						{
							"name": "Addingpresence"
						},
						{
							"name": "selectfulfillmentcast"
						},
						{
							"name": "assert3"
						},
						{
							"name": "select7"
						},
						{
							"name": "splitingbasedonerrors"
						},
						{
							"name": "filter3"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "joingwithimport"
						},
						{
							"name": "select8"
						},
						{
							"name": "join4"
						},
						{
							"name": "join5"
						},
						{
							"name": "join6"
						},
						{
							"name": "changecolumntypes"
						},
						{
							"name": "filter4"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/FulfillmentForecast/643.xlsx'),",
						"     transaction_id as string ('643')",
						"}",
						"source(output(",
						"          {Forecast Date*} as date,",
						"          {Forecast 1 Units} as string,",
						"          {Forecast 1 Orders} as string,",
						"          {Forecast 2 Units} as string,",
						"          {Units per Order} as string,",
						"          {Forecast Locked Date} as date,",
						"          {Fulfillment Service*} as string,",
						"          {Fulfillment Location ID*} as string,",
						"          {Forecast 2 Orders} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'filename',",
						"     wildcardPaths:[($file_path)]) ~> FulfillmentSource",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importHistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importLocations",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"source(output(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          forecast_date as date,",
						"          locked_forecast_units as long,",
						"          current_forecast_units as long,",
						"          average_upo as float,",
						"          locked_forecast_orders as long,",
						"          current_forecast_orders as long,",
						"          forecast_locked_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          forecast_3_units as long,",
						"          forecast_3_orders as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     inferDriftedColumnTypes: true,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentforecast",
						"FulfillmentSource keyGenerate(output(recordid as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> NewRecordID",
						"NewRecordID derive(transaction_id = toInteger($transaction_id)) ~> TransactionID",
						"filter2 select(mapColumn(",
						"          import_history_id = id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimportdetails",
						"numericalintegrity, selectimportdetails join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoiningIDs",
						"join5 select(mapColumn(",
						"          location_id = id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"JoiningIDs, selectlocations join(Fulfillment_Location_ID_SC == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinLocations",
						"join6 select(mapColumn(",
						"          fulfillment_service_id = id,",
						"          service_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectfulfillmentidandname",
						"join4, selectfulfillmentcast join(select8@location_id == selectfulfillmentcast@location_id",
						"     && selectfulfillmentidandname@fulfillment_service_id == selectfulfillmentcast@fulfillment_service_id",
						"     && Forecast_Date_SC == forecast_date,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinFullfillments",
						"TransactionID select(mapColumn(",
						"          Forecast_Date_SC = {Forecast Date*},",
						"          Forecast_1_Units_SC = {Forecast 1 Units},",
						"          Forecast_1_Orders_SC = {Forecast 1 Orders},",
						"          Forecast_2_Units_SC = {Forecast 2 Units},",
						"          Units_per_Order_SC = {Units per Order},",
						"          Forecast_Locked_Date_SC = {Forecast Locked Date},",
						"          Fulfillment_Service_SC = {Fulfillment Service*},",
						"          Fulfillment_Location_ID_SC = {Fulfillment Location ID*},",
						"          Forecast_2_Orders_SC = {Forecast 2 Orders},",
						"          filename,",
						"          recordid,",
						"          transaction_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> elemenateUnwantedColumns",
						"elemenateUnwantedColumns window(over(filename,",
						"          {Fulfillment_Location_ID*} = Fulfillment_Location_ID_SC,",
						"          {Fulfillment_Service*} = Fulfillment_Service_SC,",
						"          {Forecast_Date*} = Forecast_Date_SC,",
						"          Forecast_Locked_Date = Forecast_Locked_Date_SC),",
						"     asc(recordid, true),",
						"     nonduplicate_row = rowNumber() == 1) ~> nonduplicate",
						"nonduplicate derive(numericalintegrity = iif(isNull(Forecast_1_Units_SC),true(),not(isNull(toFloat(Forecast_1_Units_SC)))) && iif(isNull(Forecast_1_Orders_SC),true(),not(isNull(toFloat(Forecast_1_Orders_SC)))) && iif(isNull(Forecast_2_Units_SC),true(),not(isNull(toFloat(Forecast_2_Units_SC)))) && iif(isNull(Forecast_2_Orders_SC),true(),not(isNull(toFloat(Forecast_2_Orders_SC)))) && iif(isNull(Units_per_Order_SC),true(),not(isNull(toFloat(Units_per_Order_SC))))) ~> numericalintegrity",
						"assert3 derive(validation_errors = assertErrorMessages(),",
						"          transaction_id = toInteger($transaction_id),",
						"          type = 'Error') ~> deriverrors",
						"deriverrors aggregate(groupBy(filename),",
						"     error_count = countIf(not(isNull(validation_errors)))) ~> aggregate1",
						"deriverrors, aggregate1 join(select7@filename == aggregate1@filename,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"importHistory filter(toInteger(id) == toInteger($transaction_id)) ~> filter2",
						"joingwithimport derive(presence = 'true') ~> Addingpresence",
						"Addingpresence select(mapColumn(",
						"          organization_id = fulfillmentforecast@organization_id,",
						"          business_unit_id = fulfillmentforecast@business_unit_id,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          forecast_date,",
						"          locked_forecast_units,",
						"          current_forecast_units,",
						"          average_upo,",
						"          locked_forecast_orders,",
						"          current_forecast_orders,",
						"          forecast_locked_date,",
						"          created_date,",
						"          updated_date,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectfulfillmentcast",
						"filter4, selectlocations, selectfulfillmentidandname assert(expectTrue(not(isNull(Fulfillment_Location_ID_SC)) && not(isNull(Fulfillment_Service_SC)) && not(isNull(Forecast_Date_SC)), false, 'nullvalues', null, 'Null Values Found In Mandatory Fields'),",
						"     expectExists(Fulfillment_Location_ID_SC == selectlocations@location_code, false, 'locationexist', null, 'Location ID Not Found In Database'),",
						"     expectExists(Fulfillment_Service_SC == selectfulfillmentidandname@service_name, false, 'profileexist', null, 'Fulfillment Service Does Not Exists In Database'),",
						"     expectTrue(isNull(presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
						"     expectTrue(numericalintegrity, false, 'numericalfieldintegrity', null, 'Numerical Fields Contains Non Numeric Values'),",
						"     expectTrue(nonduplicate_row, false, 'duplicateddata', null, 'Duplicate Records Found In Upload')) ~> assert3",
						"joinFullfillments select(mapColumn(",
						"          Forecast_Date_SC,",
						"          Forecast_1_Units_SC,",
						"          Forecast_1_Orders_SC,",
						"          Forecast_2_Units_SC,",
						"          Units_per_Order_SC,",
						"          Forecast_Locked_Date_SC,",
						"          Fulfillment_Service_SC,",
						"          Fulfillment_Location_ID_SC,",
						"          Forecast_2_Orders_SC,",
						"          filename,",
						"          recordid,",
						"          transaction_id,",
						"          nonduplicate_row,",
						"          numericalintegrity,",
						"          location_id = select8@location_id,",
						"          location_code,",
						"          organization_id = select8@organization_id,",
						"          business_unit_id = select8@business_unit_id,",
						"          fulfillment_service_id = selectfulfillmentidandname@fulfillment_service_id,",
						"          service_name,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select7",
						"join1 split(error_count == 0,",
						"     disjoint: false) ~> splitingbasedonerrors@(validrows, invalidrows)",
						"splitingbasedonerrors@invalidrows filter(not(isNull(validation_errors))) ~> filter3",
						"filter3 derive(failed_file_name = replace(replace(replace($file_path, 'staging/', ''), '/Upload/', '/FailedTransactions/'), '.xlsx', '.json'),",
						"          error_message = concat('record number ',toString(recordid),' has following errors ',toString(validation_errors)),",
						"          type = 'error') ~> derivedColumn1",
						"fulfillmentforecast, selectimportdetails join(fulfillmentforecast@organization_id == selectimportdetails@organization_id",
						"     && fulfillmentforecast@business_unit_id == selectimportdetails@business_unit_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joingwithimport",
						"joinLocations select(mapColumn(",
						"          Forecast_Date_SC,",
						"          Forecast_1_Units_SC,",
						"          Forecast_1_Orders_SC,",
						"          Forecast_2_Units_SC,",
						"          Units_per_Order_SC,",
						"          Forecast_Locked_Date_SC,",
						"          Fulfillment_Service_SC,",
						"          Fulfillment_Location_ID_SC,",
						"          Forecast_2_Orders_SC,",
						"          filename,",
						"          recordid,",
						"          transaction_id,",
						"          nonduplicate_row,",
						"          numericalintegrity,",
						"          import_history_id,",
						"          location_id,",
						"          location_code,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select8",
						"select8, selectfulfillmentidandname join(Fulfillment_Service_SC == service_name,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join4",
						"importLocations, selectimportdetails join(importLocations@organization_id == selectimportdetails@organization_id",
						"     && importLocations@organization_id == selectimportdetails@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join5",
						"fulfillmentservices, selectimportdetails join(fulfillmentservices@organization_id == selectimportdetails@organization_id",
						"     && fulfillmentservices@business_unit_id == selectimportdetails@business_unit_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join6",
						"splitingbasedonerrors@validrows derive(Forecast_1_Units_SC = toLong(Forecast_1_Units_SC),",
						"          Forecast_1_Orders_SC = toLong(Forecast_1_Orders_SC),",
						"          Forecast_2_Units_SC = toLong(Forecast_2_Units_SC),",
						"          Forecast_2_Orders_SC = toLong(Forecast_2_Orders_SC),",
						"          Units_per_Order_SC = toFloat(Units_per_Order_SC)) ~> changecolumntypes",
						"select7 filter(not(isNull(Fulfillment_Location_ID_SC)) || not(isNull(Fulfillment_Service_SC)) || not(isNull(Forecast_Date_SC)) || not(isNull(Forecast_1_Units_SC)) || not(isNull(Forecast_1_Orders_SC)) || not(isNull(Forecast_2_Units_SC)) || not(isNull(Forecast_Locked_Date_SC)) || not(isNull(Units_per_Order_SC))) ~> filter4",
						"changecolumntypes sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          forecast_date as date,",
						"          locked_forecast_units as long,",
						"          current_forecast_units as long,",
						"          average_upo as float,",
						"          locked_forecast_orders as long,",
						"          current_forecast_orders as long,",
						"          forecast_locked_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          forecast_3_units as long,",
						"          forecast_3_orders as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          organization_id,",
						"          business_unit_id,",
						"          location_id = splitingbasedonerrors@validrows@location_id,",
						"          fulfillment_service_id = splitingbasedonerrors@validrows@fulfillment_service_id,",
						"          forecast_date = Forecast_Date_SC,",
						"          locked_forecast_units = Forecast_1_Units_SC,",
						"          current_forecast_units = Forecast_2_Units_SC,",
						"          average_upo = Units_per_Order_SC,",
						"          locked_forecast_orders = Forecast_1_Orders_SC,",
						"          current_forecast_orders = Forecast_2_Orders_SC,",
						"          forecast_locked_date = Forecast_Locked_Date_SC",
						"     )) ~> validfulfillmentforecast",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message = error_message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/FULFILLMENT_FORECAST_UX_STAGING')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_services')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_forecast')]",
				"[concat(variables('factoryId'), '/datasets/Error_Json')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_fulfillment_forecast')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "FULFILLMENT_FORECAST_RAW",
								"type": "DatasetReference"
							},
							"name": "fulfillmentforecast"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "LocationMaster"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "fulfillment_forecast",
								"type": "DatasetReference"
							},
							"name": "sinkfullfillmentforecast"
						},
						{
							"dataset": {
								"referenceName": "SFTP_Failed_FulfillmentForecast",
								"type": "DatasetReference"
							},
							"name": "sinkfailedftpfiles"
						}
					],
					"transformations": [
						{
							"name": "THDSelected"
						},
						{
							"name": "JoinTHDSelected"
						},
						{
							"name": "LocationsSelected"
						},
						{
							"name": "JoinLocations"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "filterburecords"
						},
						{
							"name": "filterorgrecords"
						},
						{
							"name": "joinorgrecords"
						},
						{
							"name": "selectorgbranch"
						},
						{
							"name": "assert1"
						},
						{
							"name": "derivederrors"
						},
						{
							"name": "splitvalidationrows"
						}
					],
					"scriptLines": [
						"parameters{",
						"     filename as string ('Radial/FulfillmentForecast/sample_file_ff_20240624.csv')",
						"}",
						"source(output(",
						"          {Organization ID} as string,",
						"          {Business ID} as string,",
						"          {Location Code} as string,",
						"          {Fulfillment Service} as string,",
						"          {Forecast Date} as date 'MM/dd/yyyy',",
						"          {Locked Forecast Units} as long '000,000,000',",
						"          {Current Forecast Units} as long '000,000,000',",
						"          {Forecast 3 Units} as string,",
						"          {Average Locked UPO} as string,",
						"          {Locked Forecast Orders} as string,",
						"          {Current Forecast Orders} as string,",
						"          {Forecast 3 Orders} as string,",
						"          {Forecast Locked Date} as date 'MM/dd/yyyy'",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($filename)],",
						"     mode: 'read') ~> fulfillmentforecast",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> LocationMaster",
						"joinorgrecords select(mapColumn(",
						"          business_unit_id = id,",
						"          tenant_id,",
						"          organization_id = parent_id,",
						"          bu_tenant_hierarchy_code = tenant_hierarchy_code,",
						"          org_tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> THDSelected",
						"fulfillmentforecast, THDSelected join({Business ID} == bu_tenant_hierarchy_code",
						"     && {Organization ID} == org_tenant_hierarchy_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHDSelected",
						"LocationMaster select(mapColumn(",
						"          location_code,",
						"          location_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LocationsSelected",
						"JoinTHDSelected, LocationsSelected join({Location Code} == location_code",
						"     && THDSelected@business_unit_id == LocationsSelected@business_unit_id",
						"     && THDSelected@tenant_id == LocationsSelected@tenant_id",
						"     && THDSelected@organization_id == LocationsSelected@organization_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocations",
						"splitvalidationrows@validrows alterRow(upsertIf(true())) ~> AlterRow1",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type == 3) ~> filterburecords",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type == 2) ~> filterorgrecords",
						"filterburecords, selectorgbranch join(parent_id == org_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinorgrecords",
						"filterorgrecords select(mapColumn(",
						"          org_id = id,",
						"          org_tenant_id = tenant_id,",
						"          org_parent_id = parent_id,",
						"          org_tenant_hierarchy_code = tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectorgbranch",
						"JoinLocations assert(expectTrue(not(isNull(THDSelected@business_unit_id)) && not(isNull(THDSelected@organization_id)), false, 'assertthtd', null, 'Business Unit & Organization ID doesnot match with existing record'),",
						"     expectTrue(not(isNull(location_id)), false, 'assertlocations', not(isNull(THDSelected@business_unit_id)) && not(isNull(THDSelected@organization_id)), 'Location ID Doesnt Exist In Database'),",
						"     expectTrue(iif(isNull({Locked Forecast Units}),true(),not(isNull(toFloat({Locked Forecast Units})))) && iif(isNull({Current Forecast Units}),true(),not(isNull(toFloat({Current Forecast Units})))) && iif(isNull({Forecast 3 Units}),true(),not(isNull(toFloat({Forecast 3 Units})))) && iif(isNull({Average Locked UPO}),true(),not(isNull(toFloat({Average Locked UPO})))) && iif(isNull({Locked Forecast Orders}),true(),not(isNull(toFloat({Locked Forecast Orders})))) && iif(isNull({Current Forecast Orders}),true(),not(isNull(toFloat({Current Forecast Orders})))) && iif(isNull({Forecast 3 Orders}),true(),not(isNull(toFloat({Forecast 3 Orders})))), false, 'nonnumericvaluespresent', null, 'Non Numeric Values Present In Numeric Field')) ~> assert1",
						"assert1 derive(validation_errors = assertErrorMessages(),",
						"          failedfilename = replace($filename,'Radial','faileduploads')) ~> derivederrors",
						"derivederrors split(isNull(validation_errors),",
						"     disjoint: false) ~> splitvalidationrows@(validrows, validationfailedrows)",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          forecast_date as date,",
						"          locked_forecast_units as long,",
						"          current_forecast_units as long,",
						"          average_upo as float,",
						"          locked_forecast_orders as long,",
						"          current_forecast_orders as long,",
						"          forecast_locked_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          forecast_3_units as long,",
						"          forecast_3_orders as long",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['location_id','forecast_date'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          organization_id = splitvalidationrows@validrows@organization_id,",
						"          business_unit_id = splitvalidationrows@validrows@business_unit_id,",
						"          location_id,",
						"          forecast_date = {Forecast Date},",
						"          locked_forecast_units = {Locked Forecast Units},",
						"          current_forecast_units = {Current Forecast Units},",
						"          forecast_locked_date = {Forecast Locked Date},",
						"          average_upo = {Average Locked UPO}",
						"     )) ~> sinkfullfillmentforecast",
						"splitvalidationrows@validationfailedrows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failedfilename',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     quoteAll: true,",
						"     mapColumn(",
						"          {Organization ID},",
						"          {Business ID},",
						"          {Location Code},",
						"          {Fulfillment Service},",
						"          {Forecast Date},",
						"          {Locked Forecast Units},",
						"          {Current Forecast Units},",
						"          {Forecast 3 Units},",
						"          {Average Locked UPO},",
						"          {Locked Forecast Orders},",
						"          {Current Forecast Orders},",
						"          {Forecast 3 Orders},",
						"          {Forecast Locked Date},",
						"          file_name,",
						"          validation_errors",
						"     )) ~> sinkfailedftpfiles"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/FULFILLMENT_FORECAST_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_forecast')]",
				"[concat(variables('factoryId'), '/datasets/SFTP_Failed_FulfillmentForecast')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_inventory')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "INVENTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "inventory"
						},
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "ItemMaster"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "LocationMaster"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyTable"
						},
						{
							"dataset": {
								"referenceName": "enum_types",
								"type": "DatasetReference"
							},
							"name": "EnumType"
						},
						{
							"dataset": {
								"referenceName": "enum_values",
								"type": "DatasetReference"
							},
							"name": "EnumValues"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "inventory",
								"type": "DatasetReference"
							},
							"name": "Write2Inventory"
						}
					],
					"transformations": [
						{
							"name": "THTSelected"
						},
						{
							"name": "LMSelected"
						},
						{
							"name": "IMSelected"
						},
						{
							"name": "DeriveAttributes"
						},
						{
							"name": "JoinTenantHeirarchy"
						},
						{
							"name": "JoinItemMaster"
						},
						{
							"name": "JoinLocationMaster"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterStockType"
						},
						{
							"name": "JoinEnumValues"
						},
						{
							"name": "JoinStockTypeEnum"
						},
						{
							"name": "select1"
						},
						{
							"name": "FilterBU"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Item ID} as string,",
						"          {Location ID} as string,",
						"          {On Hand Stock Date} as date,",
						"          {On Hand Stock Quantity} as float,",
						"          {Reserved On Hold Stock} as float,",
						"          {Available Stock} as float,",
						"          {Lot ID} as string,",
						"          {On Order Due Date} as date,",
						"          {On Order Quantity} as float,",
						"          {Purchase Order Status} as float,",
						"          {On Order Supplier Shipping Date} as date,",
						"          {On Order Promised Delivery Date} as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> inventory",
						"source(output(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> ItemMaster",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> LocationMaster",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyTable",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EnumType",
						"source(output(",
						"          id as integer,",
						"          enum_type_id as integer,",
						"          value_id as integer,",
						"          value as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EnumValues",
						"FilterBU select(mapColumn(",
						"          business_unit_id = id,",
						"          tenant_hierarchy_type,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> THTSelected",
						"LocationMaster select(mapColumn(",
						"          location_id = id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LMSelected",
						"ItemMaster select(mapColumn(",
						"          item_id = id,",
						"          item_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> IMSelected",
						"inventory derive(business_unit_name = split(split(file_name,'/')[4],'_')[1],",
						"          stock_type = 'ON_HAND') ~> DeriveAttributes",
						"DeriveAttributes, THTSelected join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTenantHeirarchy",
						"JoinTenantHeirarchy, IMSelected join({Item ID} == item_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinItemMaster",
						"JoinItemMaster, LMSelected join({Location ID} == location_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocationMaster",
						"select1 alterRow(upsertIf(true())) ~> AlterRow1",
						"EnumType filter(name==\"stock_type\") ~> FilterStockType",
						"FilterStockType, EnumValues join(EnumType@id == enum_type_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinEnumValues",
						"JoinLocationMaster, JoinEnumValues join(stock_type == value,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinStockTypeEnum",
						"JoinStockTypeEnum select(mapColumn(",
						"          {Item ID},",
						"          {Location ID},",
						"          {On Hand Stock Date},",
						"          {On Hand Stock Quantity},",
						"          {Reserved On Hold Stock},",
						"          {Available Stock},",
						"          {Lot ID},",
						"          {On Order Due Date},",
						"          {On Order Quantity},",
						"          {Purchase Order Status},",
						"          {On Order Supplier Shipping Date},",
						"          {On Order Promised Delivery Date},",
						"          file_name,",
						"          business_unit_name,",
						"          stock_type,",
						"          business_unit_id,",
						"          tenant_hierarchy_type,",
						"          name = THTSelected@name,",
						"          tenant_id,",
						"          organization_id,",
						"          item_id,",
						"          item_code,",
						"          location_id,",
						"          location_code,",
						"          name = EnumType@name,",
						"          created_date = EnumType@created_date,",
						"          updated_date = EnumType@updated_date,",
						"          enum_type_id,",
						"          value_id,",
						"          value,",
						"          created_date = EnumValues@created_date,",
						"          updated_date = EnumValues@updated_date",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"TenantHeirarchyTable filter(tenant_hierarchy_type==3) ~> FilterBU",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          item_id as integer,",
						"          location_id as integer,",
						"          on_hand_stock_date as date,",
						"          on_hand_stock_quantity as float,",
						"          reserved_on_hold_stock_ as float,",
						"          available_stock as float,",
						"          lot_id as string,",
						"          on_order_due_date as date,",
						"          on_order_quantity_ as float,",
						"          purchase_order_status as float,",
						"          on_order_supplier_shipping_date as date,",
						"          on_order_promised_delivery_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          stock_type_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['item_id','location_id','on_hand_stock_date'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          item_id,",
						"          location_id,",
						"          on_hand_stock_date = {On Hand Stock Date},",
						"          on_hand_stock_quantity = {On Hand Stock Quantity},",
						"          reserved_on_hold_stock_ = {Reserved On Hold Stock},",
						"          available_stock = {Available Stock},",
						"          lot_id = {Lot ID},",
						"          on_order_due_date = {On Order Due Date},",
						"          on_order_quantity_ = {On Order Quantity},",
						"          purchase_order_status = {Purchase Order Status},",
						"          on_order_supplier_shipping_date = {On Order Supplier Shipping Date},",
						"          on_order_promised_delivery_date = {On Order Promised Delivery Date},",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          stock_type_id = value_id",
						"     )) ~> Write2Inventory"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/INVENTORY_RAW')]",
				"[concat(variables('factoryId'), '/datasets/item')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/enum_types')]",
				"[concat(variables('factoryId'), '/datasets/enum_values')]",
				"[concat(variables('factoryId'), '/datasets/inventory')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_inventory_ux')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "IMPORT_MANAGER_MERGED"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenanthierarchy"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "fetchinglocations"
						},
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "fetchingitems"
						},
						{
							"dataset": {
								"referenceName": "INVENTORY_UX",
								"type": "DatasetReference"
							},
							"name": "fetchinginventorysource"
						},
						{
							"dataset": {
								"referenceName": "inventory",
								"type": "DatasetReference"
							},
							"name": "fetchinginventory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "inventory",
								"type": "DatasetReference"
							},
							"name": "validinventoryrows"
						},
						{
							"dataset": {
								"referenceName": "FailedInventoryRows",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "filter3"
						},
						{
							"name": "selectimportdetails"
						},
						{
							"name": "join1"
						},
						{
							"name": "choosingtenants"
						},
						{
							"name": "choosinglocations"
						},
						{
							"name": "choosingitems"
						},
						{
							"name": "addingrecordid"
						},
						{
							"name": "nonduplicate"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "renamesourcecolumns"
						},
						{
							"name": "joininglocations"
						},
						{
							"name": "joiningitems"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "selectinginventory"
						},
						{
							"name": "finaldataset"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "joiningTenants"
						},
						{
							"name": "selectedfields"
						},
						{
							"name": "assert1"
						},
						{
							"name": "join3"
						},
						{
							"name": "mergingds"
						},
						{
							"name": "selectrequired"
						},
						{
							"name": "select1"
						},
						{
							"name": "aggregateerrors"
						},
						{
							"name": "join4"
						},
						{
							"name": "splitingtherecordsbasedonerrors"
						},
						{
							"name": "filter4"
						},
						{
							"name": "filter5"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "join5"
						},
						{
							"name": "join6"
						},
						{
							"name": "changecolumntypes"
						}
					],
					"scriptLines": [
						"parameters{",
						"     transaction_id as string ('657'),",
						"     file_path as string ('DEV/Upload/Inventory/657.xlsx')",
						"}",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenanthierarchy",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fetchinglocations",
						"source(output(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fetchingitems",
						"source(output(",
						"          {Item ID} as string,",
						"          {Location ID} as string,",
						"          {Stock Date} as date,",
						"          {Stock Quantity} as string,",
						"          {Reserved Quantity} as string,",
						"          {Available Quantity} as string,",
						"          {On Order ID} as string,",
						"          {On Order Due Date} as date,",
						"          {On Order Supplier Shipping Date} as date,",
						"          {On Order Promised Delivery Date} as date",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> fetchinginventorysource",
						"source(output(",
						"          id as integer,",
						"          item_id as integer,",
						"          location_id as integer,",
						"          on_hand_stock_date as date,",
						"          on_hand_stock_quantity as float,",
						"          reserved_on_hold_stock_ as float,",
						"          available_stock as float,",
						"          lot_id as string,",
						"          on_order_due_date as date,",
						"          on_order_quantity_ as float,",
						"          purchase_order_status as float,",
						"          on_order_supplier_shipping_date as date,",
						"          on_order_promised_delivery_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          stock_type_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fetchinginventory",
						"importhistory filter(id == toInteger($transaction_id)) ~> filter3",
						"filter3 select(mapColumn(",
						"          id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimportdetails",
						"tenanthierarchy, selectimportdetails join(tenanthierarchy@id == business_unit_id",
						"     && parent_id == organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 select(mapColumn(",
						"          tenant_id,",
						"          import_id = selectimportdetails@id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> choosingtenants",
						"join5 select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          organization_id = fetchinglocations@organization_id,",
						"          business_unit_id = fetchinglocations@business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> choosinglocations",
						"join6 select(mapColumn(",
						"          id,",
						"          item_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> choosingitems",
						"fetchinginventorysource keyGenerate(output(record_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> addingrecordid",
						"renamesourcecolumns window(over(Item_ID_SC,",
						"          Location_ID_SC,",
						"          Stock_Date_SC,",
						"          On_Order_Supplier_Shipping_Date_SC,",
						"          On_Order_Promised_Delivery_Date_SC,",
						"          On_Order_ID_SC),",
						"     asc(record_id, true),",
						"     nonduplicated = rowNumber() == 1) ~> nonduplicate",
						"nonduplicate derive(numericalintegrity = iif(isNull(Stock_Quantity_SC),true(),not(isNull(toFloat(Stock_Quantity_SC)))) &&  iif(isNull(Reserved_Quantity_SC),true(),not(isNull(toFloat(Reserved_Quantity_SC)))) && iif(isNull(Available_Quantity_SC),true(),not(isNull(toFloat(Available_Quantity_SC))))) ~> derivedColumn1",
						"addingrecordid select(mapColumn(",
						"          Item_ID_SC = {Item ID},",
						"          Location_ID_SC = {Location ID},",
						"          Stock_Date_SC = {Stock Date},",
						"          Stock_Quantity_SC = {Stock Quantity},",
						"          Reserved_Quantity_SC = {Reserved Quantity},",
						"          Available_Quantity_SC = {Available Quantity},",
						"          On_Order_ID_SC = {On Order ID},",
						"          On_Order_Due_Date_SC = {On Order Due Date},",
						"          On_Order_Supplier_Shipping_Date_SC = {On Order Supplier Shipping Date},",
						"          On_Order_Promised_Delivery_Date_SC = {On Order Promised Delivery Date},",
						"          record_id,",
						"          file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> renamesourcecolumns",
						"joiningTenants, choosinglocations join(Location_ID_SC == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joininglocations",
						"joininglocations, choosingitems join(Item_ID_SC == item_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joiningitems",
						"fetchinginventory derive(presence = 'true') ~> derivedColumn3",
						"derivedColumn3 select(mapColumn(",
						"          id,",
						"          item_id,",
						"          location_id,",
						"          on_hand_stock_date,",
						"          on_hand_stock_quantity,",
						"          reserved_on_hold_stock_,",
						"          available_stock,",
						"          lot_id,",
						"          on_order_due_date,",
						"          on_order_quantity_,",
						"          purchase_order_status,",
						"          on_order_supplier_shipping_date,",
						"          on_order_promised_delivery_date,",
						"          created_date,",
						"          updated_date,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          stock_type_id,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectinginventory",
						"joiningitems select(mapColumn(",
						"          Item_ID_SC,",
						"          Location_ID_SC,",
						"          Stock_Date_SC,",
						"          Stock_Quantity_SC,",
						"          Reserved_Quantity_SC,",
						"          Available_Quantity_SC,",
						"          On_Order_ID_SC,",
						"          On_Order_Due_Date_SC,",
						"          On_Order_Supplier_Shipping_Date_SC,",
						"          On_Order_Promised_Delivery_Date_SC,",
						"          record_id,",
						"          filename = file_name,",
						"          nonduplicated,",
						"          stock_type_id,",
						"          transaction_id,",
						"          tenant_id,",
						"          location_id,",
						"          location_code,",
						"          item_id = id,",
						"          item_code,",
						"          business_unit_id = choosingtenants@business_unit_id,",
						"          organization_id = choosingtenants@organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> finaldataset",
						"nonduplicate derive(stock_type_id = 1,",
						"          transaction_id = toInteger($transaction_id)) ~> derivedColumn4",
						"derivedColumn4, choosingtenants join(transaction_id == import_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joiningTenants",
						"join3 select(mapColumn(",
						"          Item_ID_SC,",
						"          Location_ID_SC,",
						"          Stock_Date_SC,",
						"          Stock_Quantity_SC,",
						"          Reserved_Quantity_SC,",
						"          Available_Quantity_SC,",
						"          On_Order_ID_SC,",
						"          On_Order_Due_Date_SC,",
						"          On_Order_Supplier_Shipping_Date_SC,",
						"          On_Order_Promised_Delivery_Date_SC,",
						"          record_id,",
						"          filename,",
						"          nonduplicated,",
						"          numericalintegrity,",
						"          stock_type_id = selectrequired@stock_type_id,",
						"          transaction_id,",
						"          tenant_id = selectrequired@tenant_id,",
						"          organization_id = selectrequired@organization_id,",
						"          business_unit_id = selectrequired@business_unit_id,",
						"          location_id = selectrequired@location_id,",
						"          location_code,",
						"          item_id = selectrequired@item_id,",
						"          item_code,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectedfields",
						"filter4, selectinginventory, choosinglocations, choosingitems assert(expectExists(Location_ID_SC == choosinglocations@location_code, false, 'checklocationexists', null, 'LOCATION ID IS NOT FOUND'),",
						"     expectExists(Item_ID_SC == choosingitems@item_code, false, 'checkitemcodeexists', null, 'ITEM CODE IS NOT FOUND'),",
						"     expectTrue(numericalintegrity, false, 'numericalintegrity', null, 'Non numerical values exist in numerical fields'),",
						"     expectTrue(nonduplicated, false, 'nonduplicate', null, 'Duplicate records found in upload'),",
						"     expectTrue(isNull(selectedfields@presence), false, 'checkrecordexists', null, 'Record Already Exists in DB')) ~> assert1",
						"selectrequired, selectinginventory join(selectrequired@location_id == selectinginventory@location_id",
						"     && selectrequired@item_id == selectinginventory@item_id",
						"     && Stock_Date_SC == on_hand_stock_date",
						"     && selectrequired@stock_type_id == selectinginventory@stock_type_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"derivedColumn1, finaldataset join(renamesourcecolumns@record_id == finaldataset@record_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> mergingds",
						"mergingds select(mapColumn(",
						"          numericalintegrity,",
						"          Item_ID_SC = finaldataset@Item_ID_SC,",
						"          Location_ID_SC = finaldataset@Location_ID_SC,",
						"          Stock_Date_SC = finaldataset@Stock_Date_SC,",
						"          Stock_Quantity_SC = finaldataset@Stock_Quantity_SC,",
						"          Reserved_Quantity_SC = finaldataset@Reserved_Quantity_SC,",
						"          Available_Quantity_SC = finaldataset@Available_Quantity_SC,",
						"          On_Order_ID_SC = finaldataset@On_Order_ID_SC,",
						"          On_Order_Due_Date_SC = finaldataset@On_Order_Due_Date_SC,",
						"          On_Order_Supplier_Shipping_Date_SC = finaldataset@On_Order_Supplier_Shipping_Date_SC,",
						"          On_Order_Promised_Delivery_Date_SC = finaldataset@On_Order_Promised_Delivery_Date_SC,",
						"          record_id = finaldataset@record_id,",
						"          filename,",
						"          nonduplicated = finaldataset@nonduplicated,",
						"          stock_type_id,",
						"          transaction_id,",
						"          tenant_id,",
						"          location_id,",
						"          location_code,",
						"          item_id,",
						"          item_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectrequired",
						"assert1 select(mapColumn(",
						"          Item_ID_SC,",
						"          Location_ID_SC,",
						"          Stock_Date_SC,",
						"          Stock_Quantity_SC,",
						"          Reserved_Quantity_SC,",
						"          Available_Quantity_SC,",
						"          On_Order_ID_SC,",
						"          On_Order_Due_Date_SC,",
						"          On_Order_Supplier_Shipping_Date_SC,",
						"          On_Order_Promised_Delivery_Date_SC,",
						"          record_id,",
						"          filename,",
						"          stock_type_id = selectedfields@stock_type_id,",
						"          tenant_id = selectedfields@tenant_id,",
						"          organization_id = selectedfields@organization_id,",
						"          business_unit_id = selectedfields@business_unit_id,",
						"          location_id = selectedfields@location_id,",
						"          location_code = selectedfields@location_code,",
						"          item_id = selectedfields@item_id,",
						"          item_code = selectedfields@item_code,",
						"          presence = selectedfields@presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"derivedColumn5 aggregate(groupBy(filename),",
						"     error_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
						"derivedColumn5, aggregateerrors join(select1@filename == aggregateerrors@filename,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join4",
						"join4 split(error_count == 0,",
						"     disjoint: false) ~> splitingtherecordsbasedonerrors@(validrows, invalidrows)",
						"selectedfields filter(not(isNull(Item_ID_SC)) || not(isNull(Location_ID_SC)) || not(isNull(Stock_Date_SC)) || not(isNull(Stock_Quantity_SC)) || not(isNull(Reserved_Quantity_SC)) || not(isNull(Available_Quantity_SC)) || not(isNull(On_Order_ID_SC)) || not(isNull(On_Order_Due_Date_SC)) || not(isNull(On_Order_Supplier_Shipping_Date_SC)) || not(isNull(On_Order_Promised_Delivery_Date_SC))) ~> filter4",
						"splitingtherecordsbasedonerrors@invalidrows filter(not(isNull(validation_errors))) ~> filter5",
						"select1 derive(validation_errors = assertErrorMessages(),",
						"          failed_file_name = replace(replace($file_path,'.xlsx','.json'),'/Upload','/FailedTransactions')) ~> derivedColumn5",
						"filter5 derive(type = 'error',",
						"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedColumn6",
						"fetchinglocations, choosingtenants join(fetchinglocations@organization_id == choosingtenants@organization_id",
						"     && fetchinglocations@business_unit_id == choosingtenants@business_unit_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join5",
						"fetchingitems, choosingtenants join(fetchingitems@organization_id == choosingtenants@organization_id",
						"     && fetchingitems@business_unit_id == choosingtenants@business_unit_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join6",
						"splitingtherecordsbasedonerrors@validrows derive(Stock_Quantity_SC = toFloat(Stock_Quantity_SC),",
						"          Reserved_Quantity_SC = toFloat(Reserved_Quantity_SC),",
						"          Available_Quantity_SC = toFloat(Available_Quantity_SC)) ~> changecolumntypes",
						"changecolumntypes sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          item_id as integer,",
						"          location_id as integer,",
						"          on_hand_stock_date as date,",
						"          on_hand_stock_quantity as float,",
						"          reserved_on_hold_stock_ as float,",
						"          available_stock as float,",
						"          lot_id as string,",
						"          on_order_due_date as date,",
						"          on_order_quantity_ as float,",
						"          purchase_order_status as float,",
						"          on_order_supplier_shipping_date as date,",
						"          on_order_promised_delivery_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          stock_type_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          item_id,",
						"          location_id,",
						"          on_hand_stock_date = Stock_Date_SC,",
						"          on_hand_stock_quantity = Stock_Quantity_SC,",
						"          reserved_on_hold_stock_ = Reserved_Quantity_SC,",
						"          available_stock = Available_Quantity_SC,",
						"          lot_id = On_Order_ID_SC,",
						"          on_order_due_date = On_Order_Due_Date_SC,",
						"          on_order_supplier_shipping_date = On_Order_Supplier_Shipping_Date_SC,",
						"          on_order_promised_delivery_date = On_Order_Promised_Delivery_Date_SC,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          stock_type_id",
						"     )) ~> validinventoryrows",
						"derivedColumn6 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/item')]",
				"[concat(variables('factoryId'), '/datasets/INVENTORY_UX')]",
				"[concat(variables('factoryId'), '/datasets/inventory')]",
				"[concat(variables('factoryId'), '/datasets/FailedInventoryRows')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_item_master')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ITEM_MASTER_RAW",
								"type": "DatasetReference"
							},
							"name": "ItemMasterRaw"
						},
						{
							"dataset": {
								"referenceName": "item_heirarchy_detail",
								"type": "DatasetReference"
							},
							"name": "ItemHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "lifecycle_status",
								"type": "DatasetReference"
							},
							"name": "LifecycleStatus"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "TemporaryOutput"
						}
					],
					"transformations": [
						{
							"name": "JoinDepartment"
						},
						{
							"name": "JoinSubDepartment"
						},
						{
							"name": "TenantHeirarchyTableSelected"
						},
						{
							"name": "JoinTenantHeirarchyTable"
						},
						{
							"name": "LifecycleStatusSelected"
						},
						{
							"name": "Department"
						},
						{
							"name": "DepartmentSelected"
						},
						{
							"name": "SubDepartmentSelected"
						},
						{
							"name": "ClassSelected"
						},
						{
							"name": "SubClassSelected"
						},
						{
							"name": "ColorSelected"
						},
						{
							"name": "SizeSelected"
						},
						{
							"name": "StyleSelected"
						},
						{
							"name": "JoinClass"
						},
						{
							"name": "JoinSubClass"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "SizeSecondSelected"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     filepath as string ('Radial/ItemMaster/sample_file.csv')",
						"}",
						"source(output(",
						"          {Organization ID} as string,",
						"          {Business ID} as string,",
						"          {Location Code} as string,",
						"          {Item Code} as string,",
						"          Description as string,",
						"          {Lifecycle Status} as string,",
						"          Department as string,",
						"          Sub_Department as string,",
						"          {Product Division} as string,",
						"          {Product Category} as string,",
						"          {Measurement Unit} as string,",
						"          {Unit Cost} as float,",
						"          {Unit Volume} as float,",
						"          {Unit Weight} as float,",
						"          {Item Unit Price} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($filepath)],",
						"     mode: 'read') ~> ItemMasterRaw",
						"source(output(",
						"          id as string,",
						"          description as string,",
						"          category as string,",
						"          record_creation_date as timestamp,",
						"          record_updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> ItemHeirarchyDetail",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"source(output(",
						"          id as integer,",
						"          status as string,",
						"          lifecycle_code as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> LifecycleStatus",
						"ItemMasterRaw, DepartmentSelected join(ItemMasterRaw@Department == DepartmentSelected@description,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinDepartment",
						"JoinDepartment, SubDepartmentSelected join(ItemMasterRaw@Sub_Department == SubDepartmentSelected@description,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinSubDepartment",
						"filter1 select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          organization_id = parent_id,",
						"          tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> TenantHeirarchyTableSelected",
						"JoinSubClass, TenantHeirarchyTableSelected join({Business ID} == tenant_hierarchy_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTenantHeirarchyTable",
						"LifecycleStatus select(mapColumn(",
						"          sku_lifecycle_status = id,",
						"          lifecycle_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LifecycleStatusSelected",
						"ItemHeirarchyDetail split(category==\"DEPARTMENT\",",
						"     category==\"SUB_DEPARTMENT\",",
						"     category==\"CLASS\",",
						"     category==\"SUB_CLASS\",",
						"     category==\"COLOR\",",
						"     category==\"STYLE\",",
						"     category==\"SIZE\",",
						"     category==\"SIZE\",",
						"     disjoint: true) ~> Department@(Department, SubDepartment, Class, SubClass, Color, Style, Size, SizeSecond)",
						"Department@Department select(mapColumn(",
						"          department = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> DepartmentSelected",
						"Department@SubDepartment select(mapColumn(",
						"          sub_department = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SubDepartmentSelected",
						"Department@Class select(mapColumn(",
						"          class = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> ClassSelected",
						"Department@SubClass select(mapColumn(",
						"          sub_class = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SubClassSelected",
						"Department@Color select(mapColumn(",
						"          color = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> ColorSelected",
						"Department@Size select(mapColumn(",
						"          size = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SizeSelected",
						"Department@Style select(mapColumn(",
						"          style = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StyleSelected",
						"JoinSubDepartment, ClassSelected join({Product Division} == ClassSelected@description,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinClass",
						"JoinClass, SubClassSelected join({Product Category} == SubClassSelected@description,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinSubClass",
						"JoinTenantHeirarchyTable alterRow(upsertIf(true())) ~> AlterRow1",
						"Department@SizeSecond select(mapColumn(",
						"          size_second = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SizeSecondSelected",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type==3) ~> filter1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['item_code','business_unit_id','organization_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          item_code = {Item Code},",
						"          description = ItemMasterRaw@Description,",
						"          short_description = ItemMasterRaw@Description,",
						"          department = DepartmentSelected@department,",
						"          sub_department = SubDepartmentSelected@sub_department,",
						"          product_division = {Product Division},",
						"          class = {Product Category},",
						"          measurement_unit = {Measurement Unit},",
						"          unit_cost = {Unit Cost},",
						"          unit_volume = {Unit Volume},",
						"          unit_weight = {Unit Weight},",
						"          item_unit_price = {Item Unit Price},",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     preCommands: [],",
						"     postCommands: []) ~> TemporaryOutput"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ITEM_MASTER_RAW')]",
				"[concat(variables('factoryId'), '/datasets/item_heirarchy_detail')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/lifecycle_status')]",
				"[concat(variables('factoryId'), '/datasets/item')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_lane_rates')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Dataflow activity created for populating pfp.lane_rates table",
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LANE_RATE_GROUND_RAW",
								"type": "DatasetReference"
							},
							"name": "LaneRateForGround",
							"description": "dataset corresponding to zonewise lane rates"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "HeirarchyTable",
							"description": "Lookup table for fetching organization_id and business unit is"
						},
						{
							"dataset": {
								"referenceName": "LANE_RATE_NEXTDAY_AIR_RAW",
								"type": "DatasetReference"
							},
							"name": "LaneRateForNDA"
						},
						{
							"dataset": {
								"referenceName": "LANE_RATE_2DAY_AIR_RAW",
								"type": "DatasetReference"
							},
							"name": "LaneRateFor2DA",
							"description": "2DA ratecard"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "lane_rate",
								"type": "DatasetReference"
							},
							"name": "tempoutput"
						}
					],
					"transformations": [
						{
							"name": "ExtractAttributesByUnpivot"
						},
						{
							"name": "SelectRelevantColumns"
						},
						{
							"name": "DerivingAttributes"
						},
						{
							"name": "FinalColumnsSelect",
							"description": "Select, rename activities to match the lane_rate table schema"
						},
						{
							"name": "RemoveRowsWithNull",
							"description": "Removing rows with null value on the column rate"
						},
						{
							"name": "SelectColumnsHeirarchyTable",
							"description": "Select specific columns that will be used in downstream activities"
						},
						{
							"name": "JoinHeirarchyTable",
							"description": "Join heirarchy table to extract business_unit_id and organization_id"
						},
						{
							"name": "ExtractAttributesNDA"
						},
						{
							"name": "SelectNDA"
						},
						{
							"name": "RemoveLetterRates2DA"
						},
						{
							"name": "JoinBranches"
						},
						{
							"name": "ExtractAttributes2DA"
						},
						{
							"name": "Select2DA"
						},
						{
							"name": "CombineBeforeFilterLetter"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterBusinessUnitsRecords"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Zones as string,",
						"          {2} as float,",
						"          {3} as float,",
						"          {4} as float,",
						"          {5} as float,",
						"          {6} as float,",
						"          {7} as float,",
						"          {8} as float,",
						"          {44} as float,",
						"          {45} as float,",
						"          {46} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: true,",
						"     rowUrlColumn: 'file_name') ~> LaneRateForGround",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> HeirarchyTable",
						"source(output(",
						"          Zones as string,",
						"          {102.0} as double,",
						"          {103.0} as double,",
						"          {104.0} as double,",
						"          {105.0} as double,",
						"          {106.0} as double,",
						"          {107.0} as double,",
						"          {108.0} as double,",
						"          {124.0} as double,",
						"          {125.0} as double,",
						"          {126} as double",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: true,",
						"     rowUrlColumn: 'file_name') ~> LaneRateForNDA",
						"source(output(",
						"          Zones as string,",
						"          {202.0} as float,",
						"          {203.0} as float,",
						"          {204.0} as float,",
						"          {205.0} as float,",
						"          {206.0} as float,",
						"          {207.0} as float,",
						"          {208.0} as float,",
						"          {224.0} as float,",
						"          {225.0} as float,",
						"          {226} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: true,",
						"     rowUrlColumn: 'file_name') ~> LaneRateFor2DA",
						"LaneRateForGround unpivot(output(",
						"          Class as string,",
						"          {2} as float,",
						"          {3} as float,",
						"          {4} as float,",
						"          {5} as float,",
						"          {6} as float,",
						"          {7} as float,",
						"          {8} as float,",
						"          {44} as float,",
						"          {45} as float,",
						"          {46} as float",
						"     ),",
						"     ungroupBy(Zones,",
						"          file_name),",
						"     lateral: true,",
						"     ignoreNullPivots: false) ~> ExtractAttributesByUnpivot",
						"ExtractAttributesByUnpivot select(mapColumn(",
						"          weight = Zones,",
						"          Zone = Class,",
						"          rate = {2},",
						"          file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectRelevantColumns",
						"JoinBranches derive(rate_code = split(file_name,\"/\")[4]+'-'+split(file_name,\"/\")[5]+'-'+toString(toInteger(Zone), '000'),",
						"          break1_type = 'Weight',",
						"          break1_start = toInteger(replace(weight, ' Lbs.', ''))-1,",
						"          break1_end = toInteger(replace(weight, ' Lbs.', '')),",
						"          rate_type = 'Flat',",
						"          business_unit_name = split(split(file_name,\"/\")[6],'_')[1]) ~> DerivingAttributes",
						"JoinHeirarchyTable select(mapColumn(",
						"          rate_code,",
						"          break1_type,",
						"          break1_start,",
						"          break1_end,",
						"          rate_type,",
						"          rate,",
						"          business_unit_id = id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> FinalColumnsSelect",
						"FinalColumnsSelect filter(not(isNull(rate))) ~> RemoveRowsWithNull",
						"FilterBusinessUnitsRecords select(mapColumn(",
						"          id,",
						"          name,",
						"          parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumnsHeirarchyTable",
						"DerivingAttributes, SelectColumnsHeirarchyTable join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinHeirarchyTable",
						"LaneRateForNDA unpivot(output(",
						"          Class as string,",
						"          {102.0} as double,",
						"          {103.0} as double,",
						"          {104.0} as double,",
						"          {105.0} as double,",
						"          {106.0} as double",
						"     ),",
						"     ungroupBy(Zones,",
						"          file_name),",
						"     lateral: true,",
						"     ignoreNullPivots: false) ~> ExtractAttributesNDA",
						"ExtractAttributesNDA select(mapColumn(",
						"          weight = Zones,",
						"          file_name,",
						"          Zone = Class,",
						"          rate = {102.0}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectNDA",
						"CombineBeforeFilterLetter filter(weight!='Letter') ~> RemoveLetterRates2DA",
						"SelectRelevantColumns, RemoveLetterRates2DA union(byName: true)~> JoinBranches",
						"LaneRateFor2DA unpivot(output(",
						"          Class as string,",
						"          {202.0} as float,",
						"          {203.0} as float,",
						"          {204.0} as float,",
						"          {205.0} as float,",
						"          {206.0} as float",
						"     ),",
						"     ungroupBy(Zones,",
						"          file_name),",
						"     lateral: true,",
						"     ignoreNullPivots: false) ~> ExtractAttributes2DA",
						"ExtractAttributes2DA select(mapColumn(",
						"          weight = Zones,",
						"          file_name,",
						"          Zone = Class,",
						"          rate = {202.0}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> Select2DA",
						"SelectNDA, Select2DA union(byName: true)~> CombineBeforeFilterLetter",
						"RemoveRowsWithNull alterRow(upsertIf(true())) ~> AlterRow1",
						"HeirarchyTable filter(tenant_hierarchy_type==3) ~> FilterBusinessUnitsRecords",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          rate_code as string,",
						"          break1_type as string,",
						"          break1_start as integer,",
						"          break1_end as integer,",
						"          rate_type as string,",
						"          rate as double,",
						"          rate_minimum as double,",
						"          rate_maximum as double,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['rate_code','break1_type','break1_start','break1_end','rate_type'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> tempoutput"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/LANE_RATE_GROUND_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/LANE_RATE_NEXTDAY_AIR_RAW')]",
				"[concat(variables('factoryId'), '/datasets/LANE_RATE_2DAY_AIR_RAW')]",
				"[concat(variables('factoryId'), '/datasets/lane_rate')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_location_master')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LOCATION_MASTER_RAW",
								"type": "DatasetReference"
							},
							"name": "LocationMasterRaw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHierarchyDetail"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "WriteToLocationsTable",
							"rejectedDataLinkedService": {
								"referenceName": "datalakelinkedservice",
								"type": "LinkedServiceReference"
							}
						},
						{
							"dataset": {
								"referenceName": "FAILED_LOCATION_MASTER_ROWS_SFTP",
								"type": "DatasetReference"
							},
							"name": "failedrowslocationmaster"
						}
					],
					"transformations": [
						{
							"name": "THDBUSelected"
						},
						{
							"name": "JoinTenantHeirarchyDetail"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterBUrecords"
						},
						{
							"name": "AddDefaultedColumns",
							"description": "Add Location Type - always 1"
						},
						{
							"name": "ValidateData"
						},
						{
							"name": "Pass",
							"description": "If there are no validation errors, pass. Otherwise fail."
						},
						{
							"name": "DeriveErrorsAndFileName",
							"description": "Convert Assertions In Columns"
						},
						{
							"name": "RenameColumnsForValidation"
						},
						{
							"name": "FilterOrgRecords"
						},
						{
							"name": "THDOrgSelected"
						},
						{
							"name": "JoinBUWithOrg"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('Radial/LocationMaster/data_107e2644-2ce0-4274-abb8-2ad1ea4d944d_d6b001c9-e396-41a1-ad43-b5f3d1aebeae.csv')",
						"}",
						"source(output(",
						"          {Organization ID} as string,",
						"          {Business ID} as string,",
						"          {Location Code} as short,",
						"          Name as string,",
						"          Address as string,",
						"          City as string,",
						"          State as string,",
						"          Zip as string,",
						"          Country as string,",
						"          Latitude as double,",
						"          Longitude as double,",
						"          {Location Status} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     wildcardPaths:[($file_path)],",
						"     mode: 'read') ~> LocationMasterRaw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHierarchyDetail",
						"FilterBUrecords select(mapColumn(",
						"          THD_BU_id = id,",
						"          THD_BU_parent_id = parent_id,",
						"          THD_BU_tenant_hierarchy_code = tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> THDBUSelected",
						"LocationMasterRaw, JoinBUWithOrg join({Business ID} == THD_BU_tenant_hierarchy_code",
						"     && {Organization ID} == THD_Org_tenant_hierarchy_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTenantHeirarchyDetail",
						"AddDefaultedColumns alterRow(upsertIf(true())) ~> AlterRow1",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type==3) ~> FilterBUrecords",
						"Pass@Pass derive(Location_Type = 1) ~> AddDefaultedColumns",
						"RenameColumnsForValidation assert(expectTrue(! isNull(Organization_ID), false, 'OrgIDNull', null, \"Organization ID is NULL\"),",
						"     expectTrue(! isNull(Business_ID), false, 'BusIDNull', null, \"Business ID is NULL\"),",
						"     expectTrue(! isNull(Location_Code), false, 'LocCodeNull', null, \"Location Code is NULL\"),",
						"     expectTrue(! isNull(Name), false, 'NameNull', null, \"Name Is NULL\"),",
						"     expectTrue(! isNull(Address), false, 'AddressIsNull', null, \"Address Is NULL\"),",
						"     expectTrue(! isNull(City), false, 'CityIsNull', null, \"City Is NULL\"),",
						"     expectTrue(! isNull(State), false, 'StateIsNull', null, \"State is NULL\"),",
						"     expectTrue(! isNull(Zip), false, 'ZipIsNull', null, \"Zip is NULL\"),",
						"     expectTrue(! isNull(Country), false, 'CountryIsNull', null, \"Country Is NULL\"),",
						"     expectTrue(! ( Longitude < -180 ) || (Longitude > 180), false, 'LongitudeInvalid', null, \"Longitude Is Invalid\"),",
						"     expectTrue(! ( Latitude < -180 ) || ( Latitude > 180 ), false, 'LatitudeInvalid', null, \"Latitude Is Invalid\"),",
						"     expectTrue(! isNull(THD_Org_id), false, 'OrgIDInvalid', null, \"Organization ID Is Invalid\"),",
						"     expectTrue(! isNull(THD_BU_id), false, 'BUInvalid', null, \"Business Unit Is Invalid\")) ~> ValidateData",
						"DeriveErrorsAndFileName split(isNull(validation_errors),",
						"     disjoint: false) ~> Pass@(Pass, Fail)",
						"ValidateData derive(validation_errors = assertErrorMessages(),",
						"          file_name = $file_path,",
						"          failed_filename = replace($file_path,'Radial','faileduploads')) ~> DeriveErrorsAndFileName",
						"JoinTenantHeirarchyDetail select(mapColumn(",
						"          Organization_ID = {Organization ID},",
						"          Business_ID = {Business ID},",
						"          Location_Code = {Location Code},",
						"          Name,",
						"          Address,",
						"          City,",
						"          State,",
						"          Zip,",
						"          Country,",
						"          Latitude,",
						"          Longitude,",
						"          Location_Status = {Location Status},",
						"          THD_BU_id,",
						"          THD_BU_parent_id,",
						"          THD_BU_tenant_hierarchy_code,",
						"          THD_Org_id,",
						"          THD_Org_tenant_id,",
						"          THD_Org_tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RenameColumnsForValidation",
						"TenantHierarchyDetail filter(tenant_hierarchy_type == 2) ~> FilterOrgRecords",
						"FilterOrgRecords select(mapColumn(",
						"          THD_Org_id = id,",
						"          THD_Org_tenant_id = tenant_id,",
						"          THD_Org_tenant_hierarchy_code = tenant_hierarchy_code,",
						"          THD_Org_tenant_id = tenant_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> THDOrgSelected",
						"THDBUSelected, THDOrgSelected join(THD_BU_parent_id == THD_Org_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinBUWithOrg",
						"AlterRow1 sink(allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     input(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['location_code'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          location_code = Location_Code,",
						"          address = Address,",
						"          name = Name,",
						"          zip = Zip,",
						"          tenant_id = THD_Org_tenant_id,",
						"          organization_id = THD_Org_id,",
						"          business_unit_id = THD_BU_id,",
						"          status = Location_Status,",
						"          type = Location_Type,",
						"          latitude = Latitude,",
						"          longitude = Longitude,",
						"          city = City,",
						"          state = State,",
						"          zip = Zip",
						"     )) ~> WriteToLocationsTable",
						"Pass@Fail sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_filename',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> failedrowslocationmaster"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/LOCATION_MASTER_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/linkedServices/datalakelinkedservice')]",
				"[concat(variables('factoryId'), '/datasets/FAILED_LOCATION_MASTER_ROWS_SFTP')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_locations_ux')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "IMPORT_MANAGER_MERGED"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "FetchingLocations"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importHistory"
						},
						{
							"dataset": {
								"referenceName": "LOCATION_UX_STAGING",
								"type": "DatasetReference"
							},
							"name": "ExcelSource"
						},
						{
							"dataset": {
								"referenceName": "location_type",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "fetchingtenentdetails"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "loadlocationsdatadb"
						},
						{
							"dataset": {
								"referenceName": "FailedRowsLocation",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "FilteringHistory"
						},
						{
							"name": "selectingImportHistory"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "selectLocations"
						},
						{
							"name": "AddingRecordID"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "join2"
						},
						{
							"name": "select2"
						},
						{
							"name": "assert1"
						},
						{
							"name": "storingErrorRecords"
						},
						{
							"name": "joiningwithErrors"
						},
						{
							"name": "select3"
						},
						{
							"name": "aggregateErrors"
						},
						{
							"name": "split1"
						},
						{
							"name": "selectingFailedRows"
						},
						{
							"name": "duplicateddata"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "window1"
						},
						{
							"name": "SelectingUniqueLocations"
						},
						{
							"name": "selectinglocationtypes"
						},
						{
							"name": "filter1"
						},
						{
							"name": "join4"
						},
						{
							"name": "mergingtenantdetails"
						},
						{
							"name": "changingcolumntypes"
						},
						{
							"name": "join5"
						}
					],
					"scriptLines": [
						"parameters{",
						"     transaction_id as string ('192'),",
						"     file_path as string ('/DEV/Upload/Location/192.xlsx')",
						"}",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> FetchingLocations",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importHistory",
						"source(output(",
						"          {Location ID*} as string,",
						"          {Location Name} as string,",
						"          Address as string,",
						"          City as string,",
						"          State as string,",
						"          Zip as string,",
						"          Country as string,",
						"          Longitude as string,",
						"          Latitude as string,",
						"          {Location Status} as string,",
						"          {Location Type} as string,",
						"          {Daily Throughput} as string,",
						"          {Storage Capacity} as string,",
						"          {Inbound Handling Cost} as string,",
						"          {Outbound Handling Cost} as string,",
						"          {Inbound Processing Time} as string,",
						"          {Outbound Processing Time} as string,",
						"          {Transfer Inbound Processing Time} as string,",
						"          {Transfer Outbound Processing Time} as string,",
						"          {Transfer Inbound Handling Cost} as string,",
						"          {Transfer Outbound Handling Cost} as string,",
						"          {Units per Hour} as string,",
						"          {Max FTE Regular Hours} as string,",
						"          {Min FTE Regular Hours} as string,",
						"          {Max Temp Regular Hours} as string,",
						"          {Min Temp Regular Hours} as string,",
						"          {Max FTE Overtime Hours} as string,",
						"          {Regular FTE Wage} as string,",
						"          {Regular Temp Wage} as string,",
						"          {Overtime FTE Wage} as string,",
						"          {Overtime Temp Wage} as string,",
						"          {FTE Staff Count} as string,",
						"          {Temp Staff Count} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'filename',",
						"     wildcardPaths:[($file_path)]) ~> ExcelSource",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          description as string,",
						"          created_date as date,",
						"          updated_date as date,",
						"          display_icon as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fetchingtenentdetails",
						"join4 filter(importHistory@id == toInteger($transaction_id)) ~> FilteringHistory",
						"FilteringHistory select(mapColumn(",
						"          import_id = importHistory@id,",
						"          business_unit_id,",
						"          organization_id,",
						"          tenant_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectingImportHistory",
						"FetchingLocations derive(presence = 'true') ~> derivedColumn1",
						"derivedColumn1 select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          presence,",
						"          name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectLocations",
						"ExcelSource keyGenerate(output(record_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> AddingRecordID",
						"AddingRecordID derive(numericalintegrity = iif(isNull({Daily Throughput}),true(),not(isNull(toFloat({Daily Throughput})))) && iif(isNull({Storage Capacity}),true(),not(isNull(toFloat({Storage Capacity})))) && iif(isNull({Inbound Handling Cost}),true(),not(isNull(toFloat({Inbound Handling Cost})))) && iif(isNull({Outbound Handling Cost}),true(),not(isNull(toFloat({Outbound Handling Cost})))) && iif(isNull({Transfer Inbound Handling Cost}),true(),not(isNull(toFloat({Transfer Inbound Handling Cost})))) && iif(isNull({Transfer Outbound Handling Cost}),true(),not(isNull(toFloat({Transfer Outbound Handling Cost})))) && iif(isNull({Units per Hour}),true(),not(isNull(toFloat({Units per Hour})))) && iif(isNull({Min FTE Regular Hours}),true(),not(isNull(toFloat({Min FTE Regular Hours})))) && iif(isNull({Max FTE Regular Hours}),true(),not(isNull(toFloat({Max FTE Regular Hours})))) && iif(isNull({Min Temp Regular Hours}),true(),not(isNull(toFloat({Min Temp Regular Hours})))) && iif(isNull({Max Temp Regular Hours}),true(),not(isNull(toFloat({Max Temp Regular Hours})))) && iif(isNull({Max FTE Overtime Hours}),true(),not(isNull(toFloat({Max FTE Overtime Hours})))) && iif(isNull({Regular FTE Wage}),true(),not(isNull(toFloat({Regular FTE Wage})))) && iif(isNull({Regular Temp Wage}),true(),not(isNull(toFloat({Regular Temp Wage})))) && iif(isNull({Overtime FTE Wage}),true(),not(isNull(toFloat({Overtime FTE Wage})))) && iif(isNull({Overtime Temp Wage}),true(),not(isNull(toFloat({Overtime Temp Wage})))) && iif(isNull({FTE Staff Count}),true(),not(isNull(toFloat({FTE Staff Count})))) && iif(isNull({Temp Staff Count}),true(),not(isNull(toFloat({Temp Staff Count})))),",
						"          transaction_id = toInteger($transaction_id)) ~> derivedColumn2",
						"duplicateddata, SelectingUniqueLocations join({Location ID*} == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join5 select(mapColumn(",
						"          Location_Code_SC = {Location ID*},",
						"          Location_Name_SC = {Location Name},",
						"          Address_SC = Address,",
						"          City_SC = City,",
						"          State_SC = State,",
						"          Zip_SC = Zip,",
						"          Country_SC = Country,",
						"          Longitude_SC = Longitude,",
						"          Latitude_SC = Latitude,",
						"          Location_Status_SC = {Location Status},",
						"          Location_Type_SC = {Location Type},",
						"          Daily_Throughput_SC = {Daily Throughput},",
						"          Storage_Capacity_SC = {Storage Capacity},",
						"          Inbound_Handling_Cost_SC = {Inbound Handling Cost},",
						"          Outbound_Handling_Cost_SC = {Outbound Handling Cost},",
						"          Inbound_Processing_Time_SC = {Inbound Processing Time},",
						"          Outbound_Processing_Time_SC = {Outbound Processing Time},",
						"          Transfer_Inbound_Processing_Time_SC = {Transfer Inbound Processing Time},",
						"          Transfer_Outbound_Processing_Time_SC = {Transfer Outbound Processing Time},",
						"          Transfer_Inbound_Handling_Cost_SC = {Transfer Inbound Handling Cost},",
						"          Transfer_Outbound_Handling_Cost_SC = {Transfer Outbound Handling Cost},",
						"          Units_per_Hour_SC = {Units per Hour},",
						"          Max_FTE_Regular_Hours_SC = {Max FTE Regular Hours},",
						"          Min_FTE_Regular_Hours_SC = {Min FTE Regular Hours},",
						"          Max_Temp_Regular_Hours_SC = {Max Temp Regular Hours},",
						"          Min_Temp_Regular_Hours_SC = {Min Temp Regular Hours},",
						"          Max_FTE_Overtime_Hours_SC = {Max FTE Overtime Hours},",
						"          Regular_FTE_Wage_SC = {Regular FTE Wage},",
						"          Regular_Temp_Wage_SC = {Regular Temp Wage},",
						"          Overtime_FTE_Wage_SC = {Overtime FTE Wage},",
						"          Overtime_Temp_Wage_SC = {Overtime Temp Wage},",
						"          FTE_Staff_Count_SC = {FTE Staff Count},",
						"          Temp_Staff_Count_SC = {Temp Staff Count},",
						"          record_id,",
						"          nonduplicate,",
						"          numericalintegrity,",
						"          location_id,",
						"          presence,",
						"          filename,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          location_type_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"filter1, selectLocations, selectinglocationtypes assert(expectTrue(isNull(select2@presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
						"     expectExists(Location_Type_SC == location_type_name, false, 'checklocationtype', null, 'Location Type Not Found'),",
						"     expectTrue(numericalintegrity, false, 'numericalintegrity', null, 'Numerical fields contain non numeric values'),",
						"     expectTrue(nonduplicate, false, 'nonduplicate', null, 'Duplicate Values Not Found')) ~> assert1",
						"assert1 derive(transaction_id = $transaction_id,",
						"          validation_errors = assertErrorMessages(),",
						"          failed_file_name = replace(replace($file_path,'.xlsx','.json'),'/Upload','/FailedTransactions')) ~> storingErrorRecords",
						"storingErrorRecords, aggregateErrors join(select2@filename == aggregateErrors@filename,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joiningwithErrors",
						"storingErrorRecords select(mapColumn(",
						"          validation_errors,",
						"          filename",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select3 aggregate(groupBy(filename),",
						"     error_count = countIf(not(isNull(validation_errors)))) ~> aggregateErrors",
						"joiningwithErrors split(error_count==0,",
						"     disjoint: false) ~> split1@(validrows, invalidrows)",
						"split1@invalidrows select(mapColumn(",
						"          filename = split1@invalidrows@filename,",
						"          validation_errors,",
						"          failed_file_name,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectingFailedRows",
						"derivedColumn2 window(over({Location ID*}),",
						"     asc(record_id, true),",
						"     nonduplicate = rowNumber() == 1) ~> duplicateddata",
						"selectingFailedRows derive(failed_file_name = replace(replace($file_path,'.xlsx','.json'),'/Upload','/FailedTransactions'),",
						"          type = 'error',",
						"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedColumn3",
						"selectLocations window(over(location_code),",
						"     asc(location_id, true),",
						"     duplicate_data = rowNumber() == 1) ~> window1",
						"window1 filter(duplicate_data == true()) ~> SelectingUniqueLocations",
						"source1 select(mapColumn(",
						"          location_type_id = id,",
						"          location_type_name = name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectinglocationtypes",
						"select2 filter(not(isNull(Location_Code_SC)) || ",
						"not(isNull(Location_Name_SC)) || ",
						"not(isNull(Address_SC)) || ",
						"not(isNull(City_SC)) || ",
						"not(isNull(State_SC)) || ",
						"not(isNull(Zip_SC)) || ",
						"not(isNull(Longitude_SC)) || ",
						"not(isNull(Latitude_SC)) || ",
						"not(isNull(Location_Status_SC)) || ",
						"not(isNull(Location_Type_SC)) || ",
						"not(isNull(Daily_Throughput_SC)) || ",
						"not(isNull(Storage_Capacity_SC)) || ",
						"not(isNull(Inbound_Handling_Cost_SC)) || ",
						"not(isNull(Outbound_Handling_Cost_SC)) || ",
						"not(isNull(Inbound_Processing_Time_SC)) || ",
						"not(isNull(Outbound_Processing_Time_SC)) || ",
						"not(isNull(Transfer_Inbound_Processing_Time_SC)) || ",
						"not(isNull(Transfer_Outbound_Processing_Time_SC)) || ",
						"not(isNull(Transfer_Inbound_Handling_Cost_SC)) || ",
						"not(isNull(Units_per_Hour_SC)) || ",
						"not(isNull(Max_FTE_Regular_Hours_SC)) || ",
						"not(isNull(Min_FTE_Regular_Hours_SC)) || ",
						"not(isNull(Max_Temp_Regular_Hours_SC)) || ",
						"not(isNull(Min_Temp_Regular_Hours_SC)) || ",
						"not(isNull(Max_FTE_Overtime_Hours_SC)) || ",
						"not(isNull(Regular_FTE_Wage_SC)) || ",
						"not(isNull(Regular_Temp_Wage_SC)) || ",
						"not(isNull(Overtime_FTE_Wage_SC)) || ",
						"not(isNull(Overtime_Temp_Wage_SC)) || ",
						"not(isNull(FTE_Staff_Count_SC)) || ",
						"not(isNull(Temp_Staff_Count_SC))) ~> filter1",
						"importHistory, fetchingtenentdetails join(business_unit_id == fetchingtenentdetails@id",
						"     && organization_id == parent_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join4",
						"join2, selectingImportHistory join(transaction_id == import_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> mergingtenantdetails",
						"split1@validrows derive(latitude = coalesce(toInteger(Latitude_SC), 0),",
						"          longitude = coalesce(toInteger(Longitude_SC), 0),",
						"          Daily_Throughput_SC = toFloat(Daily_Throughput_SC),",
						"          Storage_Capacity_SC = toFloat(Storage_Capacity_SC),",
						"          Inbound_Handling_Cost_SC = toFloat(Inbound_Handling_Cost_SC),",
						"          Outbound_Handling_Cost_SC = toFloat(Outbound_Handling_Cost_SC),",
						"          Inbound_Processing_Time_SC = toDouble(Inbound_Processing_Time_SC),",
						"          Outbound_Processing_Time_SC = toDouble(Outbound_Processing_Time_SC),",
						"          Transfer_Inbound_Processing_Time_SC = toDouble(Transfer_Inbound_Processing_Time_SC),",
						"          Transfer_Outbound_Processing_Time_SC = toDouble(Transfer_Outbound_Processing_Time_SC),",
						"          Transfer_Inbound_Handling_Cost_SC = toDouble(Transfer_Inbound_Handling_Cost_SC),",
						"          Transfer_Outbound_Handling_Cost_SC = toDouble(Transfer_Outbound_Handling_Cost_SC),",
						"          Units_per_Hour_SC = toFloat(Units_per_Hour_SC),",
						"          Max_FTE_Regular_Hours_SC = toFloat(Max_FTE_Regular_Hours_SC),",
						"          Min_FTE_Regular_Hours_SC = toFloat(Min_FTE_Regular_Hours_SC),",
						"          Max_Temp_Regular_Hours_SC = toFloat(Max_Temp_Regular_Hours_SC),",
						"          Min_Temp_Regular_Hours_SC = toFloat(Min_Temp_Regular_Hours_SC),",
						"          Max_FTE_Overtime_Hours_SC = toFloat(Max_FTE_Overtime_Hours_SC),",
						"          Regular_FTE_Wage_SC = toFloat(Regular_FTE_Wage_SC),",
						"          Regular_Temp_Wage_SC = toFloat(Regular_Temp_Wage_SC),",
						"          Overtime_FTE_Wage_SC = toFloat(Overtime_FTE_Wage_SC),",
						"          FTE_Staff_Count_SC = toFloat(FTE_Staff_Count_SC),",
						"          Overtime_Temp_Wage_SC = toFloat(Overtime_Temp_Wage_SC),",
						"          Temp_Staff_Count_SC = toFloat(Temp_Staff_Count_SC)) ~> changingcolumntypes",
						"mergingtenantdetails, selectinglocationtypes join({Location Type} == location_type_name,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join5",
						"changingcolumntypes sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          location_code = Location_Code_SC,",
						"          name = Location_Name_SC,",
						"          address = Address_SC,",
						"          city = City_SC,",
						"          state = State_SC,",
						"          zip = Zip_SC,",
						"          country = Country_SC,",
						"          throughput = Daily_Throughput_SC,",
						"          capacity = Storage_Capacity_SC,",
						"          inbound_handling_cost = Inbound_Handling_Cost_SC,",
						"          outbound_handling_cost = Outbound_Handling_Cost_SC,",
						"          longitude,",
						"          latitude,",
						"          status = Location_Status_SC,",
						"          inbound_processing_time = Inbound_Processing_Time_SC,",
						"          outbound_processing_time = Outbound_Processing_Time_SC,",
						"          type = split1@validrows@location_type_id,",
						"          transfer_inbound_processing_time = Transfer_Inbound_Processing_Time_SC,",
						"          transfer_outbound_processing_time = Transfer_Outbound_Processing_Time_SC,",
						"          transfer_inbound_handling_cost = Transfer_Inbound_Handling_Cost_SC,",
						"          transfer_outbound_handling_cost = Transfer_Outbound_Handling_Cost_SC,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          units_per_hour = Units_per_Hour_SC,",
						"          max_fte_regular_hours = Max_FTE_Regular_Hours_SC,",
						"          min_fte_regular_hours = Min_FTE_Regular_Hours_SC,",
						"          max_temp_regular_hours = Max_Temp_Regular_Hours_SC,",
						"          min_temp_regular_hours = Min_Temp_Regular_Hours_SC,",
						"          max_fte_overtime_hours = Max_FTE_Overtime_Hours_SC,",
						"          regular_fte_wage = Regular_FTE_Wage_SC,",
						"          regular_temp_wage = Regular_Temp_Wage_SC,",
						"          overtime_fte_wage = Overtime_FTE_Wage_SC,",
						"          overtime_temp_wage = Overtime_Temp_Wage_SC,",
						"          fte_staff_count = FTE_Staff_Count_SC,",
						"          temp_staff_count = Temp_Staff_Count_SC",
						"     )) ~> loadlocationsdatadb",
						"derivedColumn3 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/LOCATION_UX_STAGING')]",
				"[concat(variables('factoryId'), '/datasets/location_type')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/FailedRowsLocation')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_order_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ORDER_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "orderhistoryraw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "order_history",
								"type": "DatasetReference"
							},
							"name": "OrderHistory"
						}
					],
					"transformations": [
						{
							"name": "AggregationOrderLevel"
						},
						{
							"name": "SelectColumns"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "filterbusinessunits"
						},
						{
							"name": "JoinTHTD"
						},
						{
							"name": "RenameColumns"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "devfilter"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Order ID} as string,",
						"          {Order Line ID} as string,",
						"          {Location ID} as string,",
						"          Channel as string,",
						"          {Order Date} as timestamp,",
						"          {Order Original Ship Date} as timestamp,",
						"          {Order Actual Ship Date} as timestamp,",
						"          {Order Due Date} as timestamp,",
						"          {Order Received Date and Time} as timestamp,",
						"          {Order Completed Date and Time} as timestamp,",
						"          {Destination Zip Code} as string,",
						"          {Item Code} as string,",
						"          {Order Quantity} as float,",
						"          {Quantity (UOM) Picked} as string,",
						"          {Order Status} as string,",
						"          Carrier as string,",
						"          {Service Type} as string,",
						"          {Shipment Fees} as float,",
						"          {Order Value} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> orderhistoryraw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"SelectColumns aggregate(groupBy({Order ID},",
						"          Channel,",
						"          {Order Date},",
						"          {Order Due Date},",
						"          {Destination Zip Code},",
						"          {Order Status},",
						"          {Order Actual Ship Date},",
						"          Carrier,",
						"          {Service Type},",
						"          {Location ID},",
						"          business_unit_id,",
						"          organization_id,",
						"          import_date),",
						"     {Shipment Fees} = toFloat(sum({Shipment Fees})),",
						"          {Order Quantity} = toFloat(sum({Order Quantity})),",
						"          {Order Value} = toDecimal(sum({Order Value}), 10, 2)) ~> AggregationOrderLevel",
						"JoinTHTD select(mapColumn(",
						"          {Order ID},",
						"          Channel,",
						"          {Order Date},",
						"          {Order Due Date},",
						"          {Destination Zip Code},",
						"          {Order Actual Ship Date},",
						"          {Order Status},",
						"          Carrier,",
						"          {Service Type},",
						"          {Order Quantity},",
						"          {Shipment Fees},",
						"          {Order Value},",
						"          business_unit_id,",
						"          organization_id,",
						"          import_date,",
						"          {Location ID}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumns",
						"orderhistoryraw derive(business_unit_name = split(split(file_name,'/')[4],'_')[2],",
						"          import_date = currentUTC(\"UTC\")) ~> derivedColumn1",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type==3) ~> filterbusinessunits",
						"derivedColumn1, RenameColumns join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHTD",
						"filterbusinessunits select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RenameColumns",
						"devfilter alterRow(upsertIf(true())) ~> AlterRow1",
						"AggregationOrderLevel derive({Order Value} = round({Order Value},2)) ~> derivedColumn2",
						"derivedColumn2 filter(true()) ~> devfilter",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          order_code as string,",
						"          channel as string,",
						"          order_date as timestamp,",
						"          must_ship_by_date as timestamp,",
						"          must_deliver_by_date as timestamp,",
						"          destination_city as string,",
						"          destination_state as string,",
						"          destination_postal_code as string,",
						"          destination_country as string,",
						"          status as string,",
						"          delivery_partner_name as string,",
						"          service_level_name as string,",
						"          fulfillment_service as string,",
						"          total_units as float,",
						"          total_shipping_charge as float,",
						"          total_order_value as float,",
						"          import_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['order_code'],",
						"     format: 'table',",
						"     batchSize: 9530131,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          order_code = {Order ID},",
						"          channel = Channel,",
						"          order_date = {Order Date},",
						"          must_ship_by_date = {Order Actual Ship Date},",
						"          must_deliver_by_date = {Order Due Date},",
						"          destination_postal_code = {Destination Zip Code},",
						"          status = {Order Status},",
						"          delivery_partner_name = Carrier,",
						"          service_level_name = {Service Type},",
						"          total_units = {Order Quantity},",
						"          total_shipping_charge = {Shipment Fees},",
						"          total_order_value = {Order Value},",
						"          organization_id,",
						"          business_unit_id,",
						"          import_date,",
						"          location_code = {Location ID}",
						"     )) ~> OrderHistory"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ORDER_HISTORY_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/order_history')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_order_line_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ORDER_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "orderhistoryraw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "order_history",
								"type": "DatasetReference"
							},
							"name": "OrderHistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "order_line_history",
								"type": "DatasetReference"
							},
							"name": "OrderLineHistory"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "filterbusinessunits"
						},
						{
							"name": "JoinTHTD"
						},
						{
							"name": "RenameColumns"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "SelectOrderHistory"
						},
						{
							"name": "JoinOrderHistory"
						},
						{
							"name": "deriveSpecial"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Order ID} as string,",
						"          {Order Line ID} as string,",
						"          Channel as string,",
						"          {Order Date} as timestamp,",
						"          {Order Original Ship Date} as timestamp,",
						"          {Order Actual Ship Date} as timestamp,",
						"          {Order Due Date} as timestamp,",
						"          {Order Received Date And Time} as timestamp,",
						"          {Order Completed Date and Time} as timestamp,",
						"          {Destination Zip Code} as string,",
						"          {Item Code} as string,",
						"          {Order Quantity} as float,",
						"          {Quantity (UOM) Picked} as string,",
						"          {Order Status} as string,",
						"          Carrier as string,",
						"          {Service Type} as string,",
						"          {Shipment Fees} as float,",
						"          {Order Value} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> orderhistoryraw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"source(output(",
						"          id as integer,",
						"          order_code as string,",
						"          channel as string,",
						"          order_date as timestamp,",
						"          must_ship_by_date as timestamp,",
						"          must_deliver_by_date as timestamp,",
						"          destination_city as string,",
						"          destination_state as string,",
						"          destination_postal_code as string,",
						"          destination_country as string,",
						"          status as string,",
						"          delivery_partner_name as string,",
						"          service_level_name as string,",
						"          fulfillment_service as string,",
						"          total_units as float,",
						"          total_shipping_charge as float,",
						"          total_order_value as float,",
						"          import_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> OrderHistory",
						"orderhistoryraw derive(business_unit_name = split(split(file_name,'/')[4],'_')[2],",
						"          {Ship Quantity} = {Order Quantity}) ~> derivedColumn1",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type==3) ~> filterbusinessunits",
						"derivedColumn1, RenameColumns join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHTD",
						"filterbusinessunits select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RenameColumns",
						"filter1 alterRow(upsertIf(true())) ~> AlterRow1",
						"deriveSpecial filter(not(isNull({Order Value}))) ~> filter1",
						"OrderHistory select(mapColumn(",
						"          order_id = id,",
						"          order_code,",
						"          item_value = total_order_value,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectOrderHistory",
						"JoinTHTD, SelectOrderHistory join({Order ID} == order_code",
						"     && RenameColumns@business_unit_id == SelectOrderHistory@business_unit_id",
						"     && RenameColumns@organization_id == SelectOrderHistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOrderHistory",
						"JoinOrderHistory derive(item_price = round(item_value*.2,2)) ~> deriveSpecial",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          order_id as integer,",
						"          order_line_code as string,",
						"          item_code as string,",
						"          item_name as string,",
						"          item_description as string,",
						"          order_quantity as float,",
						"          ship_quantity as float,",
						"          line_status as string,",
						"          item_price as float,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['order_id','order_line_code'],",
						"     format: 'table',",
						"     batchSize: 57459551,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          order_id,",
						"          order_line_code = {Order Line ID},",
						"          item_code = {Item Code},",
						"          order_quantity = {Order Quantity},",
						"          line_status = {Order Status},",
						"          item_price,",
						"          business_unit_id,",
						"          organization_id,",
						"          ship_quantity = {Ship Quantity}",
						"     )) ~> OrderLineHistory"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ORDER_HISTORY_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/order_history')]",
				"[concat(variables('factoryId'), '/datasets/order_line_history')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_order_status_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ORDER_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "orderhistoryraw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "order_history",
								"type": "DatasetReference"
							},
							"name": "OrderHistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "order_status_history",
								"type": "DatasetReference"
							},
							"name": "OrderStatusHistory"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "filterbusinessunits"
						},
						{
							"name": "JoinTHTD"
						},
						{
							"name": "RenameColumns"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "SelectOrderHistory"
						},
						{
							"name": "JoinOrderHistory"
						},
						{
							"name": "unpivot1"
						},
						{
							"name": "SelectFields"
						},
						{
							"name": "RemoveDuplicates"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Order ID} as string,",
						"          {Order Line ID} as string,",
						"          Channel as string,",
						"          {Order Date} as timestamp,",
						"          {Order Original Ship Date} as timestamp,",
						"          {Order Actual Ship Date} as timestamp,",
						"          {Order Due Date} as timestamp,",
						"          {Order Received Date And Time} as timestamp,",
						"          {Order Completed Date and Time} as timestamp,",
						"          {Destination Zip Code} as string,",
						"          {Item Code} as string,",
						"          {Order Quantity} as float,",
						"          {Quantity (UOM) Picked} as string,",
						"          {Order Status} as string,",
						"          Carrier as string,",
						"          {Service Type} as string,",
						"          {Shipment Fees} as float,",
						"          {Order Value} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> orderhistoryraw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"source(output(",
						"          id as integer,",
						"          order_code as string,",
						"          channel as string,",
						"          order_date as timestamp,",
						"          must_ship_by_date as timestamp,",
						"          must_deliver_by_date as timestamp,",
						"          destination_city as string,",
						"          destination_state as string,",
						"          destination_postal_code as string,",
						"          destination_country as string,",
						"          status as string,",
						"          delivery_partner_name as string,",
						"          service_level_name as string,",
						"          fulfillment_service as string,",
						"          total_units as float,",
						"          total_shipping_charge as float,",
						"          total_order_value as float,",
						"          import_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> OrderHistory",
						"unpivot1 derive(business_unit_name = split(split(file_name,'/')[4],'_')[2],",
						"          status = iif(\r",
						"    status_grp=='Order Actual Ship Date',\r",
						"    'Shipped',\r",
						"    iif(\r",
						"        status_grp=='Order Received Date And Time',\r",
						"        'Order Received (in Warehouse) Date and time',\r",
						"        iif(\r",
						"            status_grp=='Order Completed Date and Time',\r",
						"            'Order Completed (in Warehouse) Date and Time',\r",
						"            status_grp\r",
						"        )\r",
						"    )\r",
						"),",
						"          status_date = {Order Actual Ship Date}) ~> derivedColumn1",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type==3) ~> filterbusinessunits",
						"derivedColumn1, RenameColumns join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHTD",
						"filterbusinessunits select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RenameColumns",
						"JoinOrderHistory alterRow(upsertIf(true())) ~> AlterRow1",
						"OrderHistory select(mapColumn(",
						"          order_id = id,",
						"          order_code,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectOrderHistory",
						"JoinTHTD, SelectOrderHistory join({Order ID} == order_code",
						"     && RenameColumns@business_unit_id == SelectOrderHistory@business_unit_id",
						"     && RenameColumns@organization_id == SelectOrderHistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOrderHistory",
						"SelectFields unpivot(output(",
						"          status_grp as string,",
						"          {Order Actual Ship Date} as timestamp,",
						"          {Order Received Date And Time} as timestamp,",
						"          {Order Completed Date and Time} as timestamp",
						"     ),",
						"     ungroupBy({Order ID},",
						"          file_name),",
						"     lateral: true,",
						"     ignoreNullPivots: false) ~> unpivot1",
						"RemoveDuplicates select(mapColumn(",
						"          {Order ID},",
						"          {Order Actual Ship Date},",
						"          {Order Received Date And Time},",
						"          {Order Completed Date and Time},",
						"          file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectFields",
						"orderhistoryraw aggregate(groupBy({Order ID},",
						"          {Order Actual Ship Date},",
						"          {Order Received Date And Time},",
						"          {Order Completed Date and Time},",
						"          file_name),",
						"     {Order Line ID} = countDistinct({Order Line ID})) ~> RemoveDuplicates",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          order_id as integer,",
						"          status as string,",
						"          status_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['order_id','status'],",
						"     format: 'table',",
						"     batchSize: 36396960,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          order_id,",
						"          status,",
						"          status_date,",
						"          business_unit_id = SelectOrderHistory@business_unit_id,",
						"          organization_id = RenameColumns@organization_id",
						"     )) ~> OrderStatusHistory"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ORDER_HISTORY_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/order_history')]",
				"[concat(variables('factoryId'), '/datasets/order_status_history')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_shipment_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SHIPMENT_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "shipmenthistoryraw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchydetail"
						},
						{
							"dataset": {
								"referenceName": "order_line_history",
								"type": "DatasetReference"
							},
							"name": "orderlinetable"
						},
						{
							"dataset": {
								"referenceName": "order_history",
								"type": "DatasetReference"
							},
							"name": "orderhistory"
						},
						{
							"dataset": {
								"referenceName": "order_status_history",
								"type": "DatasetReference"
							},
							"name": "orderstatushistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "shipment_history",
								"type": "DatasetReference"
							},
							"name": "ShipmentHistory"
						}
					],
					"transformations": [
						{
							"name": "derivebusinessunitname"
						},
						{
							"name": "selectthtd"
						},
						{
							"name": "filter1"
						},
						{
							"name": "JoinTHTD"
						},
						{
							"name": "selectorderline"
						},
						{
							"name": "selectorderhistory"
						},
						{
							"name": "JoinOrderLine"
						},
						{
							"name": "JoinOrderHistory"
						},
						{
							"name": "filtershipmentstatus"
						},
						{
							"name": "JoinOrderShipmentStatusHistory"
						},
						{
							"name": "selectshipmentstatus"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterNotNullRows"
						},
						{
							"name": "RemoveDuplicates"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Shipment ID} as string,",
						"          {Order Line ID} as string,",
						"          {Location ID} as string,",
						"          {Carrier Name} as string,",
						"          Mode as string,",
						"          {Total Units} as float,",
						"          {Total Shipment Weight} as float,",
						"          {Total Shipment Volume} as float,",
						"          {Total Shipment Cost} as float,",
						"          {Total Shipment Value} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> shipmenthistoryraw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchydetail",
						"source(output(",
						"          order_id as integer,",
						"          order_line_code as string,",
						"          item_code as string,",
						"          item_name as string,",
						"          item_description as string,",
						"          order_quantity as float,",
						"          ship_quantity as float,",
						"          line_status as string,",
						"          item_price as float,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> orderlinetable",
						"source(output(",
						"          id as integer,",
						"          order_code as string,",
						"          channel as string,",
						"          order_date as timestamp,",
						"          must_ship_by_date as timestamp,",
						"          must_deliver_by_date as timestamp,",
						"          destination_city as string,",
						"          destination_state as string,",
						"          destination_postal_code as string,",
						"          destination_country as string,",
						"          status as string,",
						"          delivery_partner_name as string,",
						"          service_level_name as string,",
						"          fulfillment_service as string,",
						"          total_units as float,",
						"          total_shipping_charge as float,",
						"          total_order_value as float,",
						"          import_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> orderhistory",
						"source(output(",
						"          order_id as integer,",
						"          status as string,",
						"          status_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> orderstatushistory",
						"shipmenthistoryraw derive(business_unit_name = split(split(file_name,'/')[4],\"_\")[2]) ~> derivebusinessunitname",
						"filter1 select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectthtd",
						"tenantheirarchydetail filter(tenant_hierarchy_type==3) ~> filter1",
						"derivebusinessunitname, selectthtd join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHTD",
						"orderlinetable select(mapColumn(",
						"          order_id,",
						"          order_line_code,",
						"          line_status,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectorderline",
						"orderhistory select(mapColumn(",
						"          order_id = id,",
						"          order_code,",
						"          order_date,",
						"          service_level_name,",
						"          must_deliver_by_date,",
						"          status,",
						"          import_date,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectorderhistory",
						"JoinTHTD, selectorderline join({Order Line ID} == order_line_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOrderLine",
						"JoinOrderLine, selectorderhistory join(selectorderline@order_id == selectorderhistory@order_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOrderHistory",
						"orderstatushistory filter(status=='Shipped') ~> filtershipmentstatus",
						"JoinOrderHistory, selectshipmentstatus join(selectorderline@order_id == selectshipmentstatus@order_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOrderShipmentStatusHistory",
						"filtershipmentstatus select(mapColumn(",
						"          order_id,",
						"          shipment_date = status_date,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectshipmentstatus",
						"RemoveDuplicates alterRow(upsertIf(true())) ~> AlterRow1",
						"JoinOrderShipmentStatusHistory filter(not(isNull({Carrier Name}))&& not(isNull(service_level_name))) ~> FilterNotNullRows",
						"FilterNotNullRows aggregate(groupBy({Shipment ID},",
						"          order_code,",
						"          {Carrier Name},",
						"          service_level_name,",
						"          status,",
						"          shipment_date,",
						"          {Location ID},",
						"          import_date,",
						"          selectthtd@business_unit_id,",
						"          selectthtd@organization_id),",
						"     {Total Units} = toFloat(sum({Total Units})),",
						"          {Total Shipment Weight} = toFloat(avg({Total Shipment Weight})),",
						"          {Total Shipment Volume} = toFloat(avg({Total Shipment Volume})),",
						"          {Total Shipment Cost} = toFloat(sum({Total Shipment Cost}))) ~> RemoveDuplicates",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          shipment_code as string,",
						"          order_code as string,",
						"          delivery_partner_name as string,",
						"          service_level as string,",
						"          status as string,",
						"          shipment_date as timestamp,",
						"          total_units as float,",
						"          total_weight as float,",
						"          total_volume as float,",
						"          total_cost as float,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          import_date as timestamp,",
						"          location_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['shipment_code'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          shipment_code = {Shipment ID},",
						"          order_code,",
						"          delivery_partner_name = {Carrier Name},",
						"          service_level = service_level_name,",
						"          status,",
						"          shipment_date,",
						"          total_units = {Total Units},",
						"          total_weight = {Total Shipment Weight},",
						"          total_volume = {Total Shipment Volume},",
						"          total_cost = {Total Shipment Cost},",
						"          business_unit_id,",
						"          organization_id,",
						"          import_date,",
						"          location_code = {Location ID}",
						"     )) ~> ShipmentHistory"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/SHIPMENT_HISTORY_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/order_line_history')]",
				"[concat(variables('factoryId'), '/datasets/order_history')]",
				"[concat(variables('factoryId'), '/datasets/order_status_history')]",
				"[concat(variables('factoryId'), '/datasets/shipment_history')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_shipment_line_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SHIPMENT_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "shipmenthistoryraw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchytable"
						},
						{
							"dataset": {
								"referenceName": "order_line_history",
								"type": "DatasetReference"
							},
							"name": "orderlinehistory"
						},
						{
							"dataset": {
								"referenceName": "shipment_history",
								"type": "DatasetReference"
							},
							"name": "shipmenthistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "shipment_line_history",
								"type": "DatasetReference"
							},
							"name": "ShipmentLineHistory"
						}
					],
					"transformations": [
						{
							"name": "derivebusinessunitname"
						},
						{
							"name": "FilterBusinessUnit"
						},
						{
							"name": "SelectTHD"
						},
						{
							"name": "JoinTHDT"
						},
						{
							"name": "SelectOLH"
						},
						{
							"name": "JoinSLH2OLH"
						},
						{
							"name": "SelectSH"
						},
						{
							"name": "JoinSH2SLH"
						},
						{
							"name": "AlterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Shipment ID} as string,",
						"          {Order Line ID} as string,",
						"          {Location ID} as string,",
						"          {Carrier Name} as string,",
						"          Mode as string,",
						"          {Total Units} as float,",
						"          {Total Shipment Weight} as float,",
						"          {Total Shipment Volume} as float,",
						"          {Total Shipment Cost} as float,",
						"          {Total Shipment Value} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> shipmenthistoryraw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchytable",
						"source(output(",
						"          order_id as integer,",
						"          order_line_code as string,",
						"          item_code as string,",
						"          item_name as string,",
						"          item_description as string,",
						"          order_quantity as float,",
						"          ship_quantity as float,",
						"          line_status as string,",
						"          item_price as float,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> orderlinehistory",
						"source(output(",
						"          id as integer,",
						"          shipment_code as string,",
						"          order_code as string,",
						"          delivery_partner_name as string,",
						"          service_level as string,",
						"          status as string,",
						"          shipment_date as timestamp,",
						"          total_units as float,",
						"          total_weight as float,",
						"          total_volume as float,",
						"          total_cost as float,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          import_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> shipmenthistory",
						"shipmenthistoryraw derive(business_unit_name = split(split(file_name,'/')[4],\"_\")[2]) ~> derivebusinessunitname",
						"tenantheirarchytable filter(tenant_hierarchy_type==3) ~> FilterBusinessUnit",
						"FilterBusinessUnit select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectTHD",
						"derivebusinessunitname, SelectTHD join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHDT",
						"orderlinehistory select(mapColumn(",
						"          order_id,",
						"          order_line_code,",
						"          item_code,",
						"          item_name,",
						"          ship_quantity,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectOLH",
						"JoinSH2SLH, SelectOLH join({Order Line ID} == order_line_code",
						"     && SelectTHD@business_unit_id == SelectOLH@business_unit_id",
						"     && SelectTHD@organization_id == SelectOLH@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinSLH2OLH",
						"shipmenthistory select(mapColumn(",
						"          shipment_id = id,",
						"          shipment_code,",
						"          order_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectSH",
						"JoinTHDT, SelectSH join({Shipment ID} == shipment_code",
						"     && SelectTHD@business_unit_id == SelectSH@business_unit_id",
						"     && SelectTHD@organization_id == SelectSH@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinSH2SLH",
						"JoinSLH2OLH alterRow(upsertIf(true())) ~> AlterRow1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          shipment_id as integer,",
						"          shipment_line_code as string,",
						"          order_code as string,",
						"          order_line_code as string,",
						"          item_code as string,",
						"          item_name as string,",
						"          units as float,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['order_code','order_line_code'],",
						"     format: 'table',",
						"     batchSize: 4000000,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          shipment_id,",
						"          shipment_line_code = shipment_code,",
						"          order_code,",
						"          order_line_code,",
						"          item_code,",
						"          item_name,",
						"          units = {Total Units},",
						"          business_unit_id = SelectOLH@business_unit_id,",
						"          organization_id = SelectTHD@organization_id",
						"     )) ~> ShipmentLineHistory"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/SHIPMENT_HISTORY_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/order_line_history')]",
				"[concat(variables('factoryId'), '/datasets/shipment_history')]",
				"[concat(variables('factoryId'), '/datasets/shipment_line_history')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_throughput_predictions')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "THROUGHPUT_PREDICTIONS_RAW",
								"type": "DatasetReference"
							},
							"name": "throughtputoutput"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyTable"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "LocationsTable"
						},
						{
							"dataset": {
								"referenceName": "enum_types",
								"type": "DatasetReference"
							},
							"name": "EnumTypeDB"
						},
						{
							"dataset": {
								"referenceName": "enum_values",
								"type": "DatasetReference"
							},
							"name": "EnumValue"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "operational_calendar",
								"type": "DatasetReference"
							},
							"name": "WriteToDatabase"
						}
					],
					"transformations": [
						{
							"name": "SelectedColsThroughput"
						},
						{
							"name": "DeriveAttributes"
						},
						{
							"name": "THTSelected"
						},
						{
							"name": "JoinTHT"
						},
						{
							"name": "FinalSelectThroughputPredictions"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "LocationsSelected"
						},
						{
							"name": "JoinLocationsTable"
						},
						{
							"name": "JoinEnumLocationMetricType"
						},
						{
							"name": "FilterEnumLocationMetricType"
						},
						{
							"name": "JoinLocationMetricTypeEnum"
						},
						{
							"name": "FilterBURecords"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Prop_0 as string,",
						"          date as date,",
						"          unit_volume as string,",
						"          capacity as string,",
						"          picker_capacity as string,",
						"          packer_capacity as string,",
						"          total_work_hours as string,",
						"          inventory_level as string,",
						"          throughput_preds as decimal(10,0)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: true,",
						"     rowUrlColumn: 'file_name',",
						"     mode: 'read') ~> throughtputoutput",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyTable",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> LocationsTable",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EnumTypeDB",
						"source(output(",
						"          id as integer,",
						"          enum_type_id as integer,",
						"          value_id as integer,",
						"          value as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EnumValue",
						"throughtputoutput select(mapColumn(",
						"          date,",
						"          throughput_preds,",
						"          file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectedColsThroughput",
						"SelectedColsThroughput derive(location_code = split(split(file_name,'/')[4],'_')[2],",
						"          business_unit_name = split(split(file_name,'/')[4],'_')[1],",
						"          location_metric_type = \"Throughput\") ~> DeriveAttributes",
						"FilterBURecords select(mapColumn(",
						"          id,",
						"          name,",
						"          tenant_id,",
						"          parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> THTSelected",
						"DeriveAttributes, THTSelected join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHT",
						"JoinLocationMetricTypeEnum select(mapColumn(",
						"          location_id,",
						"          business_unit_id = THTSelected@id,",
						"          organization_id = parent_id,",
						"          date,",
						"          location_metric_value = throughput_preds,",
						"          location_metric_type_id = value_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> FinalSelectThroughputPredictions",
						"FinalSelectThroughputPredictions alterRow(upsertIf(true())) ~> AlterRow1",
						"LocationsTable select(mapColumn(",
						"          location_id = id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LocationsSelected",
						"JoinTHT, LocationsSelected join(DeriveAttributes@location_code == LocationsSelected@location_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocationsTable",
						"FilterEnumLocationMetricType, EnumValue join(EnumTypeDB@id == enum_type_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinEnumLocationMetricType",
						"EnumTypeDB filter(name=='location_metric_type') ~> FilterEnumLocationMetricType",
						"JoinLocationsTable, JoinEnumLocationMetricType join(location_metric_type == value,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocationMetricTypeEnum",
						"TenantHeirarchyTable filter(tenant_hierarchy_type==3) ~> FilterBURecords",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          location_id as integer,",
						"          date as date,",
						"          location_metric_value as decimal(0,0),",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          enum_value_id as integer,",
						"          enum_type_id as integer,",
						"          operational_profile_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['location_id','date','location_metric_type_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          business_unit_id,",
						"          organization_id,",
						"          location_id,",
						"          date,",
						"          location_metric_value,",
						"          location_metric_type_id",
						"     )) ~> WriteToDatabase"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/THROUGHPUT_PREDICTIONS_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/enum_types')]",
				"[concat(variables('factoryId'), '/datasets/enum_values')]",
				"[concat(variables('factoryId'), '/datasets/operational_calendar')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transform_current_backlog')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CurrentBacklogMain",
								"type": "DatasetReference"
							},
							"name": "currentbacklogmain"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "current_backlog_table",
								"type": "DatasetReference"
							},
							"name": "sinkcurrentbacklog"
						}
					],
					"transformations": [
						{
							"name": "derivecolumns"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "fulfillmentservicesselect"
						},
						{
							"name": "joinfulfillmentservices"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/CurrentBacklog/86.txt'),",
						"     transaction_id as string ('86')",
						"}",
						"source(output(",
						"          {Fulfillment Location ID*} as string,",
						"          {Fulfillment Service*} as string,",
						"          {Backlog Date*} as date,",
						"          {Backlog Units} as long,",
						"          {Backlog Orders} as long,",
						"          {Units per Order} as float",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> currentbacklogmain",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"currentbacklogmain derive(transaction_id = toInteger($transaction_id)) ~> derivecolumns",
						"importhistory select(mapColumn(",
						"          import_history_id = id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"derivecolumns, selectimporthistory join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory, selectlocations join({Fulfillment Location ID*} == location_code",
						"     && selectimporthistory@business_unit_id == selectlocations@business_unit_id",
						"     && selectimporthistory@organization_id == selectlocations@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"locations select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"fulfillmentservices select(mapColumn(",
						"          fulfillment_service_id = id,",
						"          service_name,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> fulfillmentservicesselect",
						"joinlocations, fulfillmentservicesselect join({Fulfillment Service*} == service_name",
						"     && selectlocations@business_unit_id == fulfillmentservicesselect@business_unit_id",
						"     && selectlocations@organization_id == fulfillmentservicesselect@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinfulfillmentservices",
						"joinfulfillmentservices sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          backlog_date as date,",
						"          open_backlog_units as long,",
						"          open_backlog_orders as long,",
						"          average_upo as float,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          organization_id,",
						"          business_unit_id = selectimporthistory@business_unit_id,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          backlog_date = {Backlog Date*},",
						"          open_backlog_units = {Backlog Units},",
						"          open_backlog_orders = {Backlog Orders},",
						"          average_upo = {Units per Order}",
						"     )) ~> sinkcurrentbacklog"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/CurrentBacklogMain')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_services')]",
				"[concat(variables('factoryId'), '/datasets/current_backlog_table')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transform_fulfillment_forecast_ux')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "FulfillmentForecastMain",
								"type": "DatasetReference"
							},
							"name": "fulfillmentforecastmain"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "fulfillment_forecast",
								"type": "DatasetReference"
							},
							"name": "sinkfulfillmentforecast"
						}
					],
					"transformations": [
						{
							"name": "derivecolumns"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "fulfillmentservicesselect"
						},
						{
							"name": "joinfulfillmentservices"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/FulfillmentForecast/338.txt'),",
						"     transaction_id as string ('338')",
						"}",
						"source(output(",
						"          {Fulfillment Location ID*} as string,",
						"          {Fulfillment Service*} as string,",
						"          {Forecast Date*} as date,",
						"          {Forecast 1 Units} as long,",
						"          {Forecast 1 Orders} as long,",
						"          {Forecast 2 Units} as float,",
						"          {Forecast 2 Orders} as long,",
						"          {Units per Order} as long,",
						"          {Forecast Locked Date} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> fulfillmentforecastmain",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"fulfillmentforecastmain derive(transaction_id = toInteger($transaction_id)) ~> derivecolumns",
						"importhistory select(mapColumn(",
						"          import_history_id = id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"derivecolumns, selectimporthistory join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory, selectlocations join({Fulfillment Location ID*} == location_code",
						"     && selectimporthistory@business_unit_id == selectlocations@business_unit_id",
						"     && selectimporthistory@organization_id == selectlocations@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"locations select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"fulfillmentservices select(mapColumn(",
						"          fulfillment_service_id = id,",
						"          service_name,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> fulfillmentservicesselect",
						"joinlocations, fulfillmentservicesselect join({Fulfillment Service*} == service_name",
						"     && selectimporthistory@business_unit_id == fulfillmentservicesselect@business_unit_id",
						"     && selectimporthistory@organization_id == fulfillmentservicesselect@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinfulfillmentservices",
						"joinfulfillmentservices sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          forecast_date as date,",
						"          locked_forecast_units as long,",
						"          current_forecast_units as long,",
						"          average_upo as float,",
						"          locked_forecast_orders as long,",
						"          current_forecast_orders as long,",
						"          forecast_locked_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          forecast_3_units as long,",
						"          forecast_3_orders as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          organization_id,",
						"          business_unit_id,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          forecast_date = {Forecast Date*},",
						"          locked_forecast_units = {Forecast 1 Units},",
						"          current_forecast_units = {Forecast 2 Units},",
						"          average_upo = {Units per Order},",
						"          locked_forecast_orders = {Forecast 1 Orders},",
						"          current_forecast_orders = {Forecast 2 Orders},",
						"          forecast_locked_date = {Forecast Locked Date}",
						"     )) ~> sinkfulfillmentforecast"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/FulfillmentForecastMain')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_services')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_forecast')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transform_inventory')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "INVENTORY_MAIN_UX",
								"type": "DatasetReference"
							},
							"name": "inventorymain",
							"description": "inventory main"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "item"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchydetail"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "inventory",
								"type": "DatasetReference"
							},
							"name": "sinkinventory"
						}
					],
					"transformations": [
						{
							"name": "derivecolumns"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "itemselect"
						},
						{
							"name": "joinitem",
							"description": "Inner join on 'joinlocations' and 'item'"
						},
						{
							"name": "jointhtd"
						},
						{
							"name": "filterburecords"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/Inventory/211.txt'),",
						"     transaction_id as string ('211')",
						"}",
						"source(output(",
						"          {Item ID} as string,",
						"          {Location ID} as string,",
						"          {Stock Date} as date,",
						"          {Stock Quantity} as float,",
						"          {Reserved Quantity} as float,",
						"          {Available Quantity} as float,",
						"          {On Order ID} as string,",
						"          {On Order Due Date} as date,",
						"          {On Order Supplier Shipping Date} as date,",
						"          {On Order Promised Delivery Date} as date",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> inventorymain",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> item",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchydetail",
						"inventorymain derive(transaction_id = toInteger($transaction_id),",
						"          stock_type_id = 1) ~> derivecolumns",
						"jointhtd select(mapColumn(",
						"          import_history_id = importhistory@id,",
						"          business_unit_id,",
						"          organization_id,",
						"          tenant_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"derivecolumns, selectimporthistory join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory, selectlocations join({Location ID} == location_code",
						"     && selectimporthistory@organization_id == selectlocations@organization_id",
						"     && selectimporthistory@business_unit_id == selectlocations@business_unit_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"locations select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"item select(mapColumn(",
						"          item_id = id,",
						"          item_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> itemselect",
						"joinlocations, itemselect join({Item ID} == item_code",
						"     && selectimporthistory@business_unit_id == itemselect@business_unit_id",
						"     && selectimporthistory@organization_id == itemselect@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinitem",
						"importhistory, filterburecords join(business_unit_id == tenantheirarchydetail@id",
						"     && organization_id == parent_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointhtd",
						"tenantheirarchydetail filter(tenant_hierarchy_type==3) ~> filterburecords",
						"joinitem sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          item_id as integer,",
						"          location_id as integer,",
						"          on_hand_stock_date as date,",
						"          on_hand_stock_quantity as float,",
						"          reserved_on_hold_stock_ as float,",
						"          available_stock as float,",
						"          lot_id as string,",
						"          on_order_due_date as date,",
						"          on_order_quantity_ as float,",
						"          purchase_order_status as float,",
						"          on_order_supplier_shipping_date as date,",
						"          on_order_promised_delivery_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          stock_type_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          item_id,",
						"          location_id,",
						"          on_hand_stock_date = {Stock Date},",
						"          on_hand_stock_quantity = {Stock Quantity},",
						"          reserved_on_hold_stock_ = {Reserved Quantity},",
						"          available_stock = {Available Quantity},",
						"          lot_id = {On Order ID},",
						"          on_order_due_date = {On Order Due Date},",
						"          on_order_supplier_shipping_date = {On Order Supplier Shipping Date},",
						"          on_order_promised_delivery_date = {On Order Promised Delivery Date},",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id = selectimporthistory@business_unit_id,",
						"          stock_type_id",
						"     )) ~> sinkinventory"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/INVENTORY_MAIN_UX')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/item')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/inventory')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transform_location_staffing')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LocationStaffingMain",
								"type": "DatasetReference"
							},
							"name": "locationstaffingmain"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "enum_values",
								"type": "DatasetReference"
							},
							"name": "enumvalue"
						},
						{
							"dataset": {
								"referenceName": "operationalprofile",
								"type": "DatasetReference"
							},
							"name": "operationalprofile"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "operational_calendar",
								"type": "DatasetReference"
							},
							"name": "sinkopeartionalcalendar"
						}
					],
					"transformations": [
						{
							"name": "derivecolumns"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "colsselectenumvalue"
						},
						{
							"name": "filterenumvalues"
						},
						{
							"name": "joinenumvalues"
						},
						{
							"name": "operationalprofileselect"
						},
						{
							"name": "joinoperationalprofile"
						},
						{
							"name": "selectcols"
						},
						{
							"name": "filtertransaction"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/LocationStaffing/439.txt'),",
						"     transaction_id as string ('439')",
						"}",
						"source(output(",
						"          {Profile Name*} as string,",
						"          {Location ID*} as string,",
						"          {Date*} as date,",
						"          {Metric_Name*} as string,",
						"          {Value*} as decimal(10,0),",
						"          validation_errors as string,",
						"          errors_count as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> locationstaffingmain",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          enum_type_id as integer,",
						"          value_id as integer,",
						"          value as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> enumvalue",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> operationalprofile",
						"locationstaffingmain derive(transaction_id = toInteger($transaction_id)) ~> derivecolumns",
						"filtertransaction select(mapColumn(",
						"          import_history_id = id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"derivecolumns, selectimporthistory join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory, selectlocations join({Location ID*} == location_code",
						"     && selectimporthistory@business_unit_id == selectlocations@business_unit_id",
						"     && selectimporthistory@organization_id == selectlocations@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"locations select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"filterenumvalues select(mapColumn(",
						"          enum_type_id,",
						"          value_id,",
						"          value",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> colsselectenumvalue",
						"enumvalue filter(enum_type_id==4) ~> filterenumvalues",
						"joinlocations, colsselectenumvalue join(lower({Metric_Name*}) == lower(value),",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinenumvalues",
						"operationalprofile select(mapColumn(",
						"          operational_profile_id = id,",
						"          name,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> operationalprofileselect",
						"joinenumvalues, operationalprofileselect join({Profile Name*} == name",
						"     && selectimporthistory@business_unit_id == operationalprofileselect@business_unit_id",
						"     && selectlocations@organization_id == operationalprofileselect@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinoperationalprofile",
						"joinoperationalprofile select(mapColumn(",
						"          {Date*},",
						"          {Value*},",
						"          import_history_id,",
						"          business_unit_id = selectimporthistory@business_unit_id,",
						"          organization_id = selectimporthistory@organization_id,",
						"          location_id,",
						"          enum_type_id,",
						"          value_id,",
						"          operational_profile_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcols",
						"importhistory filter(id == toInteger($transaction_id)) ~> filtertransaction",
						"selectcols sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          location_id as integer,",
						"          date as date,",
						"          location_metric_value as decimal(0,0),",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          enum_value_id as integer,",
						"          enum_type_id as integer,",
						"          operational_profile_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          business_unit_id,",
						"          organization_id,",
						"          location_id,",
						"          date = {Date*},",
						"          location_metric_value = {Value*},",
						"          enum_value_id = value_id,",
						"          enum_type_id,",
						"          operational_profile_id",
						"     )) ~> sinkopeartionalcalendar"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/LocationStaffingMain')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/enum_values')]",
				"[concat(variables('factoryId'), '/datasets/operationalprofile')]",
				"[concat(variables('factoryId'), '/datasets/operational_calendar')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transform_location_ux')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LocationsMain",
								"type": "DatasetReference"
							},
							"name": "locationmain"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "location_type",
								"type": "DatasetReference"
							},
							"name": "locationtype"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchydetail"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "sinklocation"
						}
					],
					"transformations": [
						{
							"name": "derivecolumns"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocationtypes"
						},
						{
							"name": "joinTHTD"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/Location/198.txt'),",
						"     transaction_id as string ('198')",
						"}",
						"source(output(",
						"          {Location ID*} as string,",
						"          {Location Name} as string,",
						"          Address as string,",
						"          City as string,",
						"          State as string,",
						"          Zip as string,",
						"          Country as string,",
						"          Longitude as double,",
						"          Latitude as double,",
						"          {Location Status} as string,",
						"          {Location Type} as string,",
						"          {Daily Throughput} as float,",
						"          {Storage Capacity} as float,",
						"          {Inbound Handling Cost} as float,",
						"          {Outbound Handling Cost} as float,",
						"          {Inbound Processing Time} as decimal(10,0),",
						"          {Outbound Processing Time} as decimal(10,0),",
						"          {Transfer Inbound Processing Time} as double,",
						"          {Transfer Outbound Processing Time} as double,",
						"          {Transfer Inbound Handling Cost} as double,",
						"          {Transfer Outbound Handling Cost} as double,",
						"          {Units per Hour} as float,",
						"          {Max FTE Regular Hours} as float,",
						"          {Min FTE Regular Hours} as float,",
						"          {Max Temp Regular Hours} as float,",
						"          {Min Temp Regular Hours} as float,",
						"          {Regular FTE Wage} as float,",
						"          {Regular Temp Wage} as float,",
						"          {Overtime FTE Wage} as float,",
						"          {Overtime Temp Wage} as float,",
						"          {FTE Staff Count} as integer,",
						"          {Temp Staff Count} as integer",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> locationmain",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          description as string,",
						"          created_date as date,",
						"          updated_date as date,",
						"          display_icon as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locationtype",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchydetail",
						"locationmain derive(transaction_id = toInteger($transaction_id)) ~> derivecolumns",
						"joinTHTD select(mapColumn(",
						"          import_history_id = importhistory@id,",
						"          business_unit_id,",
						"          organization_id,",
						"          tenant_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"derivecolumns, selectimporthistory join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory, selectlocationtypes join({Location Type} == location_type_name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"locationtype select(mapColumn(",
						"          location_type_id = id,",
						"          location_type_name = name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocationtypes",
						"importhistory, tenantheirarchydetail join(business_unit_id == tenantheirarchydetail@id",
						"     && organization_id == parent_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinTHTD",
						"joinlocations sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          location_code = {Location ID*},",
						"          name = {Location Name},",
						"          address = Address,",
						"          city = City,",
						"          state = State,",
						"          zip = Zip,",
						"          country = Country,",
						"          throughput = {Daily Throughput},",
						"          capacity = {Storage Capacity},",
						"          inbound_handling_cost = {Inbound Handling Cost},",
						"          outbound_handling_cost = {Outbound Handling Cost},",
						"          longitude = Longitude,",
						"          latitude = Latitude,",
						"          status = {Location Status},",
						"          inbound_processing_time = {Inbound Processing Time},",
						"          outbound_processing_time = {Outbound Processing Time},",
						"          type = location_type_id,",
						"          transfer_inbound_processing_time = {Transfer Inbound Processing Time},",
						"          transfer_outbound_processing_time = {Transfer Outbound Processing Time},",
						"          transfer_inbound_handling_cost = {Transfer Inbound Handling Cost},",
						"          transfer_outbound_handling_cost = {Transfer Outbound Handling Cost},",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          units_per_hour = {Units per Hour},",
						"          max_fte_regular_hours = {Max FTE Regular Hours},",
						"          min_fte_regular_hours = {Min FTE Regular Hours},",
						"          max_temp_regular_hours = {Max Temp Regular Hours},",
						"          min_temp_regular_hours = {Min Temp Regular Hours},",
						"          max_fte_overtime_hours = {Max FTE Regular Hours},",
						"          max_temp_overtime_hours = {Max FTE Regular Hours},",
						"          regular_fte_wage = {Regular FTE Wage},",
						"          regular_temp_wage = {Regular Temp Wage},",
						"          overtime_fte_wage = {Overtime FTE Wage},",
						"          overtime_temp_wage = {Overtime Temp Wage},",
						"          fte_staff_count = {FTE Staff Count},",
						"          temp_staff_count = {Temp Staff Count}",
						"     )) ~> sinklocation"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/LocationsMain')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/location_type')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/locations')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transportation_lane')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Data flow edited on 2023-08-08 on bringing in attributes from filename and using lookup to fetch organization_id and business_unit_id",
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ZONE_RAW",
								"type": "DatasetReference"
							},
							"name": "RawDataForZone",
							"description": "source data stored in datalake-\"radial-demo-data\" for populating pfp.zone table\n"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyTable",
							"description": "Data from tenant_heirarchy_table"
						},
						{
							"dataset": {
								"referenceName": "TRANSIT_TIME_RAW",
								"type": "DatasetReference"
							},
							"name": "TransitTimeTable",
							"description": "Transit time table data"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "LocationsTable"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "transportation_lane",
								"type": "DatasetReference"
							},
							"name": "WriteToDatabase",
							"description": "Write Records To transportation_lanes table"
						}
					],
					"transformations": [
						{
							"name": "DerivingAttributes",
							"description": "Deriving attributes for fields like origin_start, origin_end, business_unit_name from filename, static value for delivery_partner_id"
						},
						{
							"name": "MappingColumns",
							"description": "Final step in data transformation to select specific columns, renaming certain columns to match the zone table schema"
						},
						{
							"name": "JoinHeirarchyTable"
						},
						{
							"name": "JoinTransitTime"
						},
						{
							"name": "DeriveAttributesTransitTable"
						},
						{
							"name": "JoinLocations"
						},
						{
							"name": "SelectColumnsHeirarchyTable",
							"description": "Select columns relevant for downstream actviites"
						},
						{
							"name": "SelectColumnsRawData",
							"description": "select the relevant columns alone from RawDataZone"
						},
						{
							"name": "SelectColumnsLocationTable",
							"description": "Select relavant columns"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterBUrecords"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Dest. ZIP} as string,",
						"          {Ground - ZONE} as string,",
						"          {3 Day Select} as string,",
						"          {2nd Day Air} as string,",
						"          {2nd Day Air A.M.} as string,",
						"          {Next Day Air Saver} as string,",
						"          {Next Day Air} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: true,",
						"     rowUrlColumn: 'file_name') ~> RawDataForZone",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyTable",
						"source(output(",
						"          Zones as string,",
						"          {Transit Time} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name_transit') ~> TransitTimeTable",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> LocationsTable",
						"SelectColumnsRawData derive(origin_zip = split(split(file_name,\"/\")[4],\"_\")[2],",
						"          business_unit_name = split(split(file_name,\"/\")[4],\"_\")[1],",
						"          origin_country = 'US',",
						"          destination_country = 'US',",
						"          zone = toInteger({Ground - ZONE}),",
						"          organization_id := \"8078acfb-eca6-4708-b197-694f50a24c92\",",
						"          business_unit_id := \"994dc35f-7eba-4f6e-918b-7bd311482d7b\",",
						"          local1 := \"8078acfb-eca6-4708-b197-694f50a24c92\") ~> DerivingAttributes",
						"JoinLocations select(mapColumn(",
						"          delivery_partner_id,",
						"          rate_code,",
						"          service_type,",
						"          origin_location_code = location_code,",
						"          origin_zip,",
						"          origin_country,",
						"          destination_zip = {Dest. ZIP},",
						"          destination_country,",
						"          transit_time = {Transit Time},",
						"          zone,",
						"          business_unit_id = id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> MappingColumns",
						"DerivingAttributes, SelectColumnsHeirarchyTable join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinHeirarchyTable",
						"JoinHeirarchyTable, DeriveAttributesTransitTable join({Ground - ZONE} == Zones,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTransitTime",
						"TransitTimeTable derive(delivery_partner_id = split(split(file_name_transit,\"/\")[4],\"_\")[2],",
						"          service_type = split(split(file_name_transit,\"/\")[4],\"_\")[3],",
						"          rate_code = split(split(file_name_transit,\"/\")[4],\"_\")[2]+'-'+split(split(file_name_transit,\"/\")[4],\"_\")[3]+\"-\"+Zones) ~> DeriveAttributesTransitTable",
						"JoinTransitTime, SelectColumnsLocationTable join(origin_zip == toString(zip_code),",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocations",
						"FilterBUrecords select(mapColumn(",
						"          id,",
						"          name,",
						"          parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumnsHeirarchyTable",
						"RawDataForZone select(mapColumn(",
						"          {Dest. ZIP},",
						"          {Ground - ZONE},",
						"          file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumnsRawData",
						"LocationsTable select(mapColumn(",
						"          zip_code = id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumnsLocationTable",
						"MappingColumns alterRow(upsertIf(true())) ~> AlterRow1",
						"TenantHeirarchyTable filter(tenant_hierarchy_type==3) ~> FilterBUrecords",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          delivery_partner_id as string,",
						"          rate_code as string,",
						"          fulfillment_service_type as string,",
						"          service_type as string,",
						"          origin_location_code as integer,",
						"          origin_address as string,",
						"          origin_city as string,",
						"          origin_state as string,",
						"          origin_zip as string,",
						"          origin_country as string,",
						"          destination_location_code as integer,",
						"          destination_address as string,",
						"          destination_city as string,",
						"          destination_state as string,",
						"          destination_zip as string,",
						"          destination_country as string,",
						"          transit_time as integer,",
						"          zone as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['rate_code','origin_zip','destination_zip'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     preCommands: [],",
						"     postCommands: []) ~> WriteToDatabase"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ZONE_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/TRANSIT_TIME_RAW')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/transportation_lane')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_validation_current_backlog')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CURRENT_BACKLOG_UX_STAGING",
								"type": "DatasetReference"
							},
							"name": "currentbackloguxuploadstaging"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices",
							"description": "Import data from fulfillment services"
						},
						{
							"dataset": {
								"referenceName": "current_backlog_table",
								"type": "DatasetReference"
							},
							"name": "currentbacklog"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "current_backlog_table",
								"type": "DatasetReference"
							},
							"name": "ValidCurrentBacklog"
						},
						{
							"dataset": {
								"referenceName": "FailedValidationRowsCurrentBacklog",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "validations"
						},
						{
							"name": "reverserename"
						},
						{
							"name": "deriveerrors"
						},
						{
							"name": "selectmainfields"
						},
						{
							"name": "aggregateerrors"
						},
						{
							"name": "joinaggregaterror"
						},
						{
							"name": "splitvalidatedrows"
						},
						{
							"name": "derivedfilename"
						},
						{
							"name": "newchangenameforassert"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "selectfulfillmentservices"
						},
						{
							"name": "derivepresence"
						},
						{
							"name": "joinforecastservices"
						},
						{
							"name": "selectexistrecordcheck"
						},
						{
							"name": "joinexistrecordchech"
						},
						{
							"name": "selectcolsforassert"
						},
						{
							"name": "joincurrentbacklog"
						},
						{
							"name": "filtertransaction"
						},
						{
							"name": "joinbuorglocation"
						},
						{
							"name": "joinbuorgfservice"
						},
						{
							"name": "joinbuorgcbacklog"
						},
						{
							"name": "recordid"
						},
						{
							"name": "detectduplicates"
						},
						{
							"name": "filterrowswithvalidationerrors"
						},
						{
							"name": "filteremptyrows"
						},
						{
							"name": "alterRow1"
						},
						{
							"name": "dervietranscolumn"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "selectimporthistory"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/CurrentBacklog/580.xlsx'),",
						"     transaction_id as string ('580')",
						"}",
						"source(output(",
						"          {Fulfillment Location ID*} as string,",
						"          {Fulfillment Service*} as string,",
						"          {Backlog Date*} as date,",
						"          {Backlog Units} as string,",
						"          {Backlog Orders} as string,",
						"          {Units per Order} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> currentbackloguxuploadstaging",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"source(output(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          backlog_date as date,",
						"          open_backlog_units as long,",
						"          open_backlog_orders as long,",
						"          average_upo as float,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> currentbacklog",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"filteremptyrows, selectlocations, selectfulfillmentservices assert(expectTrue(not(isNull(Fulfillment_Location_ID))&&not(isNull(Fulfillment_Service))&&not(isNull(Backlog_Date)), false, 'nullvalues', null, 'Null Values Found In Mandatory Fields'),",
						"     expectExists(Fulfillment_Location_ID == location_code, false, 'locationexist', null, 'Location ID Not Found In Database'),",
						"     expectExists(Fulfillment_Service == service_name, false, 'serviceexist', null, 'Fulfillment Service Does Not Exists In Database'),",
						"     expectTrue(isNull(presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
						"     expectTrue(iif(isNull(Backlog_Units),true(),not(isNull(toFloat(Backlog_Units))))&& iif(isNull(Backlog_Orders),true(),not(isNull(toFloat(Backlog_Orders)))) && iif(isNull(Units_per_Order),true(),not(isNull(toFloat(Units_per_Order)))), false, 'nonnumericvals', null, 'Non numeric values present in record for numeric fields'),",
						"     expectTrue(nonduplicatedrow, false, 'duplicaterecords', null, 'Duplicate Records Found In The Upload'),",
						"     expectTrue(iif ( (toFloat(Backlog_Units) < 0) || (toFloat(Backlog_Orders) < 0) || (toFloat(Units_per_Order) < 0), false(), true() ), false, 'negativenumbers', null, 'Negative values present in record for numeric fields')) ~> validations",
						"validations select(mapColumn(",
						"          {Fulfillment Location ID*} = Fulfillment_Location_ID,",
						"          {Fulfillment Service*} = Fulfillment_Service,",
						"          {Backlog Date*} = Backlog_Date,",
						"          {Backlog Units} = Backlog_Units,",
						"          {Backlog Orders} = Backlog_Orders,",
						"          {Units per Order} = Units_per_Order,",
						"          file_name,",
						"          recordid,",
						"          location_id = selectcolsforassert@location_id,",
						"          fulfillment_service_id = selectcolsforassert@fulfillment_service_id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> reverserename",
						"reverserename derive(validation_errors = assertErrorMessages(),",
						"          transaction_id = toInteger($transaction_id),",
						"          sink_file_name = replace(file_name,'.xlsx','.txt'),",
						"          {Backlog Units} = toLong({Backlog Units}),",
						"          {Backlog Orders} = toLong({Backlog Orders}),",
						"          {Units per Order} = toFloat({Units per Order})) ~> deriveerrors",
						"joinaggregaterror select(mapColumn(",
						"          {Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Backlog Date*},",
						"          {Backlog Units},",
						"          {Backlog Orders},",
						"          {Units per Order},",
						"          file_name = reverserename@file_name,",
						"          validation_errors,",
						"          transaction_id,",
						"          sink_file_name,",
						"          file_name = aggregateerrors@file_name,",
						"          errors_count,",
						"          recordid,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectmainfields",
						"deriveerrors aggregate(groupBy(file_name),",
						"     errors_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
						"deriveerrors, aggregateerrors join(reverserename@file_name == aggregateerrors@file_name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinaggregaterror",
						"selectmainfields split(errors_count==0,",
						"     disjoint: false) ~> splitvalidatedrows@(validrows, validationfailedrows)",
						"filterrowswithvalidationerrors derive(failed_file_name = replace(replace($file_path,'/Upload/','/FailedTransactions/'),'.xlsx','.json'),",
						"          type = 'error',",
						"          message = concat('record number ',toString(recordid),' has following errors ',toString(validation_errors))) ~> derivedfilename",
						"detectduplicates select(mapColumn(",
						"          Fulfillment_Location_ID = {Fulfillment Location ID*},",
						"          Fulfillment_Service = {Fulfillment Service*},",
						"          Backlog_Date = {Backlog Date*},",
						"          Backlog_Units = {Backlog Units},",
						"          Backlog_Orders = {Backlog Orders},",
						"          Units_per_Order = {Units per Order},",
						"          file_name,",
						"          recordid,",
						"          nonduplicatedrow",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> newchangenameforassert",
						"joinimporthistory, selectlocations join({Fulfillment Location ID*} == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"joinbuorglocation select(mapColumn(",
						"          location_id = locations@id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"joinbuorgfservice select(mapColumn(",
						"          fulfillment_service_id = fulfillmentservices@id,",
						"          service_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectfulfillmentservices",
						"joinbuorgcbacklog derive(presence = 'true') ~> derivepresence",
						"joinlocations, selectfulfillmentservices join({Fulfillment Service*} == service_name,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinforecastservices",
						"joincurrentbacklog select(mapColumn(",
						"          {Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Backlog Date*},",
						"          {Backlog Units},",
						"          {Backlog Orders},",
						"          {Units per Order},",
						"          file_name,",
						"          presence,",
						"          recordid,",
						"          location_id = selectlocations@location_id,",
						"          fulfillment_service_id = selectfulfillmentservices@fulfillment_service_id,",
						"          business_unit_id = selectimporthistory@business_unit_id,",
						"          organization_id = selectimporthistory@organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectexistrecordcheck",
						"newchangenameforassert, selectexistrecordcheck join(newchangenameforassert@recordid == selectexistrecordcheck@recordid,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinexistrecordchech",
						"joinexistrecordchech select(mapColumn(",
						"          Fulfillment_Location_ID,",
						"          Fulfillment_Service,",
						"          Backlog_Date,",
						"          Backlog_Units,",
						"          Backlog_Orders,",
						"          Units_per_Order,",
						"          file_name = selectexistrecordcheck@file_name,",
						"          presence,",
						"          nonduplicatedrow,",
						"          recordid = selectexistrecordcheck@recordid,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcolsforassert",
						"joinforecastservices, derivepresence join(selectlocations@location_id == currentbacklog@location_id",
						"     && selectfulfillmentservices@fulfillment_service_id == currentbacklog@fulfillment_service_id",
						"     && {Backlog Date*} == toDate(toString(backlog_date)),",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joincurrentbacklog",
						"importhistory filter(id==toInteger($transaction_id)) ~> filtertransaction",
						"locations, filtertransaction join(locations@business_unit_id == importhistory@business_unit_id",
						"     && locations@organization_id == importhistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinbuorglocation",
						"fulfillmentservices, filtertransaction join(fulfillmentservices@business_unit_id == importhistory@business_unit_id",
						"     && fulfillmentservices@organization_id == importhistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinbuorgfservice",
						"currentbacklog, filtertransaction join(currentbacklog@business_unit_id == importhistory@business_unit_id",
						"     && currentbacklog@organization_id == importhistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinbuorgcbacklog",
						"currentbackloguxuploadstaging keyGenerate(output(recordid as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> recordid",
						"recordid window(over({Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Backlog Date*},",
						"          file_name),",
						"     asc(recordid, true),",
						"     nonduplicatedrow = rowNumber() == 1) ~> detectduplicates",
						"splitvalidatedrows@validationfailedrows filter(not(isNull(validation_errors))) ~> filterrowswithvalidationerrors",
						"selectcolsforassert filter(not(isNull(Fulfillment_Location_ID)) || not(isNull(Fulfillment_Service)) || not(isNull(Backlog_Date)) || not(isNull(Backlog_Units)) || not(isNull(Backlog_Orders)) || not(isNull(Units_per_Order))) ~> filteremptyrows",
						"splitvalidatedrows@validrows alterRow(insertIf(true())) ~> alterRow1",
						"recordid derive(transaction_id = toInteger($transaction_id)) ~> dervietranscolumn",
						"dervietranscolumn, selectimporthistory join(transaction_id == id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"filtertransaction select(mapColumn(",
						"          id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          backlog_date as date,",
						"          open_backlog_units as long,",
						"          open_backlog_orders as long,",
						"          average_upo as float,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          organization_id,",
						"          business_unit_id,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          backlog_date = {Backlog Date*},",
						"          open_backlog_units = {Backlog Units},",
						"          open_backlog_orders = {Backlog Orders},",
						"          average_upo = {Units per Order}",
						"     ),",
						"     preCommands: [],",
						"     postCommands: []) ~> ValidCurrentBacklog",
						"derivedfilename sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/CURRENT_BACKLOG_UX_STAGING')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_services')]",
				"[concat(variables('factoryId'), '/datasets/current_backlog_table')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/FailedValidationRowsCurrentBacklog')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_validation_fulfillment_forecast')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "FULFILLMENT_FORECAST_UX_STAGING",
								"type": "DatasetReference"
							},
							"name": "fulfillmentforecastuxstaging"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices",
							"description": "Import data from fulfillment services"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_forecast",
								"type": "DatasetReference"
							},
							"name": "fulfillmentforecast"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "FulfillmentForecastMain",
								"type": "DatasetReference"
							},
							"name": "ValidFulfillmentForecast"
						},
						{
							"dataset": {
								"referenceName": "FailedFulfillementRowsJson",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "validations"
						},
						{
							"name": "reverserename"
						},
						{
							"name": "deriveerrors"
						},
						{
							"name": "selectmainfields"
						},
						{
							"name": "aggregateerrors"
						},
						{
							"name": "joinaggregaterror"
						},
						{
							"name": "splitvalidatedrows"
						},
						{
							"name": "derivedfilename"
						},
						{
							"name": "newchangenameforassert"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "selectfulfillmentservices"
						},
						{
							"name": "derivepresence"
						},
						{
							"name": "joinforecastservices"
						},
						{
							"name": "selectexistrecordcheck"
						},
						{
							"name": "joinexistrecordchech"
						},
						{
							"name": "selectcolsforassert"
						},
						{
							"name": "joinfulfillmentforecast"
						},
						{
							"name": "numericalfieldintegritycheck"
						},
						{
							"name": "appendrecordid"
						},
						{
							"name": "filter1"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "jointransactionbuorglocation"
						},
						{
							"name": "jointransbuorgfservice"
						},
						{
							"name": "jointransbuorgfforecast"
						},
						{
							"name": "detectduplicates"
						},
						{
							"name": "filterrowswithvalidationerrors"
						},
						{
							"name": "filteremptyrows"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/FulfillmentForecast/460.xlsx'),",
						"     transaction_id as string ('460')",
						"}",
						"source(output(",
						"          {Forecast Date*} as date,",
						"          {Forecast 1 Units} as string,",
						"          {Forecast 1 Orders} as string,",
						"          {Forecast 2 Units} as string,",
						"          {Units per Order} as string,",
						"          {Forecast Locked Date} as date,",
						"          {Fulfillment Service*} as string,",
						"          {Fulfillment Location ID*} as string,",
						"          {Forecast 2 Orders} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> fulfillmentforecastuxstaging",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"source(output(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          forecast_date as date,",
						"          locked_forecast_units as long,",
						"          current_forecast_units as long,",
						"          average_upo as float,",
						"          locked_forecast_orders as long,",
						"          current_forecast_orders as long,",
						"          forecast_locked_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentforecast",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"filteremptyrows, selectlocations, selectfulfillmentservices assert(expectTrue(not(isNull(Fulfillment_Location_ID))&&not(isNull(Fulfillment_Service))&&not(isNull(Forecast_Date)), false, 'nullvalues', null, 'Null Values Found In Mandatory Fields'),",
						"     expectExists(Fulfillment_Location_ID == location_code, false, 'locationexist', null, 'Location ID Not Found In Database'),",
						"     expectExists(Fulfillment_Service == service_name, false, 'profileexist', null, 'Fulfillment Service Does Not Exists In Database'),",
						"     expectTrue(isNull(presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
						"     expectTrue(numericalintegrity, false, 'numericalfieldintegrity', null, 'Numerical Fields Contains Non Numeric Values'),",
						"     expectTrue(nonduplicatedrow, false, 'duplicateddata', null, 'Duplicate Records Found In Upload')) ~> validations",
						"validations select(mapColumn(",
						"          {Fulfillment Location ID*} = Fulfillment_Location_ID,",
						"          {Fulfillment Service*} = Fulfillment_Service,",
						"          {Forecast Date*} = Forecast_Date,",
						"          {Forecast 1 Units} = Forecast_1_Units,",
						"          {Forecast 1 Orders} = Forecast_1_Orders,",
						"          {Forecast 2 Units} = Forecast_2_Units,",
						"          {Forecast 2 Orders} = Forecast_2_Orders,",
						"          {Units per Order} = Units_per_Order,",
						"          {Forecast Locked Date} = Forecast_Locked_Date,",
						"          file_name,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> reverserename",
						"reverserename derive(validation_errors = assertErrorMessages(),",
						"          transaction_id = toInteger($transaction_id),",
						"          sink_file_name = replace(file_name,'.xlsx','.txt')) ~> deriveerrors",
						"joinaggregaterror select(mapColumn(",
						"          {Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Forecast Date*},",
						"          {Forecast 1 Units},",
						"          {Forecast 1 Orders},",
						"          {Forecast 2 Units},",
						"          {Forecast 2 Orders},",
						"          {Units per Order},",
						"          {Forecast Locked Date},",
						"          file_name = reverserename@file_name,",
						"          validation_errors,",
						"          transaction_id,",
						"          sink_file_name,",
						"          errors_count,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectmainfields",
						"deriveerrors aggregate(groupBy(file_name),",
						"     errors_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
						"deriveerrors, aggregateerrors join(reverserename@file_name == aggregateerrors@file_name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinaggregaterror",
						"selectmainfields split(errors_count==0,",
						"     disjoint: false) ~> splitvalidatedrows@(validrows, validationfailedrows)",
						"filterrowswithvalidationerrors derive(failed_file_name = replace(replace($file_path,'/Upload/','/FailedTransactions/'),'.xlsx','.json'),",
						"          type = 'error',",
						"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedfilename",
						"numericalfieldintegritycheck select(mapColumn(",
						"          Fulfillment_Location_ID = {Fulfillment Location ID*},",
						"          Fulfillment_Service = {Fulfillment Service*},",
						"          Forecast_Date = {Forecast Date*},",
						"          Forecast_1_Units = {Forecast 1 Units},",
						"          Forecast_1_Orders = {Forecast 1 Orders},",
						"          Forecast_2_Units = {Forecast 2 Units},",
						"          Forecast_2_Orders = {Forecast 2 Orders},",
						"          Units_per_Order = {Units per Order},",
						"          Forecast_Locked_Date = {Forecast Locked Date},",
						"          file_name,",
						"          numericalintegrity,",
						"          record_id,",
						"          nonduplicatedrow",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> newchangenameforassert",
						"appendrecordid, selectlocations join({Fulfillment Location ID*} == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"jointransactionbuorglocation select(mapColumn(",
						"          location_id = locations@id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"jointransbuorgfservice select(mapColumn(",
						"          fulfillment_service_id = fulfillmentservices@id,",
						"          service_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectfulfillmentservices",
						"jointransbuorgfforecast derive(presence = 'true') ~> derivepresence",
						"joinlocations, selectfulfillmentservices join({Fulfillment Service*} == service_name,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinforecastservices",
						"joinfulfillmentforecast select(mapColumn(",
						"          file_name,",
						"          record_id,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectexistrecordcheck",
						"newchangenameforassert, selectexistrecordcheck join(newchangenameforassert@record_id == selectexistrecordcheck@record_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinexistrecordchech",
						"joinexistrecordchech select(mapColumn(",
						"          Fulfillment_Location_ID,",
						"          Fulfillment_Service,",
						"          Forecast_Date,",
						"          Forecast_1_Units,",
						"          Forecast_1_Orders,",
						"          Forecast_2_Units,",
						"          Forecast_2_Orders,",
						"          Units_per_Order,",
						"          Forecast_Locked_Date,",
						"          file_name = newchangenameforassert@file_name,",
						"          file_name = selectexistrecordcheck@file_name,",
						"          presence,",
						"          numericalintegrity,",
						"          nonduplicatedrow,",
						"          record_id = selectexistrecordcheck@record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcolsforassert",
						"joinforecastservices, derivepresence join(selectlocations@location_id == fulfillmentforecast@location_id",
						"     && selectfulfillmentservices@fulfillment_service_id == fulfillmentforecast@fulfillment_service_id",
						"     && {Forecast Date*} == toDate(toString(forecast_date)),",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinfulfillmentforecast",
						"detectduplicates derive(numericalintegrity = iif(isNull({Forecast 1 Units}),true(),not(isNull(toFloat({Forecast 1 Units})))) && iif(isNull({Forecast 1 Orders}),true(),not(isNull(toFloat({Forecast 1 Orders})))) && iif(isNull({Forecast 2 Units}),true(),not(isNull(toFloat({Forecast 2 Units})))) && iif(isNull({Forecast 2 Orders}),true(),not(isNull(toFloat({Forecast 2 Orders})))) && iif(isNull({Units per Order}),true(),not(isNull(toFloat({Units per Order}))))) ~> numericalfieldintegritycheck",
						"fulfillmentforecastuxstaging keyGenerate(output(record_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> appendrecordid",
						"importhistory filter(id == toInteger($transaction_id)) ~> filter1",
						"filter1 select(mapColumn(",
						"          id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"locations, selectimporthistory join(locations@business_unit_id == selectimporthistory@business_unit_id",
						"     && locations@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransactionbuorglocation",
						"fulfillmentservices, selectimporthistory join(fulfillmentservices@business_unit_id == selectimporthistory@business_unit_id",
						"     && fulfillmentservices@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransbuorgfservice",
						"fulfillmentforecast, selectimporthistory join(fulfillmentforecast@business_unit_id == selectimporthistory@business_unit_id",
						"     && fulfillmentforecast@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransbuorgfforecast",
						"appendrecordid window(over(file_name,",
						"          {Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Forecast Date*},",
						"          {Forecast Locked Date}),",
						"     asc(record_id, true),",
						"     nonduplicatedrow = rowNumber() == 1) ~> detectduplicates",
						"splitvalidatedrows@validationfailedrows filter(not(isNull(validation_errors))) ~> filterrowswithvalidationerrors",
						"selectcolsforassert filter(not(isNull(Fulfillment_Location_ID)) || not(isNull(Fulfillment_Service)) || not(isNull(Forecast_Date)) || not(isNull(Forecast_1_Units)) || not(isNull(Forecast_1_Orders)) || not(isNull(Forecast_2_Units)) || not(isNull(Forecast_Locked_Date)) || not(isNull(Units_per_Order))) ~> filteremptyrows",
						"splitvalidatedrows@validrows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          {Fulfillment Location ID*} as string,",
						"          {Fulfillment Service*} as string,",
						"          {Forecast Date*} as string,",
						"          {Forecast 1 Units} as string,",
						"          {Forecast 1 Orders} as string,",
						"          {Forecast 2 Units} as string,",
						"          {Forecast 2 Orders} as string,",
						"          {Units per Order} as string,",
						"          {Forecast Locked Date} as string",
						"     ),",
						"     rowUrlColumn:'sink_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          {Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Forecast Date*},",
						"          {Forecast 1 Units},",
						"          {Forecast 1 Orders},",
						"          {Forecast 2 Units},",
						"          {Forecast 2 Orders},",
						"          {Units per Order},",
						"          {Forecast Locked Date}",
						"     )) ~> ValidFulfillmentForecast",
						"derivedfilename sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/FULFILLMENT_FORECAST_UX_STAGING')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_services')]",
				"[concat(variables('factoryId'), '/datasets/fulfillment_forecast')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/FulfillmentForecastMain')]",
				"[concat(variables('factoryId'), '/datasets/FailedFulfillementRowsJson')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_validation_inventory')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "INVENTORY_UX",
								"type": "DatasetReference"
							},
							"name": "inventoryuxstaging",
							"description": "inventory ux staging"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "item",
							"description": "Import data from items"
						},
						{
							"dataset": {
								"referenceName": "inventory",
								"type": "DatasetReference"
							},
							"name": "inventory",
							"description": "Import data from inventory"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "INVENTORY_MAIN_UX",
								"type": "DatasetReference"
							},
							"name": "ValidInventoryDataLoad"
						},
						{
							"dataset": {
								"referenceName": "FailedInventoryRows",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "validations"
						},
						{
							"name": "reverserename"
						},
						{
							"name": "deriveerrors"
						},
						{
							"name": "selectmainfields"
						},
						{
							"name": "aggregateerrors"
						},
						{
							"name": "joinaggregaterror"
						},
						{
							"name": "splitvalidatedrows"
						},
						{
							"name": "derivedfilename"
						},
						{
							"name": "newchangenameforassert"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "selectitem"
						},
						{
							"name": "derivepresence"
						},
						{
							"name": "joinitem"
						},
						{
							"name": "selectexistrecordcheck"
						},
						{
							"name": "joinexistrecordchech"
						},
						{
							"name": "selectcolsforassert"
						},
						{
							"name": "joininventory"
						},
						{
							"name": "derivestocktypeid"
						},
						{
							"name": "numericfieldintegritycheck"
						},
						{
							"name": "appendrecordid"
						},
						{
							"name": "detectduplicates"
						},
						{
							"name": "filtertransactionrecord"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "join1"
						},
						{
							"name": "joinitemtransbuorg"
						},
						{
							"name": "joininventorytransbuorg"
						},
						{
							"name": "filterrowswithvalidationerrors"
						},
						{
							"name": "removeemptyrows"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/Inventory/211.xlsx'),",
						"     transaction_id as string ('211')",
						"}",
						"source(output(",
						"          {Item ID} as string,",
						"          {Location ID} as string,",
						"          {Stock Date} as string,",
						"          {Stock Quantity} as string,",
						"          {Reserved Quantity} as string,",
						"          {Available Quantity} as string,",
						"          {On Order ID} as string,",
						"          {On Order Due Date} as string,",
						"          {On Order Supplier Shipping Date} as string,",
						"          {On Order Promised Delivery Date} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> inventoryuxstaging",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> item",
						"source(output(",
						"          id as integer,",
						"          item_id as integer,",
						"          location_id as integer,",
						"          on_hand_stock_date as date,",
						"          on_hand_stock_quantity as float,",
						"          reserved_on_hold_stock_ as float,",
						"          available_stock as float,",
						"          lot_id as string,",
						"          on_order_due_date as date,",
						"          on_order_quantity_ as float,",
						"          purchase_order_status as float,",
						"          on_order_supplier_shipping_date as date,",
						"          on_order_promised_delivery_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          stock_type_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> inventory",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"removeemptyrows, selectlocations, selectitem assert(expectExists(selectcolsforassert@Location_ID == location_code, false, 'locationexist', null, 'Location ID Not Found In Database'),",
						"     expectExists(selectcolsforassert@Item_ID == item_code, false, 'itemexists', null, 'Item Specified Does Not Exists In Database'),",
						"     expectTrue(isNull(presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
						"     expectTrue(numericintegrity, false, 'numericfieldintegrity', null, 'Non numerical values exist in numerical fields'),",
						"     expectTrue(nonduplicatedrow, false, 'duplicated', null, 'Duplicate records found in upload')) ~> validations",
						"validations select(mapColumn(",
						"          {Item ID} = selectcolsforassert@Item_ID,",
						"          {Location ID} = selectcolsforassert@Location_ID,",
						"          {Stock Date},",
						"          {Stock Quantity},",
						"          {Reserved Quantity},",
						"          {Available Quantity},",
						"          {On Order ID},",
						"          {On Order Due Date},",
						"          {On Order Supplier Shipping Date},",
						"          {On Order Promised Delivery Date},",
						"          file_name,",
						"          presence,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> reverserename",
						"reverserename derive(validation_errors = assertErrorMessages(),",
						"          transaction_id = toInteger($transaction_id),",
						"          sink_file_name = replace(file_name,'.xlsx','.txt')) ~> deriveerrors",
						"joinaggregaterror select(mapColumn(",
						"          {Item ID},",
						"          {Location ID},",
						"          {Stock Date},",
						"          {Stock Quantity},",
						"          {Reserved Quantity},",
						"          {Available Quantity},",
						"          {On Order ID},",
						"          {On Order Due Date},",
						"          {On Order Supplier Shipping Date},",
						"          {On Order Promised Delivery Date},",
						"          file_name = reverserename@file_name,",
						"          presence,",
						"          validation_errors,",
						"          transaction_id,",
						"          sink_file_name,",
						"          file_name = aggregateerrors@file_name,",
						"          errors_count,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectmainfields",
						"deriveerrors aggregate(groupBy(file_name),",
						"     errors_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
						"deriveerrors, aggregateerrors join(reverserename@file_name == aggregateerrors@file_name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinaggregaterror",
						"selectmainfields split(errors_count==0,",
						"     disjoint: false) ~> splitvalidatedrows@(validrows, validationfailedrows)",
						"filterrowswithvalidationerrors derive(failed_file_name = replace(replace($file_path,'/Upload/','/FailedTransactions/'),'.xlsx','.json'),",
						"          type = 'error',",
						"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedfilename",
						"numericfieldintegritycheck select(mapColumn(",
						"          Item_ID = {Item ID},",
						"          Location_ID = {Location ID},",
						"          {Stock Date},",
						"          {Stock Quantity},",
						"          {Reserved Quantity},",
						"          {Available Quantity},",
						"          {On Order ID},",
						"          {On Order Due Date},",
						"          {On Order Supplier Shipping Date},",
						"          {On Order Promised Delivery Date},",
						"          file_name,",
						"          numericintegrity,",
						"          record_id,",
						"          nonduplicatedrow",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> newchangenameforassert",
						"derivestocktypeid, selectlocations join({Location ID} == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"join1 select(mapColumn(",
						"          location_id = locations@id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"joinitemtransbuorg select(mapColumn(",
						"          item_id = item@id,",
						"          item_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectitem",
						"joininventorytransbuorg derive(presence = 'true') ~> derivepresence",
						"joinlocations, selectitem join({Item ID} == item_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinitem",
						"joininventory select(mapColumn(",
						"          {Item ID},",
						"          {Location ID},",
						"          {Stock Date},",
						"          {Stock Quantity},",
						"          {Reserved Quantity},",
						"          {Available Quantity},",
						"          {On Order ID},",
						"          {On Order Due Date},",
						"          {On Order Supplier Shipping Date},",
						"          {On Order Promised Delivery Date},",
						"          file_name,",
						"          presence,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectexistrecordcheck",
						"newchangenameforassert, selectexistrecordcheck join(newchangenameforassert@record_id == selectexistrecordcheck@record_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinexistrecordchech",
						"joinexistrecordchech select(mapColumn(",
						"          Item_ID,",
						"          Location_ID,",
						"          {Stock Date} = newchangenameforassert@{Stock Date},",
						"          {Stock Quantity} = newchangenameforassert@{Stock Quantity},",
						"          {Reserved Quantity} = newchangenameforassert@{Reserved Quantity},",
						"          {Available Quantity} = newchangenameforassert@{Available Quantity},",
						"          {On Order ID} = newchangenameforassert@{On Order ID},",
						"          {On Order Due Date} = newchangenameforassert@{On Order Due Date},",
						"          {On Order Supplier Shipping Date} = newchangenameforassert@{On Order Supplier Shipping Date},",
						"          {On Order Promised Delivery Date} = newchangenameforassert@{On Order Promised Delivery Date},",
						"          file_name = newchangenameforassert@file_name,",
						"          presence,",
						"          numericintegrity,",
						"          nonduplicatedrow,",
						"          record_id = selectexistrecordcheck@record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcolsforassert",
						"joinitem, derivepresence join(selectlocations@location_id == inventory@location_id",
						"     && selectitem@item_id == inventory@item_id",
						"     && derivestocktypeid@stock_type_id == inventory@stock_type_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joininventory",
						"appendrecordid derive(stock_type_id = 1) ~> derivestocktypeid",
						"detectduplicates derive(numericintegrity = iif(isNull({Stock Quantity}),true(),not(isNull(toFloat({Stock Quantity})))) &&  iif(isNull({Reserved Quantity}),true(),not(isNull(toFloat({Reserved Quantity})))) && iif(isNull({Available Quantity}),true(),not(isNull(toFloat({Available Quantity}))))) ~> numericfieldintegritycheck",
						"inventoryuxstaging keyGenerate(output(record_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> appendrecordid",
						"appendrecordid window(over({Item ID},",
						"          {Location ID},",
						"          {Stock Date},",
						"          {On Order Supplier Shipping Date},",
						"          {On Order Promised Delivery Date},",
						"          {On Order Due Date},",
						"          {On Order ID}),",
						"     asc(record_id, true),",
						"     nonduplicatedrow = rowNumber() == 1) ~> detectduplicates",
						"importhistory filter(id == toInteger($transaction_id)) ~> filtertransactionrecord",
						"filtertransactionrecord select(mapColumn(",
						"          id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"locations, selectimporthistory join(locations@business_unit_id == selectimporthistory@business_unit_id",
						"     && locations@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"item, selectimporthistory join(item@business_unit_id == selectimporthistory@business_unit_id",
						"     && item@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinitemtransbuorg",
						"inventory, selectimporthistory join(inventory@business_unit_id == selectimporthistory@business_unit_id",
						"     && inventory@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joininventorytransbuorg",
						"splitvalidatedrows@validationfailedrows filter(not(isNull(validation_errors))) ~> filterrowswithvalidationerrors",
						"selectcolsforassert filter(not(isNull(Item_ID)) || not(isNull(Location_ID)) || not(isNull({Stock Date})) || not(isNull({Stock Quantity})) || not(isNull({Reserved Quantity})) || not(isNull({Available Quantity})) || not(isNull({On Order ID})) || not(isNull({On Order Due Date})) || not(isNull({On Order Supplier Shipping Date})) || not(isNull({On Order Promised Delivery Date}))) ~> removeemptyrows",
						"splitvalidatedrows@validrows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          {Item ID} as string,",
						"          {Location ID} as string,",
						"          {Stock Date} as string,",
						"          {Stock Quantity} as string,",
						"          {Reserved Quantity} as string,",
						"          {Available Quantity} as string,",
						"          {On Order ID} as string,",
						"          {On Order Due Date} as string,",
						"          {On Order Supplier Shipping Date} as string,",
						"          {On Order Promised Delivery Date} as string",
						"     ),",
						"     rowUrlColumn:'sink_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          {Item ID},",
						"          {Location ID},",
						"          {Stock Date},",
						"          {Stock Quantity},",
						"          {Reserved Quantity},",
						"          {Available Quantity},",
						"          {On Order ID},",
						"          {On Order Due Date},",
						"          {On Order Supplier Shipping Date},",
						"          {On Order Promised Delivery Date}",
						"     )) ~> ValidInventoryDataLoad",
						"derivedfilename sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/INVENTORY_UX')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/item')]",
				"[concat(variables('factoryId'), '/datasets/inventory')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/INVENTORY_MAIN_UX')]",
				"[concat(variables('factoryId'), '/datasets/FailedInventoryRows')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_validation_location')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "LOCATION_UX_STAGING",
								"type": "DatasetReference"
							},
							"name": "locationstagingux"
						},
						{
							"dataset": {
								"referenceName": "location_type",
								"type": "DatasetReference"
							},
							"name": "locationtype"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "LocationsMain",
								"type": "DatasetReference"
							},
							"name": "ValidLocations"
						},
						{
							"dataset": {
								"referenceName": "FailedRowsLocation",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "validations"
						},
						{
							"name": "reverserename"
						},
						{
							"name": "deriveerrors"
						},
						{
							"name": "selectmainfields"
						},
						{
							"name": "aggregateerrors"
						},
						{
							"name": "joinaggregaterror"
						},
						{
							"name": "splitvalidatedrows"
						},
						{
							"name": "derivedfilename"
						},
						{
							"name": "newchangenameforassert"
						},
						{
							"name": "addcolpresence"
						},
						{
							"name": "selectlocation"
						},
						{
							"name": "derivedColumn"
						},
						{
							"name": "filtertransaction"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "appendrecordid"
						},
						{
							"name": "detectduplicates"
						},
						{
							"name": "selectlocationtypes"
						},
						{
							"name": "joinbuorglocations"
						},
						{
							"name": "filterrowswithvalidationerrors"
						},
						{
							"name": "joinlocationstable"
						},
						{
							"name": "filteremptyrows"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/Location/36.xlsx'),",
						"     transaction_id as string ('36')",
						"}",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          {Location ID*} as string,",
						"          {Location Name} as string,",
						"          Address as string,",
						"          City as string,",
						"          State as string,",
						"          Zip as string,",
						"          Country as string,",
						"          Longitude as string,",
						"          Latitude as string,",
						"          {Location Status} as string,",
						"          {Location Type} as string,",
						"          {Daily Throughput} as string,",
						"          {Storage Capacity} as string,",
						"          {Inbound Handling Cost} as string,",
						"          {Outbound Handling Cost} as string,",
						"          {Inbound Processing Time} as string,",
						"          {Outbound Processing Time} as string,",
						"          {Transfer Inbound Processing Time} as string,",
						"          {Transfer Outbound Processing Time} as string,",
						"          {Transfer Inbound Handling Cost} as string,",
						"          {Transfer Outbound Handling Cost} as string,",
						"          {Units per Hour} as string,",
						"          {Max FTE Regular Hours} as string,",
						"          {Min FTE Regular Hours} as string,",
						"          {Max Temp Regular Hours} as string,",
						"          {Min Temp Regular Hours} as string,",
						"          {Max FTE Overtime Hours} as string,",
						"          {Regular FTE Wage} as string,",
						"          {Regular Temp Wage} as string,",
						"          {Overtime FTE Wage} as string,",
						"          {Overtime Temp Wage} as string,",
						"          {FTE Staff Count} as string,",
						"          {Temp Staff Count} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     wildcardPaths:[($file_path)]) ~> locationstagingux",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          description as string,",
						"          created_date as date,",
						"          updated_date as date,",
						"          display_icon as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locationtype",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"filteremptyrows, selectlocationtypes, selectlocation assert(expectTrue(isNull(newchangenameforassert@presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
						"     expectExists(Location_Type == name, false, 'checklocationtype', null, 'Location Type Not Found'),",
						"     expectTrue(numericalfieldintegrity, false, 'numericalintegrity', null, 'Numerical fields contain non numeric values'),",
						"     expectUnique(Location_ID, false, 'duplicateddata', null, 'Duplicate Records Found In The Upload')) ~> validations",
						"validations select(mapColumn(",
						"          {Location ID*} = Location_ID,",
						"          {Location Name},",
						"          Address,",
						"          City,",
						"          State,",
						"          Zip,",
						"          Country,",
						"          Longitude,",
						"          Latitude,",
						"          {Location Status},",
						"          {Location Type} = Location_Type,",
						"          {Daily Throughput},",
						"          {Storage Capacity},",
						"          {Inbound Handling Cost},",
						"          {Outbound Handling Cost},",
						"          {Inbound Processing Time},",
						"          {Outbound Processing Time},",
						"          {Transfer Inbound Processing Time},",
						"          {Transfer Outbound Processing Time},",
						"          {Transfer Inbound Handling Cost},",
						"          {Transfer Outbound Handling Cost},",
						"          {Units per Hour},",
						"          {Max FTE Regular Hours},",
						"          {Min FTE Regular Hours},",
						"          {Max Temp Regular Hours},",
						"          {Min Temp Regular Hours},",
						"          {Regular FTE Wage},",
						"          {Regular Temp Wage},",
						"          {Overtime FTE Wage},",
						"          {Overtime Temp Wage},",
						"          {FTE Staff Count},",
						"          {Temp Staff Count},",
						"          file_name,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> reverserename",
						"reverserename derive(validation_errors = assertErrorMessages(),",
						"          transaction_id = toInteger($transaction_id),",
						"          sink_file_name = replace(file_name,'.xlsx','.txt')) ~> deriveerrors",
						"joinaggregaterror select(mapColumn(",
						"          {Location ID*},",
						"          {Location Name},",
						"          Address,",
						"          City,",
						"          State,",
						"          Zip,",
						"          Country,",
						"          Longitude,",
						"          Latitude,",
						"          {Location Status},",
						"          {Location Type},",
						"          {Daily Throughput},",
						"          {Storage Capacity},",
						"          {Inbound Handling Cost},",
						"          {Outbound Handling Cost},",
						"          {Inbound Processing Time},",
						"          {Outbound Processing Time},",
						"          {Transfer Inbound Processing Time},",
						"          {Transfer Outbound Processing Time},",
						"          {Transfer Inbound Handling Cost},",
						"          {Transfer Outbound Handling Cost},",
						"          {Units per Hour},",
						"          {Max FTE Regular Hours},",
						"          {Min FTE Regular Hours},",
						"          {Max Temp Regular Hours},",
						"          {Min Temp Regular Hours},",
						"          {Regular FTE Wage},",
						"          {Regular Temp Wage},",
						"          {Overtime FTE Wage},",
						"          {Overtime Temp Wage},",
						"          {FTE Staff Count},",
						"          {Temp Staff Count},",
						"          file_name = reverserename@file_name,",
						"          validation_errors,",
						"          transaction_id,",
						"          sink_file_name,",
						"          errors_count,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> selectmainfields",
						"deriveerrors aggregate(groupBy(file_name),",
						"     errors_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
						"deriveerrors, aggregateerrors join(reverserename@file_name == aggregateerrors@file_name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinaggregaterror",
						"selectmainfields split(errors_count==0,",
						"     disjoint: false) ~> splitvalidatedrows@(validrows, validationfailedrows)",
						"filterrowswithvalidationerrors derive(failed_file_name = replace(replace($file_path,'/Upload/','/FailedTransactions/'),'.xlsx','.json'),",
						"          type = 'error',",
						"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedfilename",
						"derivedColumn select(mapColumn(",
						"          Location_ID = {Location ID*},",
						"          {Location Name},",
						"          Address,",
						"          City,",
						"          State,",
						"          Zip,",
						"          Country,",
						"          Longitude,",
						"          Latitude,",
						"          {Location Status},",
						"          Location_Type = {Location Type},",
						"          {Daily Throughput},",
						"          {Storage Capacity},",
						"          {Inbound Handling Cost},",
						"          {Outbound Handling Cost},",
						"          {Inbound Processing Time},",
						"          {Outbound Processing Time},",
						"          {Transfer Inbound Processing Time},",
						"          {Transfer Outbound Processing Time},",
						"          {Transfer Inbound Handling Cost},",
						"          {Transfer Outbound Handling Cost},",
						"          {Units per Hour},",
						"          {Max FTE Regular Hours},",
						"          {Min FTE Regular Hours},",
						"          {Max Temp Regular Hours},",
						"          {Min Temp Regular Hours},",
						"          {Max FTE Overtime Hours},",
						"          {Regular FTE Wage},",
						"          {Regular Temp Wage},",
						"          {Overtime FTE Wage},",
						"          {Overtime Temp Wage},",
						"          {FTE Staff Count},",
						"          {Temp Staff Count},",
						"          file_name,",
						"          numericalfieldintegrity,",
						"          nonduplicatedrow,",
						"          record_id,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> newchangenameforassert",
						"joinbuorglocations derive(presence = 'true') ~> addcolpresence",
						"addcolpresence select(mapColumn(",
						"          location_code,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocation",
						"joinlocationstable derive(file_name = $file_path,",
						"          numericalfieldintegrity = iif(isNull({Daily Throughput}),true(),not(isNull(toFloat({Daily Throughput})))) && iif(isNull({Storage Capacity}),true(),not(isNull(toFloat({Storage Capacity})))) && iif(isNull({Inbound Handling Cost}),true(),not(isNull(toFloat({Inbound Handling Cost})))) && iif(isNull({Outbound Handling Cost}),true(),not(isNull(toFloat({Outbound Handling Cost})))) && iif(isNull({Transfer Inbound Handling Cost}),true(),not(isNull(toFloat({Transfer Inbound Handling Cost})))) && iif(isNull({Transfer Outbound Handling Cost}),true(),not(isNull(toFloat({Transfer Outbound Handling Cost})))) && iif(isNull({Units per Hour}),true(),not(isNull(toFloat({Units per Hour})))) && iif(isNull({Min FTE Regular Hours}),true(),not(isNull(toFloat({Min FTE Regular Hours})))) && iif(isNull({Max FTE Regular Hours}),true(),not(isNull(toFloat({Max FTE Regular Hours})))) && iif(isNull({Min Temp Regular Hours}),true(),not(isNull(toFloat({Min Temp Regular Hours})))) && iif(isNull({Max Temp Regular Hours}),true(),not(isNull(toFloat({Max Temp Regular Hours})))) && iif(isNull({Max FTE Overtime Hours}),true(),not(isNull(toFloat({Max FTE Overtime Hours})))) && iif(isNull({Regular FTE Wage}),true(),not(isNull(toFloat({Regular FTE Wage})))) && iif(isNull({Regular Temp Wage}),true(),not(isNull(toFloat({Regular Temp Wage})))) && iif(isNull({Overtime FTE Wage}),true(),not(isNull(toFloat({Overtime FTE Wage})))) && iif(isNull({Overtime Temp Wage}),true(),not(isNull(toFloat({Overtime Temp Wage})))) && iif(isNull({FTE Staff Count}),true(),not(isNull(toFloat({FTE Staff Count})))) && iif(isNull({Temp Staff Count}),true(),not(isNull(toFloat({Temp Staff Count}))))) ~> derivedColumn",
						"importhistory filter(id == toInteger($transaction_id)) ~> filtertransaction",
						"filtertransaction select(mapColumn(",
						"          id,",
						"          original_file_name,",
						"          user_id,",
						"          status_enum_value_id,",
						"          processed_time,",
						"          errors,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"locationstagingux keyGenerate(output(record_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> appendrecordid",
						"appendrecordid window(over({Location ID*}),",
						"     asc(record_id, true),",
						"     nonduplicatedrow = rowNumber() == 1) ~> detectduplicates",
						"locationtype select(mapColumn(",
						"          id,",
						"          name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocationtypes",
						"locations, selectimporthistory join(locations@business_unit_id == selectimporthistory@business_unit_id",
						"     && locations@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinbuorglocations",
						"splitvalidatedrows@validationfailedrows filter(not(isNull(validation_errors))) ~> filterrowswithvalidationerrors",
						"detectduplicates, selectlocation join({Location ID*} == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocationstable",
						"newchangenameforassert filter(not(isNull(Location_ID)) || not(isNull({Location Name})) || not(isNull(Address)) || not(isNull(City)) || not(isNull(State)) || not(isNull(Zip)) || not(isNull(Longitude)) || not(isNull(Latitude)) || not(isNull({Location Status})) || not(isNull(Location_Type)) || not(isNull({Daily Throughput})) || not(isNull({Storage Capacity})) || not(isNull({Inbound Handling Cost})) || not(isNull({Outbound Handling Cost})) || not(isNull({Inbound Processing Time})) || not(isNull({Outbound Processing Time})) || not(isNull({Transfer Inbound Processing Time})) || not(isNull({Transfer Outbound Processing Time})) || not(isNull({Transfer Inbound Handling Cost})) || not(isNull({Units per Hour})) || not(isNull({Max FTE Regular Hours})) || not(isNull({Min FTE Regular Hours})) || not(isNull({Max Temp Regular Hours})) || not(isNull({Min Temp Regular Hours})) || not(isNull({Max FTE Overtime Hours})) || not(isNull({Regular FTE Wage})) || not(isNull({Regular Temp Wage})) || not(isNull({Overtime FTE Wage})) || not(isNull({Overtime Temp Wage})) || not(isNull({FTE Staff Count})) || not(isNull({Temp Staff Count}))) ~> filteremptyrows",
						"splitvalidatedrows@validrows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          {Location ID*} as string,",
						"          {Location Name} as string,",
						"          Address as string,",
						"          City as string,",
						"          State as string,",
						"          Zip as string,",
						"          Country as string,",
						"          Longitude as string,",
						"          Latitude as string,",
						"          {Location Status} as string,",
						"          {Location Type} as string,",
						"          {Daily Throughput} as string,",
						"          {Storage Capacity} as string,",
						"          {Inbound Handling Cost} as string,",
						"          {Outbound Handling Cost} as string,",
						"          {Inbound Processing Time} as string,",
						"          {Outbound Processing Time} as string,",
						"          {Transfer Inbound Processing Time} as string,",
						"          {Transfer Outbound Processing Time} as string,",
						"          {Transfer Inbound Handling Cost} as string,",
						"          {Transfer Outbound Handling Cost} as string,",
						"          {Units per Hour} as string,",
						"          {Max FTE Regular Hours} as string,",
						"          {Min FTE Regular Hours} as string,",
						"          {Max Temp Regular Hours} as string,",
						"          {Min Temp Regular Hours} as string,",
						"          {Regular FTE Wage} as string,",
						"          {Regular Temp Wage} as string,",
						"          {Overtime FTE Wage} as string,",
						"          {Overtime Temp Wage} as string,",
						"          {FTE Staff Count} as string,",
						"          {Temp Staff Count} as string",
						"     ),",
						"     rowUrlColumn:'sink_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          {Location ID*},",
						"          {Location Name},",
						"          Address,",
						"          City,",
						"          State,",
						"          Zip,",
						"          Country,",
						"          Longitude,",
						"          Latitude,",
						"          {Location Status},",
						"          {Location Type},",
						"          {Daily Throughput},",
						"          {Storage Capacity},",
						"          {Inbound Handling Cost},",
						"          {Outbound Handling Cost},",
						"          {Inbound Processing Time},",
						"          {Outbound Processing Time},",
						"          {Transfer Inbound Processing Time},",
						"          {Transfer Outbound Processing Time},",
						"          {Transfer Inbound Handling Cost},",
						"          {Transfer Outbound Handling Cost},",
						"          {Units per Hour},",
						"          {Max FTE Regular Hours},",
						"          {Min FTE Regular Hours},",
						"          {Max Temp Regular Hours},",
						"          {Min Temp Regular Hours},",
						"          {Regular FTE Wage},",
						"          {Regular Temp Wage},",
						"          {Overtime FTE Wage},",
						"          {Overtime Temp Wage},",
						"          {FTE Staff Count},",
						"          {Temp Staff Count}",
						"     )) ~> ValidLocations",
						"derivedfilename sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/LOCATION_UX_STAGING')]",
				"[concat(variables('factoryId'), '/datasets/location_type')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/LocationsMain')]",
				"[concat(variables('factoryId'), '/datasets/FailedRowsLocation')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_validation_location_staffing')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LOCATION_STAFFING_UX",
								"type": "DatasetReference"
							},
							"name": "locationstaffingux"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "operationalprofile",
								"type": "DatasetReference"
							},
							"name": "operationalprofile"
						},
						{
							"dataset": {
								"referenceName": "enum_values",
								"type": "DatasetReference"
							},
							"name": "enumvalues"
						},
						{
							"dataset": {
								"referenceName": "operational_calendar",
								"type": "DatasetReference"
							},
							"name": "operationalcalendar"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "operational_calendar",
								"type": "DatasetReference"
							},
							"name": "ValidLocationStaffingRows"
						},
						{
							"dataset": {
								"referenceName": "FailedLocationStaffingJson",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "validations"
						},
						{
							"name": "reverserename"
						},
						{
							"name": "deriveerrors"
						},
						{
							"name": "selectmainfields"
						},
						{
							"name": "aggregateerrors"
						},
						{
							"name": "joinaggregaterror"
						},
						{
							"name": "splitvalidatedrows"
						},
						{
							"name": "derivedfilename"
						},
						{
							"name": "newchangenameforassert"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "selectoperationalprofile"
						},
						{
							"name": "filterenumvalues"
						},
						{
							"name": "selectenumvalues"
						},
						{
							"name": "derivepresence"
						},
						{
							"name": "joinprofile"
						},
						{
							"name": "joinenumvalues"
						},
						{
							"name": "joinoperationalcalendar"
						},
						{
							"name": "selectexistrecordcheck"
						},
						{
							"name": "joinopcalendarcheck"
						},
						{
							"name": "selectcolsforassert"
						},
						{
							"name": "findduplicates"
						},
						{
							"name": "selecttransaction"
						},
						{
							"name": "joinimporthistoryop"
						},
						{
							"name": "joinimporthistoryopcalendar"
						},
						{
							"name": "jointransactionlocation"
						},
						{
							"name": "appendrecordid"
						},
						{
							"name": "filterrowswithvalidationerrors"
						},
						{
							"name": "filteremptyrows"
						},
						{
							"name": "selectopcalendarloadtable"
						},
						{
							"name": "joinloadtablebranch"
						},
						{
							"name": "joinihvalidation"
						},
						{
							"name": "derivedColumnimphistory"
						},
						{
							"name": "selectopcalendar"
						},
						{
							"name": "datatypederviations"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/LocationStaffing/510.xlsx'),",
						"     transaction_id as string ('510')",
						"}",
						"source(output(",
						"          {Profile Name*} as string,",
						"          {Location ID*} as string,",
						"          {Date*} as date,",
						"          {Metric Name*} as string,",
						"          {Value*} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> locationstaffingux",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> operationalprofile",
						"source(output(",
						"          id as integer,",
						"          enum_type_id as integer,",
						"          value_id as integer,",
						"          value as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> enumvalues",
						"source(output(",
						"          id as integer,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          location_id as integer,",
						"          date as date,",
						"          location_metric_value as decimal(0,0),",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          enum_value_id as integer,",
						"          enum_type_id as integer,",
						"          operational_profile_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> operationalcalendar",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"filteremptyrows, selectlocations, selectoperationalprofile, selectenumvalues assert(expectTrue(not(isNull(Profile_Name))&&not(isNull(selectcolsforassert@Location_ID))&&not(isNull(Date))&&not(isNull(Metric_Name))&&not(isNull(selectcolsforassert@Value)), false, 'nullvalues', null, 'Null Values Found In Mandatory Fields'),",
						"     expectExists(selectcolsforassert@Location_ID == location_code, false, 'locationexist', null, 'Location ID Not Found In Database'),",
						"     expectExists(Profile_Name == name, false, 'profileexist', null, 'Profile Details Not Found In Database'),",
						"     expectExists(Metric_Name == selectenumvalues@value, false, 'metrictype', null, 'Metric Type Specified Not Found'),",
						"     expectTrue(isNull(presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
						"     expectTrue(nonduplicatedrow, false, 'duplicaterecords', null, 'Duplicate Records Uploaded'),",
						"     expectTrue(toDecimal(selectcolsforassert@Value) >= 0, false, 'valueoutofrange', null, 'Value Out Of Range')) ~> validations",
						"validations select(mapColumn(",
						"          {Profile Name*} = Profile_Name,",
						"          {Location ID*} = selectcolsforassert@Location_ID,",
						"          {Date*} = Date,",
						"          {Metric Name*} = Metric_Name,",
						"          {Value*} = selectcolsforassert@Value,",
						"          file_name,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> reverserename",
						"reverserename derive(validation_errors = assertErrorMessages(),",
						"          transaction_id = toInteger($transaction_id),",
						"          sink_file_name = replace(file_name,'.xlsx','.txt'),",
						"          file_name_failed_rows = replace(file_name,'/Upload/','/FailedTransactions/')) ~> deriveerrors",
						"joinaggregaterror select(mapColumn(",
						"          {Profile Name*},",
						"          {Location ID*},",
						"          {Date*},",
						"          {Metric_Name*} = {Metric Name*},",
						"          {Value*},",
						"          file_name = reverserename@file_name,",
						"          validation_errors,",
						"          transaction_id,",
						"          sink_file_name,",
						"          file_name_failed_rows,",
						"          file_name = aggregateerrors@file_name,",
						"          errors_count,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectmainfields",
						"deriveerrors aggregate(groupBy(file_name),",
						"     errors_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
						"deriveerrors, aggregateerrors join(reverserename@file_name == aggregateerrors@file_name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinaggregaterror",
						"selectmainfields split(errors_count==0,",
						"     disjoint: false) ~> splitvalidatedrows@(validrows, validationfailedrows)",
						"filterrowswithvalidationerrors derive(failed_file_name = replace(replace($file_path,'/Upload/','/FailedTransactions/'),'.xlsx','.json'),",
						"          type = 'error',",
						"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedfilename",
						"appendrecordid select(mapColumn(",
						"          Profile_Name = {Profile Name*},",
						"          Location_ID = {Location ID*},",
						"          Date = {Date*},",
						"          Metric_Name = {Metric Name*},",
						"          Value = {Value*},",
						"          file_name,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> newchangenameforassert",
						"joinihvalidation, selectlocations join({Location ID*} == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"jointransactionlocation select(mapColumn(",
						"          location_id = locations@id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"joinimporthistoryop select(mapColumn(",
						"          profile_id = operationalprofile@id,",
						"          name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectoperationalprofile",
						"enumvalues filter(enum_type_id==4) ~> filterenumvalues",
						"filterenumvalues select(mapColumn(",
						"          enum_type_id,",
						"          value_id,",
						"          value",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectenumvalues",
						"joinimporthistoryopcalendar derive(presence = 'true') ~> derivepresence",
						"joinlocations, selectoperationalprofile join({Profile Name*} == name,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinprofile",
						"joinprofile, selectenumvalues join({Metric Name*} == value,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinenumvalues",
						"joinenumvalues, selectopcalendar join(profile_id == operational_profile_id",
						"     && selectlocations@location_id == selectopcalendar@location_id",
						"     && {Date*} == toDate(toString(date))",
						"     && value_id == enum_value_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinoperationalcalendar",
						"joinoperationalcalendar select(mapColumn(",
						"          presence,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectexistrecordcheck",
						"findduplicates, selectexistrecordcheck join(newchangenameforassert@record_id == selectexistrecordcheck@record_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinopcalendarcheck",
						"joinopcalendarcheck select(mapColumn(",
						"          Profile_Name,",
						"          Location_ID,",
						"          Date,",
						"          Metric_Name,",
						"          Value,",
						"          file_name,",
						"          presence,",
						"          nonduplicatedrow,",
						"          record_id = newchangenameforassert@record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcolsforassert",
						"newchangenameforassert window(over(Profile_Name,",
						"          Location_ID,",
						"          Metric_Name,",
						"          Date),",
						"     asc(file_name, true),",
						"     nonduplicatedrow = rowNumber() == 1) ~> findduplicates",
						"importhistory filter(id == toInteger($transaction_id)) ~> selecttransaction",
						"operationalprofile, selecttransaction join(operationalprofile@business_unit_id == importhistory@business_unit_id",
						"     && operationalprofile@organization_id == importhistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistoryop",
						"operationalcalendar, selecttransaction join(operationalcalendar@business_unit_id == importhistory@business_unit_id",
						"     && operationalcalendar@organization_id == importhistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistoryopcalendar",
						"locations, selecttransaction join(locations@business_unit_id == importhistory@business_unit_id",
						"     && locations@organization_id == importhistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransactionlocation",
						"locationstaffingux keyGenerate(output(record_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> appendrecordid",
						"splitvalidatedrows@validationfailedrows filter(not(isNull(validation_errors))) ~> filterrowswithvalidationerrors",
						"selectcolsforassert filter(not(isNull(Profile_Name)) || not(isNull(Location_ID)) || not(isNull(Date)) || not(isNull(Metric_Name)) || not(isNull(Value))) ~> filteremptyrows",
						"joinoperationalcalendar select(mapColumn(",
						"          profile_id,",
						"          location_id = selectlocations@location_id,",
						"          {Date*},",
						"          enum_type_id = selectenumvalues@enum_type_id,",
						"          value_id,",
						"          {Value*},",
						"          file_name,",
						"          record_id,",
						"          original_file_name,",
						"          business_unit_id = importhistory@business_unit_id,",
						"          organization_id = importhistory@organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectopcalendarloadtable",
						"splitvalidatedrows@validrows, selectopcalendarloadtable join(splitvalidatedrows@validrows@record_id == selectopcalendarloadtable@record_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinloadtablebranch",
						"derivedColumnimphistory, selecttransaction join(transaction_id == id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinihvalidation",
						"appendrecordid derive(transaction_id = toInteger($transaction_id)) ~> derivedColumnimphistory",
						"derivepresence select(mapColumn(",
						"          id = operationalcalendar@id,",
						"          business_unit_id = operationalcalendar@business_unit_id,",
						"          organization_id = operationalcalendar@organization_id,",
						"          location_id,",
						"          date,",
						"          location_metric_value,",
						"          created_date,",
						"          updated_date,",
						"          enum_value_id,",
						"          enum_type_id,",
						"          operational_profile_id,",
						"          id = importhistory@id,",
						"          original_file_name,",
						"          user_id,",
						"          status_enum_value_id,",
						"          processed_time,",
						"          errors,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectopcalendar",
						"joinloadtablebranch derive({Value*} = toDecimal(splitvalidatedrows@validrows@{Value*})) ~> datatypederviations",
						"datatypederviations sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          location_id as integer,",
						"          date as date,",
						"          location_metric_value as decimal(0,0),",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          enum_value_id as integer,",
						"          enum_type_id as integer,",
						"          operational_profile_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          business_unit_id,",
						"          organization_id,",
						"          location_id,",
						"          date = splitvalidatedrows@validrows@{Date*},",
						"          location_metric_value = {Value*},",
						"          enum_value_id = value_id,",
						"          enum_type_id,",
						"          operational_profile_id = profile_id",
						"     ),",
						"     preCommands: [],",
						"     postCommands: []) ~> ValidLocationStaffingRows",
						"derivedfilename sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/LOCATION_STAFFING_UX')]",
				"[concat(variables('factoryId'), '/datasets/locations')]",
				"[concat(variables('factoryId'), '/datasets/operationalprofile')]",
				"[concat(variables('factoryId'), '/datasets/enum_values')]",
				"[concat(variables('factoryId'), '/datasets/operational_calendar')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/FailedLocationStaffingJson')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_zone')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Data flow edited on 2023-08-08 on bringing in attributes from filename and using lookup to fetch organization_id and business_unit_id",
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ZONE_RAW",
								"type": "DatasetReference"
							},
							"name": "RawDataForZone",
							"description": "source data stored in datalake-\"radial-demo-data\" for populating pfp.zone table\n"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyTable",
							"description": "Data from tenant_heirarchy_table"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "zone",
								"type": "DatasetReference"
							},
							"name": "WriteToDatabase",
							"description": "Write transformed data to pfp.zone table"
						}
					],
					"transformations": [
						{
							"name": "DerivingAttributes",
							"description": "Deriving attributes for fields like origin_start, origin_end, business_unit_name from filename, static value for delivery_partner_id"
						},
						{
							"name": "MappingColumns",
							"description": "Final step in data transformation to select specific columns, renaming certain columns to match the zone table schema"
						},
						{
							"name": "SelectColumnsHeirarchy",
							"description": "Selecting specific columns required for downstream actviities"
						},
						{
							"name": "JoinHeirarchyTable",
							"description": "Joins heirarchy table for extracting business_unit_id and organization_id"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Dest. ZIP} as string,",
						"          {Ground - ZONE} as string,",
						"          {3 Day Select} as string,",
						"          {2nd Day Air} as string,",
						"          {2nd Day Air A.M.} as string,",
						"          {Next Day Air Saver} as string,",
						"          {Next Day Air} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: true,",
						"     rowUrlColumn: 'file_name') ~> RawDataForZone",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyTable",
						"RawDataForZone derive(origin_start = split(split(file_name,\"/\")[4],\"_\")[2],",
						"          origin_end = split(split(file_name,\"/\")[4],\"_\")[2],",
						"          delivery_partner_id = 2,",
						"          destination_end = {Dest. ZIP},",
						"          business_unit_name = split(split(file_name,\"/\")[4],\"_\")[1],",
						"          organization_id := \"8078acfb-eca6-4708-b197-694f50a24c92\",",
						"          business_unit_id := \"994dc35f-7eba-4f6e-918b-7bd311482d7b\",",
						"          local1 := \"8078acfb-eca6-4708-b197-694f50a24c92\") ~> DerivingAttributes",
						"JoinHeirarchyTable select(mapColumn(",
						"          zone = {Ground - ZONE},",
						"          delivery_partner_id,",
						"          origin_start,",
						"          origin_end,",
						"          destination_start = {Dest. ZIP},",
						"          destination_end,",
						"          business_unit_id = id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> MappingColumns",
						"filter1 select(mapColumn(",
						"          id,",
						"          name,",
						"          parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumnsHeirarchy",
						"DerivingAttributes, SelectColumnsHeirarchy join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinHeirarchyTable",
						"MappingColumns alterRow(upsertIf(true())) ~> AlterRow1",
						"TenantHeirarchyTable filter(tenant_hierarchy_type==3) ~> filter1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          zone as string,",
						"          delivery_partner_id as integer,",
						"          origin_start as string,",
						"          origin_end as string,",
						"          destination_start as string,",
						"          destination_end as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['zone','origin_start','destination_start'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     preCommands: [],",
						"     postCommands: []) ~> WriteToDatabase"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ZONE_RAW')]",
				"[concat(variables('factoryId'), '/datasets/tenant_heirarchy_table')]",
				"[concat(variables('factoryId'), '/datasets/zone')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dffailurecapture')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "failurestringdemandforecast",
								"type": "DatasetReference"
							},
							"name": "failure"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistorylookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "notification",
								"type": "DatasetReference"
							},
							"name": "notification"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "parseerrrors"
						},
						{
							"name": "derivenotificationerrors"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "select1"
						},
						{
							"name": "selectimporthistory"
						}
					],
					"scriptLines": [
						"parameters{",
						"     transaction_id as string ('646'),",
						"     single_quote as string ('\\''),",
						"     file_path as string ('/DEV/Upload/CurrentBacklog/646.xlsx')",
						"}",
						"source(output(",
						"          Column_1 as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: true,",
						"     purgeFiles: true,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[(replace(replace($file_path, '/Upload/', '/FailedTransactions/'),'.xlsx','.json'))]) ~> failure",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistorylookup",
						"failure derive(id = toInteger($transaction_id),",
						"          errors = replace(concat('{\\'error\\':[',replace(concat(replace(Column_1,'}','},'),']'),',]',']'),'}'),$single_quote,'\"'),",
						"          status_enum_value_id = 3,",
						"          errors_formatted = replace(replace(concat('[',replace(Column_1,'}','},'),']'),',]',']'),'},\\n]','}]')) ~> derivedColumn1",
						"parseerrrors alterRow(updateIf(true())) ~> AlterRow1",
						"derivedColumn1 derive(errors = errors_formatted) ~> parseerrrors",
						"parseerrrors derive(run_status = iif(status_enum_value_id==3,'Failed',iif(status_enum_value_id==2,'Complete','In Progress')),",
						"          notification_type = 'Pipeline Status',",
						"          feature_id = 32) ~> derivenotificationerrors",
						"derivenotificationerrors, importhistorylookup join(derivedColumn1@id == importhistorylookup@id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory select(mapColumn(",
						"          run_id = derivedColumn1@id,",
						"          description = original_file_name,",
						"          run_status,",
						"          notification_type,",
						"          feature_id,",
						"          user_id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"importhistorylookup select(mapColumn(",
						"          id,",
						"          original_file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id,",
						"          status_enum_value_id,",
						"          errors = errors_formatted",
						"     )) ~> importhistory",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          run_id as integer,",
						"          run_status as string,",
						"          description as string,",
						"          user_id as string,",
						"          notification_status as string,",
						"          notification_type as string,",
						"          feature_id as integer,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          run_id,",
						"          run_status,",
						"          description,",
						"          user_id,",
						"          notification_type,",
						"          feature_id,",
						"          business_unit_id,",
						"          organization_id",
						"     )) ~> notification"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/failurestringdemandforecast')]",
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/notification')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/importhistorystatusinprogress')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistorysink"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     transaction_id as string ('200'),",
						"     quote as string ('\\'')",
						"}",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          template_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (concat('SELECT * FROM pfp.import_history WHERE id = ',$transaction_id)),",
						"     format: 'query') ~> importhistory",
						"importhistory derive(status_enum_value_id = 1,",
						"          errors = 'null') ~> derivedColumn1",
						"select1 alterRow(updateIf(true())) ~> AlterRow1",
						"derivedColumn1 select(mapColumn(",
						"          id,",
						"          status_enum_value_id,",
						"          errors",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id,",
						"          status_enum_value_id,",
						"          errors",
						"     )) ~> importhistorysink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/importhistory')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/importhistorystatusupdate')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistorysink"
						},
						{
							"dataset": {
								"referenceName": "notification",
								"type": "DatasetReference"
							},
							"name": "notification"
						}
					],
					"transformations": [
						{
							"name": "filtertransaction"
						},
						{
							"name": "derivestatus"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "select1"
						},
						{
							"name": "derivednotificationattributes"
						}
					],
					"scriptLines": [
						"parameters{",
						"     transaction_id as string ('16'),",
						"     quote as string ('\\''),",
						"     status_value_id as string ('1')",
						"}",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"importhistory filter(id==toInteger($transaction_id)) ~> filtertransaction",
						"filtertransaction derive(status_enum_value_id = toInteger($status_value_id),",
						"          errors = 'null') ~> derivestatus",
						"select1 alterRow(updateIf(true())) ~> AlterRow1",
						"derivestatus select(mapColumn(",
						"          id,",
						"          status_enum_value_id,",
						"          errors",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"derivestatus derive(description = original_file_name,",
						"          run_status = 'Complete',",
						"          notification_type = 'Pipeline Status',",
						"          feature_id = 32) ~> derivednotificationattributes",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id,",
						"          status_enum_value_id,",
						"          errors",
						"     )) ~> importhistorysink",
						"derivednotificationattributes sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          run_id as integer,",
						"          run_status as string,",
						"          description as string,",
						"          user_id as string,",
						"          notification_status as string,",
						"          notification_type as string,",
						"          feature_id as integer,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          run_id = id,",
						"          run_status,",
						"          description,",
						"          user_id,",
						"          notification_type,",
						"          feature_id,",
						"          business_unit_id,",
						"          organization_id",
						"     )) ~> notification"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/notification')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/runtimefailurecapture')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistorysink"
						},
						{
							"dataset": {
								"referenceName": "notification",
								"type": "DatasetReference"
							},
							"name": "notifications"
						}
					],
					"transformations": [
						{
							"name": "filtertransaction"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "select1"
						},
						{
							"name": "notificationdescderive"
						}
					],
					"scriptLines": [
						"parameters{",
						"     transaction_id as string ('1'),",
						"     runtime_error as string ('Job failed due to reason: at Source  demandforecastuxupload : Path /DEV/Upload/DemandForecast/1.xlsx does not resolve to any file(s). Please make sure the file/folder exists and is not hidden. At the same time, please ensure special character is not included in file/folder name, for example, name starting with _'),",
						"     quote as string ('\\'')",
						"}",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"importhistory filter(id==toInteger($transaction_id)) ~> filtertransaction",
						"filtertransaction derive(status_enum_value_id = 3,",
						"          errors = replace(concat('{\\'error\\':[{\\'runtime_error\\':\\'',$runtime_error,'\\'}]}'),$quote,'\"'),",
						"          errors_format2 = replace(concat('[{\\'type\\':','\\'error\\',','\\'message\\'',':\\'',$runtime_error,'\\'}]'),$quote,'\"')) ~> derivedColumn1",
						"select1 alterRow(updateIf(true())) ~> AlterRow1",
						"derivedColumn1 select(mapColumn(",
						"          id,",
						"          status_enum_value_id,",
						"          errors = errors_format2,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"filtertransaction derive(description = original_file_name,",
						"          run_status = 'Failed',",
						"          notification_type = 'Pipeline Failure',",
						"          feature_id = 32) ~> notificationdescderive",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          id,",
						"          status_enum_value_id,",
						"          errors,",
						"          business_unit_id,",
						"          organization_id",
						"     )) ~> importhistorysink",
						"notificationdescderive sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          run_id as integer,",
						"          run_status as string,",
						"          description as string,",
						"          user_id as string,",
						"          notification_status as string,",
						"          notification_type as string,",
						"          feature_id as integer,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          run_id = id,",
						"          run_status,",
						"          description,",
						"          user_id,",
						"          notification_type,",
						"          feature_id,",
						"          business_unit_id,",
						"          organization_id",
						"     )) ~> notifications"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/importhistory')]",
				"[concat(variables('factoryId'), '/datasets/notification')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/default')]",
			"type": "Microsoft.DataFactory/factories/managedVirtualNetworks",
			"apiVersion": "2018-06-01",
			"properties": {},
			"dependsOn": []
		}
	]
}