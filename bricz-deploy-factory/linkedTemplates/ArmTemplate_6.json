{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "bricz-deploy-factory"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/df_inventory')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "INVENTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "inventory"
						},
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "ItemMaster"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "LocationMaster"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyTable"
						},
						{
							"dataset": {
								"referenceName": "enum_types",
								"type": "DatasetReference"
							},
							"name": "EnumType"
						},
						{
							"dataset": {
								"referenceName": "enum_values",
								"type": "DatasetReference"
							},
							"name": "EnumValues"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "inventory",
								"type": "DatasetReference"
							},
							"name": "Write2Inventory"
						}
					],
					"transformations": [
						{
							"name": "THTSelected"
						},
						{
							"name": "LMSelected"
						},
						{
							"name": "IMSelected"
						},
						{
							"name": "DeriveAttributes"
						},
						{
							"name": "JoinTenantHeirarchy"
						},
						{
							"name": "JoinItemMaster"
						},
						{
							"name": "JoinLocationMaster"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterStockType"
						},
						{
							"name": "JoinEnumValues"
						},
						{
							"name": "JoinStockTypeEnum"
						},
						{
							"name": "select1"
						},
						{
							"name": "FilterBU"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Item ID} as string,",
						"          {Location ID} as string,",
						"          {On Hand Stock Date} as date,",
						"          {On Hand Stock Quantity} as float,",
						"          {Reserved On Hold Stock} as float,",
						"          {Available Stock} as float,",
						"          {Lot ID} as string,",
						"          {On Order Due Date} as date,",
						"          {On Order Quantity} as float,",
						"          {Purchase Order Status} as float,",
						"          {On Order Supplier Shipping Date} as date,",
						"          {On Order Promised Delivery Date} as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> inventory",
						"source(output(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> ItemMaster",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> LocationMaster",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyTable",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EnumType",
						"source(output(",
						"          id as integer,",
						"          enum_type_id as integer,",
						"          value_id as integer,",
						"          value as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EnumValues",
						"FilterBU select(mapColumn(",
						"          business_unit_id = id,",
						"          tenant_hierarchy_type,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> THTSelected",
						"LocationMaster select(mapColumn(",
						"          location_id = id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LMSelected",
						"ItemMaster select(mapColumn(",
						"          item_id = id,",
						"          item_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> IMSelected",
						"inventory derive(business_unit_name = split(split(file_name,'/')[4],'_')[1],",
						"          stock_type = 'ON_HAND') ~> DeriveAttributes",
						"DeriveAttributes, THTSelected join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTenantHeirarchy",
						"JoinTenantHeirarchy, IMSelected join({Item ID} == item_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinItemMaster",
						"JoinItemMaster, LMSelected join({Location ID} == location_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocationMaster",
						"select1 alterRow(upsertIf(true())) ~> AlterRow1",
						"EnumType filter(name==\"stock_type\") ~> FilterStockType",
						"FilterStockType, EnumValues join(EnumType@id == enum_type_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinEnumValues",
						"JoinLocationMaster, JoinEnumValues join(stock_type == value,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinStockTypeEnum",
						"JoinStockTypeEnum select(mapColumn(",
						"          {Item ID},",
						"          {Location ID},",
						"          {On Hand Stock Date},",
						"          {On Hand Stock Quantity},",
						"          {Reserved On Hold Stock},",
						"          {Available Stock},",
						"          {Lot ID},",
						"          {On Order Due Date},",
						"          {On Order Quantity},",
						"          {Purchase Order Status},",
						"          {On Order Supplier Shipping Date},",
						"          {On Order Promised Delivery Date},",
						"          file_name,",
						"          business_unit_name,",
						"          stock_type,",
						"          business_unit_id,",
						"          tenant_hierarchy_type,",
						"          name = THTSelected@name,",
						"          tenant_id,",
						"          organization_id,",
						"          item_id,",
						"          item_code,",
						"          location_id,",
						"          location_code,",
						"          name = EnumType@name,",
						"          created_date = EnumType@created_date,",
						"          updated_date = EnumType@updated_date,",
						"          enum_type_id,",
						"          value_id,",
						"          value,",
						"          created_date = EnumValues@created_date,",
						"          updated_date = EnumValues@updated_date",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"TenantHeirarchyTable filter(tenant_hierarchy_type==3) ~> FilterBU",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          item_id as integer,",
						"          location_id as integer,",
						"          on_hand_stock_date as date,",
						"          on_hand_stock_quantity as float,",
						"          reserved_on_hold_stock_ as float,",
						"          available_stock as float,",
						"          lot_id as string,",
						"          on_order_due_date as date,",
						"          on_order_quantity_ as float,",
						"          purchase_order_status as float,",
						"          on_order_supplier_shipping_date as date,",
						"          on_order_promised_delivery_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          stock_type_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['item_id','location_id','on_hand_stock_date'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          item_id,",
						"          location_id,",
						"          on_hand_stock_date = {On Hand Stock Date},",
						"          on_hand_stock_quantity = {On Hand Stock Quantity},",
						"          reserved_on_hold_stock_ = {Reserved On Hold Stock},",
						"          available_stock = {Available Stock},",
						"          lot_id = {Lot ID},",
						"          on_order_due_date = {On Order Due Date},",
						"          on_order_quantity_ = {On Order Quantity},",
						"          purchase_order_status = {Purchase Order Status},",
						"          on_order_supplier_shipping_date = {On Order Supplier Shipping Date},",
						"          on_order_promised_delivery_date = {On Order Promised Delivery Date},",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          stock_type_id = value_id",
						"     )) ~> Write2Inventory"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_inventory_ux')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "IMPORT_MANAGER_MERGED"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenanthierarchy"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "fetchinglocations"
						},
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "fetchingitems"
						},
						{
							"dataset": {
								"referenceName": "INVENTORY_UX",
								"type": "DatasetReference"
							},
							"name": "fetchinginventorysource"
						},
						{
							"dataset": {
								"referenceName": "inventory",
								"type": "DatasetReference"
							},
							"name": "fetchinginventory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "inventory",
								"type": "DatasetReference"
							},
							"name": "validinventoryrows"
						},
						{
							"dataset": {
								"referenceName": "FailedInventoryRows",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "filter3"
						},
						{
							"name": "selectimportdetails"
						},
						{
							"name": "join1"
						},
						{
							"name": "choosingtenants"
						},
						{
							"name": "choosinglocations"
						},
						{
							"name": "choosingitems"
						},
						{
							"name": "addingrecordid"
						},
						{
							"name": "nonduplicate"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "renamesourcecolumns"
						},
						{
							"name": "joininglocations"
						},
						{
							"name": "joiningitems"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "selectinginventory"
						},
						{
							"name": "finaldataset"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "joiningTenants"
						},
						{
							"name": "selectedfields"
						},
						{
							"name": "assert1"
						},
						{
							"name": "join3"
						},
						{
							"name": "mergingds"
						},
						{
							"name": "selectrequired"
						},
						{
							"name": "select1"
						},
						{
							"name": "aggregateerrors"
						},
						{
							"name": "join4"
						},
						{
							"name": "splitingtherecordsbasedonerrors"
						},
						{
							"name": "filter4"
						},
						{
							"name": "filter5"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "join5"
						},
						{
							"name": "join6"
						},
						{
							"name": "changecolumntypes"
						}
					],
					"scriptLines": [
						"parameters{",
						"     transaction_id as string ('657'),",
						"     file_path as string ('DEV/Upload/Inventory/657.xlsx')",
						"}",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenanthierarchy",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fetchinglocations",
						"source(output(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fetchingitems",
						"source(output(",
						"          {Item ID} as string,",
						"          {Location ID} as string,",
						"          {Stock Date} as date,",
						"          {Stock Quantity} as string,",
						"          {Reserved Quantity} as string,",
						"          {Available Quantity} as string,",
						"          {On Order ID} as string,",
						"          {On Order Due Date} as date,",
						"          {On Order Supplier Shipping Date} as date,",
						"          {On Order Promised Delivery Date} as date",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> fetchinginventorysource",
						"source(output(",
						"          id as integer,",
						"          item_id as integer,",
						"          location_id as integer,",
						"          on_hand_stock_date as date,",
						"          on_hand_stock_quantity as float,",
						"          reserved_on_hold_stock_ as float,",
						"          available_stock as float,",
						"          lot_id as string,",
						"          on_order_due_date as date,",
						"          on_order_quantity_ as float,",
						"          purchase_order_status as float,",
						"          on_order_supplier_shipping_date as date,",
						"          on_order_promised_delivery_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          stock_type_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fetchinginventory",
						"importhistory filter(id == toInteger($transaction_id)) ~> filter3",
						"filter3 select(mapColumn(",
						"          id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimportdetails",
						"tenanthierarchy, selectimportdetails join(tenanthierarchy@id == business_unit_id",
						"     && parent_id == organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 select(mapColumn(",
						"          tenant_id,",
						"          import_id = selectimportdetails@id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> choosingtenants",
						"join5 select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          organization_id = fetchinglocations@organization_id,",
						"          business_unit_id = fetchinglocations@business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> choosinglocations",
						"join6 select(mapColumn(",
						"          id,",
						"          item_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> choosingitems",
						"fetchinginventorysource keyGenerate(output(record_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> addingrecordid",
						"renamesourcecolumns window(over(Item_ID_SC,",
						"          Location_ID_SC,",
						"          Stock_Date_SC,",
						"          On_Order_Supplier_Shipping_Date_SC,",
						"          On_Order_Promised_Delivery_Date_SC,",
						"          On_Order_ID_SC),",
						"     asc(record_id, true),",
						"     nonduplicated = rowNumber() == 1) ~> nonduplicate",
						"nonduplicate derive(numericalintegrity = iif(isNull(Stock_Quantity_SC),true(),not(isNull(toFloat(Stock_Quantity_SC)))) &&  iif(isNull(Reserved_Quantity_SC),true(),not(isNull(toFloat(Reserved_Quantity_SC)))) && iif(isNull(Available_Quantity_SC),true(),not(isNull(toFloat(Available_Quantity_SC))))) ~> derivedColumn1",
						"addingrecordid select(mapColumn(",
						"          Item_ID_SC = {Item ID},",
						"          Location_ID_SC = {Location ID},",
						"          Stock_Date_SC = {Stock Date},",
						"          Stock_Quantity_SC = {Stock Quantity},",
						"          Reserved_Quantity_SC = {Reserved Quantity},",
						"          Available_Quantity_SC = {Available Quantity},",
						"          On_Order_ID_SC = {On Order ID},",
						"          On_Order_Due_Date_SC = {On Order Due Date},",
						"          On_Order_Supplier_Shipping_Date_SC = {On Order Supplier Shipping Date},",
						"          On_Order_Promised_Delivery_Date_SC = {On Order Promised Delivery Date},",
						"          record_id,",
						"          file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> renamesourcecolumns",
						"joiningTenants, choosinglocations join(Location_ID_SC == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joininglocations",
						"joininglocations, choosingitems join(Item_ID_SC == item_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joiningitems",
						"fetchinginventory derive(presence = 'true') ~> derivedColumn3",
						"derivedColumn3 select(mapColumn(",
						"          id,",
						"          item_id,",
						"          location_id,",
						"          on_hand_stock_date,",
						"          on_hand_stock_quantity,",
						"          reserved_on_hold_stock_,",
						"          available_stock,",
						"          lot_id,",
						"          on_order_due_date,",
						"          on_order_quantity_,",
						"          purchase_order_status,",
						"          on_order_supplier_shipping_date,",
						"          on_order_promised_delivery_date,",
						"          created_date,",
						"          updated_date,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          stock_type_id,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectinginventory",
						"joiningitems select(mapColumn(",
						"          Item_ID_SC,",
						"          Location_ID_SC,",
						"          Stock_Date_SC,",
						"          Stock_Quantity_SC,",
						"          Reserved_Quantity_SC,",
						"          Available_Quantity_SC,",
						"          On_Order_ID_SC,",
						"          On_Order_Due_Date_SC,",
						"          On_Order_Supplier_Shipping_Date_SC,",
						"          On_Order_Promised_Delivery_Date_SC,",
						"          record_id,",
						"          filename = file_name,",
						"          nonduplicated,",
						"          stock_type_id,",
						"          transaction_id,",
						"          tenant_id,",
						"          location_id,",
						"          location_code,",
						"          item_id = id,",
						"          item_code,",
						"          business_unit_id = choosingtenants@business_unit_id,",
						"          organization_id = choosingtenants@organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> finaldataset",
						"nonduplicate derive(stock_type_id = 1,",
						"          transaction_id = toInteger($transaction_id)) ~> derivedColumn4",
						"derivedColumn4, choosingtenants join(transaction_id == import_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joiningTenants",
						"join3 select(mapColumn(",
						"          Item_ID_SC,",
						"          Location_ID_SC,",
						"          Stock_Date_SC,",
						"          Stock_Quantity_SC,",
						"          Reserved_Quantity_SC,",
						"          Available_Quantity_SC,",
						"          On_Order_ID_SC,",
						"          On_Order_Due_Date_SC,",
						"          On_Order_Supplier_Shipping_Date_SC,",
						"          On_Order_Promised_Delivery_Date_SC,",
						"          record_id,",
						"          filename,",
						"          nonduplicated,",
						"          numericalintegrity,",
						"          stock_type_id = selectrequired@stock_type_id,",
						"          transaction_id,",
						"          tenant_id = selectrequired@tenant_id,",
						"          organization_id = selectrequired@organization_id,",
						"          business_unit_id = selectrequired@business_unit_id,",
						"          location_id = selectrequired@location_id,",
						"          location_code,",
						"          item_id = selectrequired@item_id,",
						"          item_code,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectedfields",
						"filter4, selectinginventory, choosinglocations, choosingitems assert(expectExists(Location_ID_SC == choosinglocations@location_code, false, 'checklocationexists', null, 'LOCATION ID IS NOT FOUND'),",
						"     expectExists(Item_ID_SC == choosingitems@item_code, false, 'checkitemcodeexists', null, 'ITEM CODE IS NOT FOUND'),",
						"     expectTrue(numericalintegrity, false, 'numericalintegrity', null, 'Non numerical values exist in numerical fields'),",
						"     expectTrue(nonduplicated, false, 'nonduplicate', null, 'Duplicate records found in upload'),",
						"     expectTrue(isNull(selectedfields@presence), false, 'checkrecordexists', null, 'Record Already Exists in DB')) ~> assert1",
						"selectrequired, selectinginventory join(selectrequired@location_id == selectinginventory@location_id",
						"     && selectrequired@item_id == selectinginventory@item_id",
						"     && Stock_Date_SC == on_hand_stock_date",
						"     && selectrequired@stock_type_id == selectinginventory@stock_type_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"derivedColumn1, finaldataset join(renamesourcecolumns@record_id == finaldataset@record_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> mergingds",
						"mergingds select(mapColumn(",
						"          numericalintegrity,",
						"          Item_ID_SC = finaldataset@Item_ID_SC,",
						"          Location_ID_SC = finaldataset@Location_ID_SC,",
						"          Stock_Date_SC = finaldataset@Stock_Date_SC,",
						"          Stock_Quantity_SC = finaldataset@Stock_Quantity_SC,",
						"          Reserved_Quantity_SC = finaldataset@Reserved_Quantity_SC,",
						"          Available_Quantity_SC = finaldataset@Available_Quantity_SC,",
						"          On_Order_ID_SC = finaldataset@On_Order_ID_SC,",
						"          On_Order_Due_Date_SC = finaldataset@On_Order_Due_Date_SC,",
						"          On_Order_Supplier_Shipping_Date_SC = finaldataset@On_Order_Supplier_Shipping_Date_SC,",
						"          On_Order_Promised_Delivery_Date_SC = finaldataset@On_Order_Promised_Delivery_Date_SC,",
						"          record_id = finaldataset@record_id,",
						"          filename,",
						"          nonduplicated = finaldataset@nonduplicated,",
						"          stock_type_id,",
						"          transaction_id,",
						"          tenant_id,",
						"          location_id,",
						"          location_code,",
						"          item_id,",
						"          item_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectrequired",
						"assert1 select(mapColumn(",
						"          Item_ID_SC,",
						"          Location_ID_SC,",
						"          Stock_Date_SC,",
						"          Stock_Quantity_SC,",
						"          Reserved_Quantity_SC,",
						"          Available_Quantity_SC,",
						"          On_Order_ID_SC,",
						"          On_Order_Due_Date_SC,",
						"          On_Order_Supplier_Shipping_Date_SC,",
						"          On_Order_Promised_Delivery_Date_SC,",
						"          record_id,",
						"          filename,",
						"          stock_type_id = selectedfields@stock_type_id,",
						"          tenant_id = selectedfields@tenant_id,",
						"          organization_id = selectedfields@organization_id,",
						"          business_unit_id = selectedfields@business_unit_id,",
						"          location_id = selectedfields@location_id,",
						"          location_code = selectedfields@location_code,",
						"          item_id = selectedfields@item_id,",
						"          item_code = selectedfields@item_code,",
						"          presence = selectedfields@presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"derivedColumn5 aggregate(groupBy(filename),",
						"     error_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
						"derivedColumn5, aggregateerrors join(select1@filename == aggregateerrors@filename,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join4",
						"join4 split(error_count == 0,",
						"     disjoint: false) ~> splitingtherecordsbasedonerrors@(validrows, invalidrows)",
						"selectedfields filter(not(isNull(Item_ID_SC)) || not(isNull(Location_ID_SC)) || not(isNull(Stock_Date_SC)) || not(isNull(Stock_Quantity_SC)) || not(isNull(Reserved_Quantity_SC)) || not(isNull(Available_Quantity_SC)) || not(isNull(On_Order_ID_SC)) || not(isNull(On_Order_Due_Date_SC)) || not(isNull(On_Order_Supplier_Shipping_Date_SC)) || not(isNull(On_Order_Promised_Delivery_Date_SC))) ~> filter4",
						"splitingtherecordsbasedonerrors@invalidrows filter(not(isNull(validation_errors))) ~> filter5",
						"select1 derive(validation_errors = assertErrorMessages(),",
						"          failed_file_name = replace(replace($file_path,'.xlsx','.json'),'/Upload','/FailedTransactions')) ~> derivedColumn5",
						"filter5 derive(type = 'error',",
						"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedColumn6",
						"fetchinglocations, choosingtenants join(fetchinglocations@organization_id == choosingtenants@organization_id",
						"     && fetchinglocations@business_unit_id == choosingtenants@business_unit_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join5",
						"fetchingitems, choosingtenants join(fetchingitems@organization_id == choosingtenants@organization_id",
						"     && fetchingitems@business_unit_id == choosingtenants@business_unit_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join6",
						"splitingtherecordsbasedonerrors@validrows derive(Stock_Quantity_SC = toFloat(Stock_Quantity_SC),",
						"          Reserved_Quantity_SC = toFloat(Reserved_Quantity_SC),",
						"          Available_Quantity_SC = toFloat(Available_Quantity_SC)) ~> changecolumntypes",
						"changecolumntypes sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          item_id as integer,",
						"          location_id as integer,",
						"          on_hand_stock_date as date,",
						"          on_hand_stock_quantity as float,",
						"          reserved_on_hold_stock_ as float,",
						"          available_stock as float,",
						"          lot_id as string,",
						"          on_order_due_date as date,",
						"          on_order_quantity_ as float,",
						"          purchase_order_status as float,",
						"          on_order_supplier_shipping_date as date,",
						"          on_order_promised_delivery_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          stock_type_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          item_id,",
						"          location_id,",
						"          on_hand_stock_date = Stock_Date_SC,",
						"          on_hand_stock_quantity = Stock_Quantity_SC,",
						"          reserved_on_hold_stock_ = Reserved_Quantity_SC,",
						"          available_stock = Available_Quantity_SC,",
						"          lot_id = On_Order_ID_SC,",
						"          on_order_due_date = On_Order_Due_Date_SC,",
						"          on_order_supplier_shipping_date = On_Order_Supplier_Shipping_Date_SC,",
						"          on_order_promised_delivery_date = On_Order_Promised_Delivery_Date_SC,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          stock_type_id",
						"     )) ~> validinventoryrows",
						"derivedColumn6 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_item_master')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ITEM_MASTER_RAW",
								"type": "DatasetReference"
							},
							"name": "ItemMasterRaw"
						},
						{
							"dataset": {
								"referenceName": "item_heirarchy_detail",
								"type": "DatasetReference"
							},
							"name": "ItemHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "lifecycle_status",
								"type": "DatasetReference"
							},
							"name": "LifecycleStatus"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "TemporaryOutput"
						}
					],
					"transformations": [
						{
							"name": "JoinDepartment"
						},
						{
							"name": "JoinSubDepartment"
						},
						{
							"name": "TenantHeirarchyTableSelected"
						},
						{
							"name": "JoinTenantHeirarchyTable"
						},
						{
							"name": "LifecycleStatusSelected"
						},
						{
							"name": "Department"
						},
						{
							"name": "DepartmentSelected"
						},
						{
							"name": "SubDepartmentSelected"
						},
						{
							"name": "ClassSelected"
						},
						{
							"name": "SubClassSelected"
						},
						{
							"name": "ColorSelected"
						},
						{
							"name": "SizeSelected"
						},
						{
							"name": "StyleSelected"
						},
						{
							"name": "JoinClass"
						},
						{
							"name": "JoinSubClass"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "SizeSecondSelected"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     filepath as string ('Radial/ItemMaster/sample_file.csv')",
						"}",
						"source(output(",
						"          {Organization ID} as string,",
						"          {Business ID} as string,",
						"          {Location Code} as string,",
						"          {Item Code} as string,",
						"          Description as string,",
						"          {Lifecycle Status} as string,",
						"          Department as string,",
						"          Sub_Department as string,",
						"          {Product Division} as string,",
						"          {Product Category} as string,",
						"          {Measurement Unit} as string,",
						"          {Unit Cost} as float,",
						"          {Unit Volume} as float,",
						"          {Unit Weight} as float,",
						"          {Item Unit Price} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($filepath)],",
						"     mode: 'read') ~> ItemMasterRaw",
						"source(output(",
						"          id as string,",
						"          description as string,",
						"          category as string,",
						"          record_creation_date as timestamp,",
						"          record_updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> ItemHeirarchyDetail",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"source(output(",
						"          id as integer,",
						"          status as string,",
						"          lifecycle_code as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> LifecycleStatus",
						"ItemMasterRaw, DepartmentSelected join(ItemMasterRaw@Department == DepartmentSelected@description,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinDepartment",
						"JoinDepartment, SubDepartmentSelected join(ItemMasterRaw@Sub_Department == SubDepartmentSelected@description,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinSubDepartment",
						"filter1 select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          organization_id = parent_id,",
						"          tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> TenantHeirarchyTableSelected",
						"JoinSubClass, TenantHeirarchyTableSelected join({Business ID} == tenant_hierarchy_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTenantHeirarchyTable",
						"LifecycleStatus select(mapColumn(",
						"          sku_lifecycle_status = id,",
						"          lifecycle_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LifecycleStatusSelected",
						"ItemHeirarchyDetail split(category==\"DEPARTMENT\",",
						"     category==\"SUB_DEPARTMENT\",",
						"     category==\"CLASS\",",
						"     category==\"SUB_CLASS\",",
						"     category==\"COLOR\",",
						"     category==\"STYLE\",",
						"     category==\"SIZE\",",
						"     category==\"SIZE\",",
						"     disjoint: true) ~> Department@(Department, SubDepartment, Class, SubClass, Color, Style, Size, SizeSecond)",
						"Department@Department select(mapColumn(",
						"          department = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> DepartmentSelected",
						"Department@SubDepartment select(mapColumn(",
						"          sub_department = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SubDepartmentSelected",
						"Department@Class select(mapColumn(",
						"          class = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> ClassSelected",
						"Department@SubClass select(mapColumn(",
						"          sub_class = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SubClassSelected",
						"Department@Color select(mapColumn(",
						"          color = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> ColorSelected",
						"Department@Size select(mapColumn(",
						"          size = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SizeSelected",
						"Department@Style select(mapColumn(",
						"          style = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StyleSelected",
						"JoinSubDepartment, ClassSelected join({Product Division} == ClassSelected@description,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinClass",
						"JoinClass, SubClassSelected join({Product Category} == SubClassSelected@description,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinSubClass",
						"JoinTenantHeirarchyTable alterRow(upsertIf(true())) ~> AlterRow1",
						"Department@SizeSecond select(mapColumn(",
						"          size_second = id,",
						"          description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SizeSecondSelected",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type==3) ~> filter1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['item_code','business_unit_id','organization_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          item_code = {Item Code},",
						"          description = ItemMasterRaw@Description,",
						"          short_description = ItemMasterRaw@Description,",
						"          department = DepartmentSelected@department,",
						"          sub_department = SubDepartmentSelected@sub_department,",
						"          product_division = {Product Division},",
						"          class = {Product Category},",
						"          measurement_unit = {Measurement Unit},",
						"          unit_cost = {Unit Cost},",
						"          unit_volume = {Unit Volume},",
						"          unit_weight = {Unit Weight},",
						"          item_unit_price = {Item Unit Price},",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     preCommands: [],",
						"     postCommands: []) ~> TemporaryOutput"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_lane_rates')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Dataflow activity created for populating pfp.lane_rates table",
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LANE_RATE_GROUND_RAW",
								"type": "DatasetReference"
							},
							"name": "LaneRateForGround",
							"description": "dataset corresponding to zonewise lane rates"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "HeirarchyTable",
							"description": "Lookup table for fetching organization_id and business unit is"
						},
						{
							"dataset": {
								"referenceName": "LANE_RATE_NEXTDAY_AIR_RAW",
								"type": "DatasetReference"
							},
							"name": "LaneRateForNDA"
						},
						{
							"dataset": {
								"referenceName": "LANE_RATE_2DAY_AIR_RAW",
								"type": "DatasetReference"
							},
							"name": "LaneRateFor2DA",
							"description": "2DA ratecard"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "lane_rate",
								"type": "DatasetReference"
							},
							"name": "tempoutput"
						}
					],
					"transformations": [
						{
							"name": "ExtractAttributesByUnpivot"
						},
						{
							"name": "SelectRelevantColumns"
						},
						{
							"name": "DerivingAttributes"
						},
						{
							"name": "FinalColumnsSelect",
							"description": "Select, rename activities to match the lane_rate table schema"
						},
						{
							"name": "RemoveRowsWithNull",
							"description": "Removing rows with null value on the column rate"
						},
						{
							"name": "SelectColumnsHeirarchyTable",
							"description": "Select specific columns that will be used in downstream activities"
						},
						{
							"name": "JoinHeirarchyTable",
							"description": "Join heirarchy table to extract business_unit_id and organization_id"
						},
						{
							"name": "ExtractAttributesNDA"
						},
						{
							"name": "SelectNDA"
						},
						{
							"name": "RemoveLetterRates2DA"
						},
						{
							"name": "JoinBranches"
						},
						{
							"name": "ExtractAttributes2DA"
						},
						{
							"name": "Select2DA"
						},
						{
							"name": "CombineBeforeFilterLetter"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterBusinessUnitsRecords"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Zones as string,",
						"          {2} as float,",
						"          {3} as float,",
						"          {4} as float,",
						"          {5} as float,",
						"          {6} as float,",
						"          {7} as float,",
						"          {8} as float,",
						"          {44} as float,",
						"          {45} as float,",
						"          {46} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: true,",
						"     rowUrlColumn: 'file_name') ~> LaneRateForGround",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> HeirarchyTable",
						"source(output(",
						"          Zones as string,",
						"          {102.0} as double,",
						"          {103.0} as double,",
						"          {104.0} as double,",
						"          {105.0} as double,",
						"          {106.0} as double,",
						"          {107.0} as double,",
						"          {108.0} as double,",
						"          {124.0} as double,",
						"          {125.0} as double,",
						"          {126} as double",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: true,",
						"     rowUrlColumn: 'file_name') ~> LaneRateForNDA",
						"source(output(",
						"          Zones as string,",
						"          {202.0} as float,",
						"          {203.0} as float,",
						"          {204.0} as float,",
						"          {205.0} as float,",
						"          {206.0} as float,",
						"          {207.0} as float,",
						"          {208.0} as float,",
						"          {224.0} as float,",
						"          {225.0} as float,",
						"          {226} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: true,",
						"     rowUrlColumn: 'file_name') ~> LaneRateFor2DA",
						"LaneRateForGround unpivot(output(",
						"          Class as string,",
						"          {2} as float,",
						"          {3} as float,",
						"          {4} as float,",
						"          {5} as float,",
						"          {6} as float,",
						"          {7} as float,",
						"          {8} as float,",
						"          {44} as float,",
						"          {45} as float,",
						"          {46} as float",
						"     ),",
						"     ungroupBy(Zones,",
						"          file_name),",
						"     lateral: true,",
						"     ignoreNullPivots: false) ~> ExtractAttributesByUnpivot",
						"ExtractAttributesByUnpivot select(mapColumn(",
						"          weight = Zones,",
						"          Zone = Class,",
						"          rate = {2},",
						"          file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectRelevantColumns",
						"JoinBranches derive(rate_code = split(file_name,\"/\")[4]+'-'+split(file_name,\"/\")[5]+'-'+toString(toInteger(Zone), '000'),",
						"          break1_type = 'Weight',",
						"          break1_start = toInteger(replace(weight, ' Lbs.', ''))-1,",
						"          break1_end = toInteger(replace(weight, ' Lbs.', '')),",
						"          rate_type = 'Flat',",
						"          business_unit_name = split(split(file_name,\"/\")[6],'_')[1]) ~> DerivingAttributes",
						"JoinHeirarchyTable select(mapColumn(",
						"          rate_code,",
						"          break1_type,",
						"          break1_start,",
						"          break1_end,",
						"          rate_type,",
						"          rate,",
						"          business_unit_id = id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> FinalColumnsSelect",
						"FinalColumnsSelect filter(not(isNull(rate))) ~> RemoveRowsWithNull",
						"FilterBusinessUnitsRecords select(mapColumn(",
						"          id,",
						"          name,",
						"          parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumnsHeirarchyTable",
						"DerivingAttributes, SelectColumnsHeirarchyTable join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinHeirarchyTable",
						"LaneRateForNDA unpivot(output(",
						"          Class as string,",
						"          {102.0} as double,",
						"          {103.0} as double,",
						"          {104.0} as double,",
						"          {105.0} as double,",
						"          {106.0} as double",
						"     ),",
						"     ungroupBy(Zones,",
						"          file_name),",
						"     lateral: true,",
						"     ignoreNullPivots: false) ~> ExtractAttributesNDA",
						"ExtractAttributesNDA select(mapColumn(",
						"          weight = Zones,",
						"          file_name,",
						"          Zone = Class,",
						"          rate = {102.0}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectNDA",
						"CombineBeforeFilterLetter filter(weight!='Letter') ~> RemoveLetterRates2DA",
						"SelectRelevantColumns, RemoveLetterRates2DA union(byName: true)~> JoinBranches",
						"LaneRateFor2DA unpivot(output(",
						"          Class as string,",
						"          {202.0} as float,",
						"          {203.0} as float,",
						"          {204.0} as float,",
						"          {205.0} as float,",
						"          {206.0} as float",
						"     ),",
						"     ungroupBy(Zones,",
						"          file_name),",
						"     lateral: true,",
						"     ignoreNullPivots: false) ~> ExtractAttributes2DA",
						"ExtractAttributes2DA select(mapColumn(",
						"          weight = Zones,",
						"          file_name,",
						"          Zone = Class,",
						"          rate = {202.0}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> Select2DA",
						"SelectNDA, Select2DA union(byName: true)~> CombineBeforeFilterLetter",
						"RemoveRowsWithNull alterRow(upsertIf(true())) ~> AlterRow1",
						"HeirarchyTable filter(tenant_hierarchy_type==3) ~> FilterBusinessUnitsRecords",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          rate_code as string,",
						"          break1_type as string,",
						"          break1_start as integer,",
						"          break1_end as integer,",
						"          rate_type as string,",
						"          rate as double,",
						"          rate_minimum as double,",
						"          rate_maximum as double,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['rate_code','break1_type','break1_start','break1_end','rate_type'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> tempoutput"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_location_master')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LOCATION_MASTER_RAW",
								"type": "DatasetReference"
							},
							"name": "LocationMasterRaw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHierarchyDetail"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "WriteToLocationsTable",
							"rejectedDataLinkedService": {
								"referenceName": "datalakelinkedservice",
								"type": "LinkedServiceReference"
							}
						},
						{
							"dataset": {
								"referenceName": "FAILED_LOCATION_MASTER_ROWS_SFTP",
								"type": "DatasetReference"
							},
							"name": "failedrowslocationmaster"
						}
					],
					"transformations": [
						{
							"name": "THDBUSelected"
						},
						{
							"name": "JoinTenantHeirarchyDetail"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterBUrecords"
						},
						{
							"name": "AddDefaultedColumns",
							"description": "Add Location Type - always 1"
						},
						{
							"name": "ValidateData"
						},
						{
							"name": "Pass",
							"description": "If there are no validation errors, pass. Otherwise fail."
						},
						{
							"name": "DeriveErrorsAndFileName",
							"description": "Convert Assertions In Columns"
						},
						{
							"name": "RenameColumnsForValidation"
						},
						{
							"name": "FilterOrgRecords"
						},
						{
							"name": "THDOrgSelected"
						},
						{
							"name": "JoinBUWithOrg"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('Radial/LocationMaster/data_107e2644-2ce0-4274-abb8-2ad1ea4d944d_d6b001c9-e396-41a1-ad43-b5f3d1aebeae.csv')",
						"}",
						"source(output(",
						"          {Organization ID} as string,",
						"          {Business ID} as string,",
						"          {Location Code} as short,",
						"          Name as string,",
						"          Address as string,",
						"          City as string,",
						"          State as string,",
						"          Zip as string,",
						"          Country as string,",
						"          Latitude as double,",
						"          Longitude as double,",
						"          {Location Status} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     wildcardPaths:[($file_path)],",
						"     mode: 'read') ~> LocationMasterRaw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHierarchyDetail",
						"FilterBUrecords select(mapColumn(",
						"          THD_BU_id = id,",
						"          THD_BU_parent_id = parent_id,",
						"          THD_BU_tenant_hierarchy_code = tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> THDBUSelected",
						"LocationMasterRaw, JoinBUWithOrg join({Business ID} == THD_BU_tenant_hierarchy_code",
						"     && {Organization ID} == THD_Org_tenant_hierarchy_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTenantHeirarchyDetail",
						"AddDefaultedColumns alterRow(upsertIf(true())) ~> AlterRow1",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type==3) ~> FilterBUrecords",
						"Pass@Pass derive(Location_Type = 1) ~> AddDefaultedColumns",
						"RenameColumnsForValidation assert(expectTrue(! isNull(Organization_ID), false, 'OrgIDNull', null, \"Organization ID is NULL\"),",
						"     expectTrue(! isNull(Business_ID), false, 'BusIDNull', null, \"Business ID is NULL\"),",
						"     expectTrue(! isNull(Location_Code), false, 'LocCodeNull', null, \"Location Code is NULL\"),",
						"     expectTrue(! isNull(Name), false, 'NameNull', null, \"Name Is NULL\"),",
						"     expectTrue(! isNull(Address), false, 'AddressIsNull', null, \"Address Is NULL\"),",
						"     expectTrue(! isNull(City), false, 'CityIsNull', null, \"City Is NULL\"),",
						"     expectTrue(! isNull(State), false, 'StateIsNull', null, \"State is NULL\"),",
						"     expectTrue(! isNull(Zip), false, 'ZipIsNull', null, \"Zip is NULL\"),",
						"     expectTrue(! isNull(Country), false, 'CountryIsNull', null, \"Country Is NULL\"),",
						"     expectTrue(! ( Longitude < -180 ) || (Longitude > 180), false, 'LongitudeInvalid', null, \"Longitude Is Invalid\"),",
						"     expectTrue(! ( Latitude < -180 ) || ( Latitude > 180 ), false, 'LatitudeInvalid', null, \"Latitude Is Invalid\"),",
						"     expectTrue(! isNull(THD_Org_id), false, 'OrgIDInvalid', null, \"Organization ID Is Invalid\"),",
						"     expectTrue(! isNull(THD_BU_id), false, 'BUInvalid', null, \"Business Unit Is Invalid\")) ~> ValidateData",
						"DeriveErrorsAndFileName split(isNull(validation_errors),",
						"     disjoint: false) ~> Pass@(Pass, Fail)",
						"ValidateData derive(validation_errors = assertErrorMessages(),",
						"          file_name = $file_path,",
						"          failed_filename = replace($file_path,'Radial','faileduploads')) ~> DeriveErrorsAndFileName",
						"JoinTenantHeirarchyDetail select(mapColumn(",
						"          Organization_ID = {Organization ID},",
						"          Business_ID = {Business ID},",
						"          Location_Code = {Location Code},",
						"          Name,",
						"          Address,",
						"          City,",
						"          State,",
						"          Zip,",
						"          Country,",
						"          Latitude,",
						"          Longitude,",
						"          Location_Status = {Location Status},",
						"          THD_BU_id,",
						"          THD_BU_parent_id,",
						"          THD_BU_tenant_hierarchy_code,",
						"          THD_Org_id,",
						"          THD_Org_tenant_id,",
						"          THD_Org_tenant_hierarchy_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RenameColumnsForValidation",
						"TenantHierarchyDetail filter(tenant_hierarchy_type == 2) ~> FilterOrgRecords",
						"FilterOrgRecords select(mapColumn(",
						"          THD_Org_id = id,",
						"          THD_Org_tenant_id = tenant_id,",
						"          THD_Org_tenant_hierarchy_code = tenant_hierarchy_code,",
						"          THD_Org_tenant_id = tenant_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> THDOrgSelected",
						"THDBUSelected, THDOrgSelected join(THD_BU_parent_id == THD_Org_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinBUWithOrg",
						"AlterRow1 sink(allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     input(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['location_code'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          location_code = Location_Code,",
						"          address = Address,",
						"          name = Name,",
						"          zip = Zip,",
						"          tenant_id = THD_Org_tenant_id,",
						"          organization_id = THD_Org_id,",
						"          business_unit_id = THD_BU_id,",
						"          status = Location_Status,",
						"          type = Location_Type,",
						"          latitude = Latitude,",
						"          longitude = Longitude,",
						"          city = City,",
						"          state = State,",
						"          zip = Zip",
						"     )) ~> WriteToLocationsTable",
						"Pass@Fail sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_filename',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> failedrowslocationmaster"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_locations_ux')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "IMPORT_MANAGER_MERGED"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "FetchingLocations"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importHistory"
						},
						{
							"dataset": {
								"referenceName": "LOCATION_UX_STAGING",
								"type": "DatasetReference"
							},
							"name": "ExcelSource"
						},
						{
							"dataset": {
								"referenceName": "location_type",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "fetchingtenentdetails"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "loadlocationsdatadb"
						},
						{
							"dataset": {
								"referenceName": "FailedRowsLocation",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "FilteringHistory"
						},
						{
							"name": "selectingImportHistory"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "selectLocations"
						},
						{
							"name": "AddingRecordID"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "join2"
						},
						{
							"name": "select2"
						},
						{
							"name": "assert1"
						},
						{
							"name": "storingErrorRecords"
						},
						{
							"name": "joiningwithErrors"
						},
						{
							"name": "select3"
						},
						{
							"name": "aggregateErrors"
						},
						{
							"name": "split1"
						},
						{
							"name": "selectingFailedRows"
						},
						{
							"name": "duplicateddata"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "window1"
						},
						{
							"name": "SelectingUniqueLocations"
						},
						{
							"name": "selectinglocationtypes"
						},
						{
							"name": "filter1"
						},
						{
							"name": "join4"
						},
						{
							"name": "mergingtenantdetails"
						},
						{
							"name": "changingcolumntypes"
						},
						{
							"name": "join5"
						}
					],
					"scriptLines": [
						"parameters{",
						"     transaction_id as string ('192'),",
						"     file_path as string ('/DEV/Upload/Location/192.xlsx')",
						"}",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> FetchingLocations",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importHistory",
						"source(output(",
						"          {Location ID*} as string,",
						"          {Location Name} as string,",
						"          Address as string,",
						"          City as string,",
						"          State as string,",
						"          Zip as string,",
						"          Country as string,",
						"          Longitude as string,",
						"          Latitude as string,",
						"          {Location Status} as string,",
						"          {Location Type} as string,",
						"          {Daily Throughput} as string,",
						"          {Storage Capacity} as string,",
						"          {Inbound Handling Cost} as string,",
						"          {Outbound Handling Cost} as string,",
						"          {Inbound Processing Time} as string,",
						"          {Outbound Processing Time} as string,",
						"          {Transfer Inbound Processing Time} as string,",
						"          {Transfer Outbound Processing Time} as string,",
						"          {Transfer Inbound Handling Cost} as string,",
						"          {Transfer Outbound Handling Cost} as string,",
						"          {Units per Hour} as string,",
						"          {Max FTE Regular Hours} as string,",
						"          {Min FTE Regular Hours} as string,",
						"          {Max Temp Regular Hours} as string,",
						"          {Min Temp Regular Hours} as string,",
						"          {Max FTE Overtime Hours} as string,",
						"          {Regular FTE Wage} as string,",
						"          {Regular Temp Wage} as string,",
						"          {Overtime FTE Wage} as string,",
						"          {Overtime Temp Wage} as string,",
						"          {FTE Staff Count} as string,",
						"          {Temp Staff Count} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'filename',",
						"     wildcardPaths:[($file_path)]) ~> ExcelSource",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          description as string,",
						"          created_date as date,",
						"          updated_date as date,",
						"          display_icon as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string,",
						"          tenant_hierarchy_code as string,",
						"          isdeleted as boolean,",
						"          updated_by_user_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fetchingtenentdetails",
						"join4 filter(importHistory@id == toInteger($transaction_id)) ~> FilteringHistory",
						"FilteringHistory select(mapColumn(",
						"          import_id = importHistory@id,",
						"          business_unit_id,",
						"          organization_id,",
						"          tenant_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectingImportHistory",
						"FetchingLocations derive(presence = 'true') ~> derivedColumn1",
						"derivedColumn1 select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          presence,",
						"          name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectLocations",
						"ExcelSource keyGenerate(output(record_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> AddingRecordID",
						"AddingRecordID derive(numericalintegrity = iif(isNull({Daily Throughput}),true(),not(isNull(toFloat({Daily Throughput})))) && iif(isNull({Storage Capacity}),true(),not(isNull(toFloat({Storage Capacity})))) && iif(isNull({Inbound Handling Cost}),true(),not(isNull(toFloat({Inbound Handling Cost})))) && iif(isNull({Outbound Handling Cost}),true(),not(isNull(toFloat({Outbound Handling Cost})))) && iif(isNull({Transfer Inbound Handling Cost}),true(),not(isNull(toFloat({Transfer Inbound Handling Cost})))) && iif(isNull({Transfer Outbound Handling Cost}),true(),not(isNull(toFloat({Transfer Outbound Handling Cost})))) && iif(isNull({Units per Hour}),true(),not(isNull(toFloat({Units per Hour})))) && iif(isNull({Min FTE Regular Hours}),true(),not(isNull(toFloat({Min FTE Regular Hours})))) && iif(isNull({Max FTE Regular Hours}),true(),not(isNull(toFloat({Max FTE Regular Hours})))) && iif(isNull({Min Temp Regular Hours}),true(),not(isNull(toFloat({Min Temp Regular Hours})))) && iif(isNull({Max Temp Regular Hours}),true(),not(isNull(toFloat({Max Temp Regular Hours})))) && iif(isNull({Max FTE Overtime Hours}),true(),not(isNull(toFloat({Max FTE Overtime Hours})))) && iif(isNull({Regular FTE Wage}),true(),not(isNull(toFloat({Regular FTE Wage})))) && iif(isNull({Regular Temp Wage}),true(),not(isNull(toFloat({Regular Temp Wage})))) && iif(isNull({Overtime FTE Wage}),true(),not(isNull(toFloat({Overtime FTE Wage})))) && iif(isNull({Overtime Temp Wage}),true(),not(isNull(toFloat({Overtime Temp Wage})))) && iif(isNull({FTE Staff Count}),true(),not(isNull(toFloat({FTE Staff Count})))) && iif(isNull({Temp Staff Count}),true(),not(isNull(toFloat({Temp Staff Count})))),",
						"          transaction_id = toInteger($transaction_id)) ~> derivedColumn2",
						"duplicateddata, SelectingUniqueLocations join({Location ID*} == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join5 select(mapColumn(",
						"          Location_Code_SC = {Location ID*},",
						"          Location_Name_SC = {Location Name},",
						"          Address_SC = Address,",
						"          City_SC = City,",
						"          State_SC = State,",
						"          Zip_SC = Zip,",
						"          Country_SC = Country,",
						"          Longitude_SC = Longitude,",
						"          Latitude_SC = Latitude,",
						"          Location_Status_SC = {Location Status},",
						"          Location_Type_SC = {Location Type},",
						"          Daily_Throughput_SC = {Daily Throughput},",
						"          Storage_Capacity_SC = {Storage Capacity},",
						"          Inbound_Handling_Cost_SC = {Inbound Handling Cost},",
						"          Outbound_Handling_Cost_SC = {Outbound Handling Cost},",
						"          Inbound_Processing_Time_SC = {Inbound Processing Time},",
						"          Outbound_Processing_Time_SC = {Outbound Processing Time},",
						"          Transfer_Inbound_Processing_Time_SC = {Transfer Inbound Processing Time},",
						"          Transfer_Outbound_Processing_Time_SC = {Transfer Outbound Processing Time},",
						"          Transfer_Inbound_Handling_Cost_SC = {Transfer Inbound Handling Cost},",
						"          Transfer_Outbound_Handling_Cost_SC = {Transfer Outbound Handling Cost},",
						"          Units_per_Hour_SC = {Units per Hour},",
						"          Max_FTE_Regular_Hours_SC = {Max FTE Regular Hours},",
						"          Min_FTE_Regular_Hours_SC = {Min FTE Regular Hours},",
						"          Max_Temp_Regular_Hours_SC = {Max Temp Regular Hours},",
						"          Min_Temp_Regular_Hours_SC = {Min Temp Regular Hours},",
						"          Max_FTE_Overtime_Hours_SC = {Max FTE Overtime Hours},",
						"          Regular_FTE_Wage_SC = {Regular FTE Wage},",
						"          Regular_Temp_Wage_SC = {Regular Temp Wage},",
						"          Overtime_FTE_Wage_SC = {Overtime FTE Wage},",
						"          Overtime_Temp_Wage_SC = {Overtime Temp Wage},",
						"          FTE_Staff_Count_SC = {FTE Staff Count},",
						"          Temp_Staff_Count_SC = {Temp Staff Count},",
						"          record_id,",
						"          nonduplicate,",
						"          numericalintegrity,",
						"          location_id,",
						"          presence,",
						"          filename,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          location_type_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"filter1, selectLocations, selectinglocationtypes assert(expectTrue(isNull(select2@presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
						"     expectExists(Location_Type_SC == location_type_name, false, 'checklocationtype', null, 'Location Type Not Found'),",
						"     expectTrue(numericalintegrity, false, 'numericalintegrity', null, 'Numerical fields contain non numeric values'),",
						"     expectTrue(nonduplicate, false, 'nonduplicate', null, 'Duplicate Values Not Found')) ~> assert1",
						"assert1 derive(transaction_id = $transaction_id,",
						"          validation_errors = assertErrorMessages(),",
						"          failed_file_name = replace(replace($file_path,'.xlsx','.json'),'/Upload','/FailedTransactions')) ~> storingErrorRecords",
						"storingErrorRecords, aggregateErrors join(select2@filename == aggregateErrors@filename,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joiningwithErrors",
						"storingErrorRecords select(mapColumn(",
						"          validation_errors,",
						"          filename",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select3 aggregate(groupBy(filename),",
						"     error_count = countIf(not(isNull(validation_errors)))) ~> aggregateErrors",
						"joiningwithErrors split(error_count==0,",
						"     disjoint: false) ~> split1@(validrows, invalidrows)",
						"split1@invalidrows select(mapColumn(",
						"          filename = split1@invalidrows@filename,",
						"          validation_errors,",
						"          failed_file_name,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectingFailedRows",
						"derivedColumn2 window(over({Location ID*}),",
						"     asc(record_id, true),",
						"     nonduplicate = rowNumber() == 1) ~> duplicateddata",
						"selectingFailedRows derive(failed_file_name = replace(replace($file_path,'.xlsx','.json'),'/Upload','/FailedTransactions'),",
						"          type = 'error',",
						"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedColumn3",
						"selectLocations window(over(location_code),",
						"     asc(location_id, true),",
						"     duplicate_data = rowNumber() == 1) ~> window1",
						"window1 filter(duplicate_data == true()) ~> SelectingUniqueLocations",
						"source1 select(mapColumn(",
						"          location_type_id = id,",
						"          location_type_name = name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectinglocationtypes",
						"select2 filter(not(isNull(Location_Code_SC)) || ",
						"not(isNull(Location_Name_SC)) || ",
						"not(isNull(Address_SC)) || ",
						"not(isNull(City_SC)) || ",
						"not(isNull(State_SC)) || ",
						"not(isNull(Zip_SC)) || ",
						"not(isNull(Longitude_SC)) || ",
						"not(isNull(Latitude_SC)) || ",
						"not(isNull(Location_Status_SC)) || ",
						"not(isNull(Location_Type_SC)) || ",
						"not(isNull(Daily_Throughput_SC)) || ",
						"not(isNull(Storage_Capacity_SC)) || ",
						"not(isNull(Inbound_Handling_Cost_SC)) || ",
						"not(isNull(Outbound_Handling_Cost_SC)) || ",
						"not(isNull(Inbound_Processing_Time_SC)) || ",
						"not(isNull(Outbound_Processing_Time_SC)) || ",
						"not(isNull(Transfer_Inbound_Processing_Time_SC)) || ",
						"not(isNull(Transfer_Outbound_Processing_Time_SC)) || ",
						"not(isNull(Transfer_Inbound_Handling_Cost_SC)) || ",
						"not(isNull(Units_per_Hour_SC)) || ",
						"not(isNull(Max_FTE_Regular_Hours_SC)) || ",
						"not(isNull(Min_FTE_Regular_Hours_SC)) || ",
						"not(isNull(Max_Temp_Regular_Hours_SC)) || ",
						"not(isNull(Min_Temp_Regular_Hours_SC)) || ",
						"not(isNull(Max_FTE_Overtime_Hours_SC)) || ",
						"not(isNull(Regular_FTE_Wage_SC)) || ",
						"not(isNull(Regular_Temp_Wage_SC)) || ",
						"not(isNull(Overtime_FTE_Wage_SC)) || ",
						"not(isNull(Overtime_Temp_Wage_SC)) || ",
						"not(isNull(FTE_Staff_Count_SC)) || ",
						"not(isNull(Temp_Staff_Count_SC))) ~> filter1",
						"importHistory, fetchingtenentdetails join(business_unit_id == fetchingtenentdetails@id",
						"     && organization_id == parent_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join4",
						"join2, selectingImportHistory join(transaction_id == import_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> mergingtenantdetails",
						"split1@validrows derive(latitude = coalesce(toInteger(Latitude_SC), 0),",
						"          longitude = coalesce(toInteger(Longitude_SC), 0),",
						"          Daily_Throughput_SC = toFloat(Daily_Throughput_SC),",
						"          Storage_Capacity_SC = toFloat(Storage_Capacity_SC),",
						"          Inbound_Handling_Cost_SC = toFloat(Inbound_Handling_Cost_SC),",
						"          Outbound_Handling_Cost_SC = toFloat(Outbound_Handling_Cost_SC),",
						"          Inbound_Processing_Time_SC = toDouble(Inbound_Processing_Time_SC),",
						"          Outbound_Processing_Time_SC = toDouble(Outbound_Processing_Time_SC),",
						"          Transfer_Inbound_Processing_Time_SC = toDouble(Transfer_Inbound_Processing_Time_SC),",
						"          Transfer_Outbound_Processing_Time_SC = toDouble(Transfer_Outbound_Processing_Time_SC),",
						"          Transfer_Inbound_Handling_Cost_SC = toDouble(Transfer_Inbound_Handling_Cost_SC),",
						"          Transfer_Outbound_Handling_Cost_SC = toDouble(Transfer_Outbound_Handling_Cost_SC),",
						"          Units_per_Hour_SC = toFloat(Units_per_Hour_SC),",
						"          Max_FTE_Regular_Hours_SC = toFloat(Max_FTE_Regular_Hours_SC),",
						"          Min_FTE_Regular_Hours_SC = toFloat(Min_FTE_Regular_Hours_SC),",
						"          Max_Temp_Regular_Hours_SC = toFloat(Max_Temp_Regular_Hours_SC),",
						"          Min_Temp_Regular_Hours_SC = toFloat(Min_Temp_Regular_Hours_SC),",
						"          Max_FTE_Overtime_Hours_SC = toFloat(Max_FTE_Overtime_Hours_SC),",
						"          Regular_FTE_Wage_SC = toFloat(Regular_FTE_Wage_SC),",
						"          Regular_Temp_Wage_SC = toFloat(Regular_Temp_Wage_SC),",
						"          Overtime_FTE_Wage_SC = toFloat(Overtime_FTE_Wage_SC),",
						"          FTE_Staff_Count_SC = toFloat(FTE_Staff_Count_SC),",
						"          Overtime_Temp_Wage_SC = toFloat(Overtime_Temp_Wage_SC),",
						"          Temp_Staff_Count_SC = toFloat(Temp_Staff_Count_SC)) ~> changingcolumntypes",
						"mergingtenantdetails, selectinglocationtypes join({Location Type} == location_type_name,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join5",
						"changingcolumntypes sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          location_code = Location_Code_SC,",
						"          name = Location_Name_SC,",
						"          address = Address_SC,",
						"          city = City_SC,",
						"          state = State_SC,",
						"          zip = Zip_SC,",
						"          country = Country_SC,",
						"          throughput = Daily_Throughput_SC,",
						"          capacity = Storage_Capacity_SC,",
						"          inbound_handling_cost = Inbound_Handling_Cost_SC,",
						"          outbound_handling_cost = Outbound_Handling_Cost_SC,",
						"          longitude,",
						"          latitude,",
						"          status = Location_Status_SC,",
						"          inbound_processing_time = Inbound_Processing_Time_SC,",
						"          outbound_processing_time = Outbound_Processing_Time_SC,",
						"          type = split1@validrows@location_type_id,",
						"          transfer_inbound_processing_time = Transfer_Inbound_Processing_Time_SC,",
						"          transfer_outbound_processing_time = Transfer_Outbound_Processing_Time_SC,",
						"          transfer_inbound_handling_cost = Transfer_Inbound_Handling_Cost_SC,",
						"          transfer_outbound_handling_cost = Transfer_Outbound_Handling_Cost_SC,",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          units_per_hour = Units_per_Hour_SC,",
						"          max_fte_regular_hours = Max_FTE_Regular_Hours_SC,",
						"          min_fte_regular_hours = Min_FTE_Regular_Hours_SC,",
						"          max_temp_regular_hours = Max_Temp_Regular_Hours_SC,",
						"          min_temp_regular_hours = Min_Temp_Regular_Hours_SC,",
						"          max_fte_overtime_hours = Max_FTE_Overtime_Hours_SC,",
						"          regular_fte_wage = Regular_FTE_Wage_SC,",
						"          regular_temp_wage = Regular_Temp_Wage_SC,",
						"          overtime_fte_wage = Overtime_FTE_Wage_SC,",
						"          overtime_temp_wage = Overtime_Temp_Wage_SC,",
						"          fte_staff_count = FTE_Staff_Count_SC,",
						"          temp_staff_count = Temp_Staff_Count_SC",
						"     )) ~> loadlocationsdatadb",
						"derivedColumn3 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_order_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ORDER_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "orderhistoryraw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "order_history",
								"type": "DatasetReference"
							},
							"name": "OrderHistory"
						}
					],
					"transformations": [
						{
							"name": "AggregationOrderLevel"
						},
						{
							"name": "SelectColumns"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "filterbusinessunits"
						},
						{
							"name": "JoinTHTD"
						},
						{
							"name": "RenameColumns"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "devfilter"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Order ID} as string,",
						"          {Order Line ID} as string,",
						"          {Location ID} as string,",
						"          Channel as string,",
						"          {Order Date} as timestamp,",
						"          {Order Original Ship Date} as timestamp,",
						"          {Order Actual Ship Date} as timestamp,",
						"          {Order Due Date} as timestamp,",
						"          {Order Received Date and Time} as timestamp,",
						"          {Order Completed Date and Time} as timestamp,",
						"          {Destination Zip Code} as string,",
						"          {Item Code} as string,",
						"          {Order Quantity} as float,",
						"          {Quantity (UOM) Picked} as string,",
						"          {Order Status} as string,",
						"          Carrier as string,",
						"          {Service Type} as string,",
						"          {Shipment Fees} as float,",
						"          {Order Value} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> orderhistoryraw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"SelectColumns aggregate(groupBy({Order ID},",
						"          Channel,",
						"          {Order Date},",
						"          {Order Due Date},",
						"          {Destination Zip Code},",
						"          {Order Status},",
						"          {Order Actual Ship Date},",
						"          Carrier,",
						"          {Service Type},",
						"          {Location ID},",
						"          business_unit_id,",
						"          organization_id,",
						"          import_date),",
						"     {Shipment Fees} = toFloat(sum({Shipment Fees})),",
						"          {Order Quantity} = toFloat(sum({Order Quantity})),",
						"          {Order Value} = toDecimal(sum({Order Value}), 10, 2)) ~> AggregationOrderLevel",
						"JoinTHTD select(mapColumn(",
						"          {Order ID},",
						"          Channel,",
						"          {Order Date},",
						"          {Order Due Date},",
						"          {Destination Zip Code},",
						"          {Order Actual Ship Date},",
						"          {Order Status},",
						"          Carrier,",
						"          {Service Type},",
						"          {Order Quantity},",
						"          {Shipment Fees},",
						"          {Order Value},",
						"          business_unit_id,",
						"          organization_id,",
						"          import_date,",
						"          {Location ID}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumns",
						"orderhistoryraw derive(business_unit_name = split(split(file_name,'/')[4],'_')[2],",
						"          import_date = currentUTC(\"UTC\")) ~> derivedColumn1",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type==3) ~> filterbusinessunits",
						"derivedColumn1, RenameColumns join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHTD",
						"filterbusinessunits select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RenameColumns",
						"devfilter alterRow(upsertIf(true())) ~> AlterRow1",
						"AggregationOrderLevel derive({Order Value} = round({Order Value},2)) ~> derivedColumn2",
						"derivedColumn2 filter(true()) ~> devfilter",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          order_code as string,",
						"          channel as string,",
						"          order_date as timestamp,",
						"          must_ship_by_date as timestamp,",
						"          must_deliver_by_date as timestamp,",
						"          destination_city as string,",
						"          destination_state as string,",
						"          destination_postal_code as string,",
						"          destination_country as string,",
						"          status as string,",
						"          delivery_partner_name as string,",
						"          service_level_name as string,",
						"          fulfillment_service as string,",
						"          total_units as float,",
						"          total_shipping_charge as float,",
						"          total_order_value as float,",
						"          import_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['order_code'],",
						"     format: 'table',",
						"     batchSize: 9530131,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          order_code = {Order ID},",
						"          channel = Channel,",
						"          order_date = {Order Date},",
						"          must_ship_by_date = {Order Actual Ship Date},",
						"          must_deliver_by_date = {Order Due Date},",
						"          destination_postal_code = {Destination Zip Code},",
						"          status = {Order Status},",
						"          delivery_partner_name = Carrier,",
						"          service_level_name = {Service Type},",
						"          total_units = {Order Quantity},",
						"          total_shipping_charge = {Shipment Fees},",
						"          total_order_value = {Order Value},",
						"          organization_id,",
						"          business_unit_id,",
						"          import_date,",
						"          location_code = {Location ID}",
						"     )) ~> OrderHistory"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_order_line_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ORDER_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "orderhistoryraw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "order_history",
								"type": "DatasetReference"
							},
							"name": "OrderHistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "order_line_history",
								"type": "DatasetReference"
							},
							"name": "OrderLineHistory"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "filterbusinessunits"
						},
						{
							"name": "JoinTHTD"
						},
						{
							"name": "RenameColumns"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "SelectOrderHistory"
						},
						{
							"name": "JoinOrderHistory"
						},
						{
							"name": "deriveSpecial"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Order ID} as string,",
						"          {Order Line ID} as string,",
						"          Channel as string,",
						"          {Order Date} as timestamp,",
						"          {Order Original Ship Date} as timestamp,",
						"          {Order Actual Ship Date} as timestamp,",
						"          {Order Due Date} as timestamp,",
						"          {Order Received Date And Time} as timestamp,",
						"          {Order Completed Date and Time} as timestamp,",
						"          {Destination Zip Code} as string,",
						"          {Item Code} as string,",
						"          {Order Quantity} as float,",
						"          {Quantity (UOM) Picked} as string,",
						"          {Order Status} as string,",
						"          Carrier as string,",
						"          {Service Type} as string,",
						"          {Shipment Fees} as float,",
						"          {Order Value} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> orderhistoryraw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"source(output(",
						"          id as integer,",
						"          order_code as string,",
						"          channel as string,",
						"          order_date as timestamp,",
						"          must_ship_by_date as timestamp,",
						"          must_deliver_by_date as timestamp,",
						"          destination_city as string,",
						"          destination_state as string,",
						"          destination_postal_code as string,",
						"          destination_country as string,",
						"          status as string,",
						"          delivery_partner_name as string,",
						"          service_level_name as string,",
						"          fulfillment_service as string,",
						"          total_units as float,",
						"          total_shipping_charge as float,",
						"          total_order_value as float,",
						"          import_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> OrderHistory",
						"orderhistoryraw derive(business_unit_name = split(split(file_name,'/')[4],'_')[2],",
						"          {Ship Quantity} = {Order Quantity}) ~> derivedColumn1",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type==3) ~> filterbusinessunits",
						"derivedColumn1, RenameColumns join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHTD",
						"filterbusinessunits select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RenameColumns",
						"filter1 alterRow(upsertIf(true())) ~> AlterRow1",
						"deriveSpecial filter(not(isNull({Order Value}))) ~> filter1",
						"OrderHistory select(mapColumn(",
						"          order_id = id,",
						"          order_code,",
						"          item_value = total_order_value,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectOrderHistory",
						"JoinTHTD, SelectOrderHistory join({Order ID} == order_code",
						"     && RenameColumns@business_unit_id == SelectOrderHistory@business_unit_id",
						"     && RenameColumns@organization_id == SelectOrderHistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOrderHistory",
						"JoinOrderHistory derive(item_price = round(item_value*.2,2)) ~> deriveSpecial",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          order_id as integer,",
						"          order_line_code as string,",
						"          item_code as string,",
						"          item_name as string,",
						"          item_description as string,",
						"          order_quantity as float,",
						"          ship_quantity as float,",
						"          line_status as string,",
						"          item_price as float,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['order_id','order_line_code'],",
						"     format: 'table',",
						"     batchSize: 57459551,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          order_id,",
						"          order_line_code = {Order Line ID},",
						"          item_code = {Item Code},",
						"          order_quantity = {Order Quantity},",
						"          line_status = {Order Status},",
						"          item_price,",
						"          business_unit_id,",
						"          organization_id,",
						"          ship_quantity = {Ship Quantity}",
						"     )) ~> OrderLineHistory"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_order_status_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ORDER_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "orderhistoryraw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyDetail"
						},
						{
							"dataset": {
								"referenceName": "order_history",
								"type": "DatasetReference"
							},
							"name": "OrderHistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "order_status_history",
								"type": "DatasetReference"
							},
							"name": "OrderStatusHistory"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "filterbusinessunits"
						},
						{
							"name": "JoinTHTD"
						},
						{
							"name": "RenameColumns"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "SelectOrderHistory"
						},
						{
							"name": "JoinOrderHistory"
						},
						{
							"name": "unpivot1"
						},
						{
							"name": "SelectFields"
						},
						{
							"name": "RemoveDuplicates"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Order ID} as string,",
						"          {Order Line ID} as string,",
						"          Channel as string,",
						"          {Order Date} as timestamp,",
						"          {Order Original Ship Date} as timestamp,",
						"          {Order Actual Ship Date} as timestamp,",
						"          {Order Due Date} as timestamp,",
						"          {Order Received Date And Time} as timestamp,",
						"          {Order Completed Date and Time} as timestamp,",
						"          {Destination Zip Code} as string,",
						"          {Item Code} as string,",
						"          {Order Quantity} as float,",
						"          {Quantity (UOM) Picked} as string,",
						"          {Order Status} as string,",
						"          Carrier as string,",
						"          {Service Type} as string,",
						"          {Shipment Fees} as float,",
						"          {Order Value} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> orderhistoryraw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyDetail",
						"source(output(",
						"          id as integer,",
						"          order_code as string,",
						"          channel as string,",
						"          order_date as timestamp,",
						"          must_ship_by_date as timestamp,",
						"          must_deliver_by_date as timestamp,",
						"          destination_city as string,",
						"          destination_state as string,",
						"          destination_postal_code as string,",
						"          destination_country as string,",
						"          status as string,",
						"          delivery_partner_name as string,",
						"          service_level_name as string,",
						"          fulfillment_service as string,",
						"          total_units as float,",
						"          total_shipping_charge as float,",
						"          total_order_value as float,",
						"          import_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> OrderHistory",
						"unpivot1 derive(business_unit_name = split(split(file_name,'/')[4],'_')[2],",
						"          status = iif(\r",
						"    status_grp=='Order Actual Ship Date',\r",
						"    'Shipped',\r",
						"    iif(\r",
						"        status_grp=='Order Received Date And Time',\r",
						"        'Order Received (in Warehouse) Date and time',\r",
						"        iif(\r",
						"            status_grp=='Order Completed Date and Time',\r",
						"            'Order Completed (in Warehouse) Date and Time',\r",
						"            status_grp\r",
						"        )\r",
						"    )\r",
						"),",
						"          status_date = {Order Actual Ship Date}) ~> derivedColumn1",
						"TenantHeirarchyDetail filter(tenant_hierarchy_type==3) ~> filterbusinessunits",
						"derivedColumn1, RenameColumns join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHTD",
						"filterbusinessunits select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RenameColumns",
						"JoinOrderHistory alterRow(upsertIf(true())) ~> AlterRow1",
						"OrderHistory select(mapColumn(",
						"          order_id = id,",
						"          order_code,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectOrderHistory",
						"JoinTHTD, SelectOrderHistory join({Order ID} == order_code",
						"     && RenameColumns@business_unit_id == SelectOrderHistory@business_unit_id",
						"     && RenameColumns@organization_id == SelectOrderHistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOrderHistory",
						"SelectFields unpivot(output(",
						"          status_grp as string,",
						"          {Order Actual Ship Date} as timestamp,",
						"          {Order Received Date And Time} as timestamp,",
						"          {Order Completed Date and Time} as timestamp",
						"     ),",
						"     ungroupBy({Order ID},",
						"          file_name),",
						"     lateral: true,",
						"     ignoreNullPivots: false) ~> unpivot1",
						"RemoveDuplicates select(mapColumn(",
						"          {Order ID},",
						"          {Order Actual Ship Date},",
						"          {Order Received Date And Time},",
						"          {Order Completed Date and Time},",
						"          file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectFields",
						"orderhistoryraw aggregate(groupBy({Order ID},",
						"          {Order Actual Ship Date},",
						"          {Order Received Date And Time},",
						"          {Order Completed Date and Time},",
						"          file_name),",
						"     {Order Line ID} = countDistinct({Order Line ID})) ~> RemoveDuplicates",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          order_id as integer,",
						"          status as string,",
						"          status_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['order_id','status'],",
						"     format: 'table',",
						"     batchSize: 36396960,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          order_id,",
						"          status,",
						"          status_date,",
						"          business_unit_id = SelectOrderHistory@business_unit_id,",
						"          organization_id = RenameColumns@organization_id",
						"     )) ~> OrderStatusHistory"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_shipment_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SHIPMENT_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "shipmenthistoryraw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchydetail"
						},
						{
							"dataset": {
								"referenceName": "order_line_history",
								"type": "DatasetReference"
							},
							"name": "orderlinetable"
						},
						{
							"dataset": {
								"referenceName": "order_history",
								"type": "DatasetReference"
							},
							"name": "orderhistory"
						},
						{
							"dataset": {
								"referenceName": "order_status_history",
								"type": "DatasetReference"
							},
							"name": "orderstatushistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "shipment_history",
								"type": "DatasetReference"
							},
							"name": "ShipmentHistory"
						}
					],
					"transformations": [
						{
							"name": "derivebusinessunitname"
						},
						{
							"name": "selectthtd"
						},
						{
							"name": "filter1"
						},
						{
							"name": "JoinTHTD"
						},
						{
							"name": "selectorderline"
						},
						{
							"name": "selectorderhistory"
						},
						{
							"name": "JoinOrderLine"
						},
						{
							"name": "JoinOrderHistory"
						},
						{
							"name": "filtershipmentstatus"
						},
						{
							"name": "JoinOrderShipmentStatusHistory"
						},
						{
							"name": "selectshipmentstatus"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterNotNullRows"
						},
						{
							"name": "RemoveDuplicates"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Shipment ID} as string,",
						"          {Order Line ID} as string,",
						"          {Location ID} as string,",
						"          {Carrier Name} as string,",
						"          Mode as string,",
						"          {Total Units} as float,",
						"          {Total Shipment Weight} as float,",
						"          {Total Shipment Volume} as float,",
						"          {Total Shipment Cost} as float,",
						"          {Total Shipment Value} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> shipmenthistoryraw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchydetail",
						"source(output(",
						"          order_id as integer,",
						"          order_line_code as string,",
						"          item_code as string,",
						"          item_name as string,",
						"          item_description as string,",
						"          order_quantity as float,",
						"          ship_quantity as float,",
						"          line_status as string,",
						"          item_price as float,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> orderlinetable",
						"source(output(",
						"          id as integer,",
						"          order_code as string,",
						"          channel as string,",
						"          order_date as timestamp,",
						"          must_ship_by_date as timestamp,",
						"          must_deliver_by_date as timestamp,",
						"          destination_city as string,",
						"          destination_state as string,",
						"          destination_postal_code as string,",
						"          destination_country as string,",
						"          status as string,",
						"          delivery_partner_name as string,",
						"          service_level_name as string,",
						"          fulfillment_service as string,",
						"          total_units as float,",
						"          total_shipping_charge as float,",
						"          total_order_value as float,",
						"          import_date as timestamp,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> orderhistory",
						"source(output(",
						"          order_id as integer,",
						"          status as string,",
						"          status_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> orderstatushistory",
						"shipmenthistoryraw derive(business_unit_name = split(split(file_name,'/')[4],\"_\")[2]) ~> derivebusinessunitname",
						"filter1 select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectthtd",
						"tenantheirarchydetail filter(tenant_hierarchy_type==3) ~> filter1",
						"derivebusinessunitname, selectthtd join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHTD",
						"orderlinetable select(mapColumn(",
						"          order_id,",
						"          order_line_code,",
						"          line_status,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectorderline",
						"orderhistory select(mapColumn(",
						"          order_id = id,",
						"          order_code,",
						"          order_date,",
						"          service_level_name,",
						"          must_deliver_by_date,",
						"          status,",
						"          import_date,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectorderhistory",
						"JoinTHTD, selectorderline join({Order Line ID} == order_line_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOrderLine",
						"JoinOrderLine, selectorderhistory join(selectorderline@order_id == selectorderhistory@order_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOrderHistory",
						"orderstatushistory filter(status=='Shipped') ~> filtershipmentstatus",
						"JoinOrderHistory, selectshipmentstatus join(selectorderline@order_id == selectshipmentstatus@order_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinOrderShipmentStatusHistory",
						"filtershipmentstatus select(mapColumn(",
						"          order_id,",
						"          shipment_date = status_date,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectshipmentstatus",
						"RemoveDuplicates alterRow(upsertIf(true())) ~> AlterRow1",
						"JoinOrderShipmentStatusHistory filter(not(isNull({Carrier Name}))&& not(isNull(service_level_name))) ~> FilterNotNullRows",
						"FilterNotNullRows aggregate(groupBy({Shipment ID},",
						"          order_code,",
						"          {Carrier Name},",
						"          service_level_name,",
						"          status,",
						"          shipment_date,",
						"          {Location ID},",
						"          import_date,",
						"          selectthtd@business_unit_id,",
						"          selectthtd@organization_id),",
						"     {Total Units} = toFloat(sum({Total Units})),",
						"          {Total Shipment Weight} = toFloat(avg({Total Shipment Weight})),",
						"          {Total Shipment Volume} = toFloat(avg({Total Shipment Volume})),",
						"          {Total Shipment Cost} = toFloat(sum({Total Shipment Cost}))) ~> RemoveDuplicates",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          shipment_code as string,",
						"          order_code as string,",
						"          delivery_partner_name as string,",
						"          service_level as string,",
						"          status as string,",
						"          shipment_date as timestamp,",
						"          total_units as float,",
						"          total_weight as float,",
						"          total_volume as float,",
						"          total_cost as float,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          import_date as timestamp,",
						"          location_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['shipment_code'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          shipment_code = {Shipment ID},",
						"          order_code,",
						"          delivery_partner_name = {Carrier Name},",
						"          service_level = service_level_name,",
						"          status,",
						"          shipment_date,",
						"          total_units = {Total Units},",
						"          total_weight = {Total Shipment Weight},",
						"          total_volume = {Total Shipment Volume},",
						"          total_cost = {Total Shipment Cost},",
						"          business_unit_id,",
						"          organization_id,",
						"          import_date,",
						"          location_code = {Location ID}",
						"     )) ~> ShipmentHistory"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_shipment_line_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SHIPMENT_HISTORY_RAW",
								"type": "DatasetReference"
							},
							"name": "shipmenthistoryraw"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchytable"
						},
						{
							"dataset": {
								"referenceName": "order_line_history",
								"type": "DatasetReference"
							},
							"name": "orderlinehistory"
						},
						{
							"dataset": {
								"referenceName": "shipment_history",
								"type": "DatasetReference"
							},
							"name": "shipmenthistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "shipment_line_history",
								"type": "DatasetReference"
							},
							"name": "ShipmentLineHistory"
						}
					],
					"transformations": [
						{
							"name": "derivebusinessunitname"
						},
						{
							"name": "FilterBusinessUnit"
						},
						{
							"name": "SelectTHD"
						},
						{
							"name": "JoinTHDT"
						},
						{
							"name": "SelectOLH"
						},
						{
							"name": "JoinSLH2OLH"
						},
						{
							"name": "SelectSH"
						},
						{
							"name": "JoinSH2SLH"
						},
						{
							"name": "AlterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Shipment ID} as string,",
						"          {Order Line ID} as string,",
						"          {Location ID} as string,",
						"          {Carrier Name} as string,",
						"          Mode as string,",
						"          {Total Units} as float,",
						"          {Total Shipment Weight} as float,",
						"          {Total Shipment Volume} as float,",
						"          {Total Shipment Cost} as float,",
						"          {Total Shipment Value} as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     rowUrlColumn: 'file_name') ~> shipmenthistoryraw",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchytable",
						"source(output(",
						"          order_id as integer,",
						"          order_line_code as string,",
						"          item_code as string,",
						"          item_name as string,",
						"          item_description as string,",
						"          order_quantity as float,",
						"          ship_quantity as float,",
						"          line_status as string,",
						"          item_price as float,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> orderlinehistory",
						"source(output(",
						"          id as integer,",
						"          shipment_code as string,",
						"          order_code as string,",
						"          delivery_partner_name as string,",
						"          service_level as string,",
						"          status as string,",
						"          shipment_date as timestamp,",
						"          total_units as float,",
						"          total_weight as float,",
						"          total_volume as float,",
						"          total_cost as float,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          import_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> shipmenthistory",
						"shipmenthistoryraw derive(business_unit_name = split(split(file_name,'/')[4],\"_\")[2]) ~> derivebusinessunitname",
						"tenantheirarchytable filter(tenant_hierarchy_type==3) ~> FilterBusinessUnit",
						"FilterBusinessUnit select(mapColumn(",
						"          business_unit_id = id,",
						"          name,",
						"          tenant_id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectTHD",
						"derivebusinessunitname, SelectTHD join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHDT",
						"orderlinehistory select(mapColumn(",
						"          order_id,",
						"          order_line_code,",
						"          item_code,",
						"          item_name,",
						"          ship_quantity,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectOLH",
						"JoinSH2SLH, SelectOLH join({Order Line ID} == order_line_code",
						"     && SelectTHD@business_unit_id == SelectOLH@business_unit_id",
						"     && SelectTHD@organization_id == SelectOLH@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinSLH2OLH",
						"shipmenthistory select(mapColumn(",
						"          shipment_id = id,",
						"          shipment_code,",
						"          order_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectSH",
						"JoinTHDT, SelectSH join({Shipment ID} == shipment_code",
						"     && SelectTHD@business_unit_id == SelectSH@business_unit_id",
						"     && SelectTHD@organization_id == SelectSH@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinSH2SLH",
						"JoinSLH2OLH alterRow(upsertIf(true())) ~> AlterRow1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          shipment_id as integer,",
						"          shipment_line_code as string,",
						"          order_code as string,",
						"          order_line_code as string,",
						"          item_code as string,",
						"          item_name as string,",
						"          units as float,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['order_code','order_line_code'],",
						"     format: 'table',",
						"     batchSize: 4000000,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          shipment_id,",
						"          shipment_line_code = shipment_code,",
						"          order_code,",
						"          order_line_code,",
						"          item_code,",
						"          item_name,",
						"          units = {Total Units},",
						"          business_unit_id = SelectOLH@business_unit_id,",
						"          organization_id = SelectTHD@organization_id",
						"     )) ~> ShipmentLineHistory"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_throughput_predictions')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "THROUGHPUT_PREDICTIONS_RAW",
								"type": "DatasetReference"
							},
							"name": "throughtputoutput"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyTable"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "LocationsTable"
						},
						{
							"dataset": {
								"referenceName": "enum_types",
								"type": "DatasetReference"
							},
							"name": "EnumTypeDB"
						},
						{
							"dataset": {
								"referenceName": "enum_values",
								"type": "DatasetReference"
							},
							"name": "EnumValue"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "operational_calendar",
								"type": "DatasetReference"
							},
							"name": "WriteToDatabase"
						}
					],
					"transformations": [
						{
							"name": "SelectedColsThroughput"
						},
						{
							"name": "DeriveAttributes"
						},
						{
							"name": "THTSelected"
						},
						{
							"name": "JoinTHT"
						},
						{
							"name": "FinalSelectThroughputPredictions"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "LocationsSelected"
						},
						{
							"name": "JoinLocationsTable"
						},
						{
							"name": "JoinEnumLocationMetricType"
						},
						{
							"name": "FilterEnumLocationMetricType"
						},
						{
							"name": "JoinLocationMetricTypeEnum"
						},
						{
							"name": "FilterBURecords"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Prop_0 as string,",
						"          date as date,",
						"          unit_volume as string,",
						"          capacity as string,",
						"          picker_capacity as string,",
						"          packer_capacity as string,",
						"          total_work_hours as string,",
						"          inventory_level as string,",
						"          throughput_preds as decimal(10,0)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: true,",
						"     rowUrlColumn: 'file_name',",
						"     mode: 'read') ~> throughtputoutput",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyTable",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> LocationsTable",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EnumTypeDB",
						"source(output(",
						"          id as integer,",
						"          enum_type_id as integer,",
						"          value_id as integer,",
						"          value as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EnumValue",
						"throughtputoutput select(mapColumn(",
						"          date,",
						"          throughput_preds,",
						"          file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectedColsThroughput",
						"SelectedColsThroughput derive(location_code = split(split(file_name,'/')[4],'_')[2],",
						"          business_unit_name = split(split(file_name,'/')[4],'_')[1],",
						"          location_metric_type = \"Throughput\") ~> DeriveAttributes",
						"FilterBURecords select(mapColumn(",
						"          id,",
						"          name,",
						"          tenant_id,",
						"          parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> THTSelected",
						"DeriveAttributes, THTSelected join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTHT",
						"JoinLocationMetricTypeEnum select(mapColumn(",
						"          location_id,",
						"          business_unit_id = THTSelected@id,",
						"          organization_id = parent_id,",
						"          date,",
						"          location_metric_value = throughput_preds,",
						"          location_metric_type_id = value_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> FinalSelectThroughputPredictions",
						"FinalSelectThroughputPredictions alterRow(upsertIf(true())) ~> AlterRow1",
						"LocationsTable select(mapColumn(",
						"          location_id = id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LocationsSelected",
						"JoinTHT, LocationsSelected join(DeriveAttributes@location_code == LocationsSelected@location_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocationsTable",
						"FilterEnumLocationMetricType, EnumValue join(EnumTypeDB@id == enum_type_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinEnumLocationMetricType",
						"EnumTypeDB filter(name=='location_metric_type') ~> FilterEnumLocationMetricType",
						"JoinLocationsTable, JoinEnumLocationMetricType join(location_metric_type == value,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocationMetricTypeEnum",
						"TenantHeirarchyTable filter(tenant_hierarchy_type==3) ~> FilterBURecords",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          location_id as integer,",
						"          date as date,",
						"          location_metric_value as decimal(0,0),",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          enum_value_id as integer,",
						"          enum_type_id as integer,",
						"          operational_profile_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['location_id','date','location_metric_type_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          business_unit_id,",
						"          organization_id,",
						"          location_id,",
						"          date,",
						"          location_metric_value,",
						"          location_metric_type_id",
						"     )) ~> WriteToDatabase"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transform_current_backlog')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CurrentBacklogMain",
								"type": "DatasetReference"
							},
							"name": "currentbacklogmain"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "current_backlog_table",
								"type": "DatasetReference"
							},
							"name": "sinkcurrentbacklog"
						}
					],
					"transformations": [
						{
							"name": "derivecolumns"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "fulfillmentservicesselect"
						},
						{
							"name": "joinfulfillmentservices"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/CurrentBacklog/86.txt'),",
						"     transaction_id as string ('86')",
						"}",
						"source(output(",
						"          {Fulfillment Location ID*} as string,",
						"          {Fulfillment Service*} as string,",
						"          {Backlog Date*} as date,",
						"          {Backlog Units} as long,",
						"          {Backlog Orders} as long,",
						"          {Units per Order} as float",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> currentbacklogmain",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"currentbacklogmain derive(transaction_id = toInteger($transaction_id)) ~> derivecolumns",
						"importhistory select(mapColumn(",
						"          import_history_id = id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"derivecolumns, selectimporthistory join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory, selectlocations join({Fulfillment Location ID*} == location_code",
						"     && selectimporthistory@business_unit_id == selectlocations@business_unit_id",
						"     && selectimporthistory@organization_id == selectlocations@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"locations select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"fulfillmentservices select(mapColumn(",
						"          fulfillment_service_id = id,",
						"          service_name,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> fulfillmentservicesselect",
						"joinlocations, fulfillmentservicesselect join({Fulfillment Service*} == service_name",
						"     && selectlocations@business_unit_id == fulfillmentservicesselect@business_unit_id",
						"     && selectlocations@organization_id == fulfillmentservicesselect@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinfulfillmentservices",
						"joinfulfillmentservices sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          backlog_date as date,",
						"          open_backlog_units as long,",
						"          open_backlog_orders as long,",
						"          average_upo as float,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          organization_id,",
						"          business_unit_id = selectimporthistory@business_unit_id,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          backlog_date = {Backlog Date*},",
						"          open_backlog_units = {Backlog Units},",
						"          open_backlog_orders = {Backlog Orders},",
						"          average_upo = {Units per Order}",
						"     )) ~> sinkcurrentbacklog"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transform_fulfillment_forecast_ux')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "FulfillmentForecastMain",
								"type": "DatasetReference"
							},
							"name": "fulfillmentforecastmain"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "fulfillment_forecast",
								"type": "DatasetReference"
							},
							"name": "sinkfulfillmentforecast"
						}
					],
					"transformations": [
						{
							"name": "derivecolumns"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "fulfillmentservicesselect"
						},
						{
							"name": "joinfulfillmentservices"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/FulfillmentForecast/338.txt'),",
						"     transaction_id as string ('338')",
						"}",
						"source(output(",
						"          {Fulfillment Location ID*} as string,",
						"          {Fulfillment Service*} as string,",
						"          {Forecast Date*} as date,",
						"          {Forecast 1 Units} as long,",
						"          {Forecast 1 Orders} as long,",
						"          {Forecast 2 Units} as float,",
						"          {Forecast 2 Orders} as long,",
						"          {Units per Order} as long,",
						"          {Forecast Locked Date} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> fulfillmentforecastmain",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"fulfillmentforecastmain derive(transaction_id = toInteger($transaction_id)) ~> derivecolumns",
						"importhistory select(mapColumn(",
						"          import_history_id = id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"derivecolumns, selectimporthistory join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory, selectlocations join({Fulfillment Location ID*} == location_code",
						"     && selectimporthistory@business_unit_id == selectlocations@business_unit_id",
						"     && selectimporthistory@organization_id == selectlocations@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"locations select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"fulfillmentservices select(mapColumn(",
						"          fulfillment_service_id = id,",
						"          service_name,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> fulfillmentservicesselect",
						"joinlocations, fulfillmentservicesselect join({Fulfillment Service*} == service_name",
						"     && selectimporthistory@business_unit_id == fulfillmentservicesselect@business_unit_id",
						"     && selectimporthistory@organization_id == fulfillmentservicesselect@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinfulfillmentservices",
						"joinfulfillmentservices sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          forecast_date as date,",
						"          locked_forecast_units as long,",
						"          current_forecast_units as long,",
						"          average_upo as float,",
						"          locked_forecast_orders as long,",
						"          current_forecast_orders as long,",
						"          forecast_locked_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          forecast_3_units as long,",
						"          forecast_3_orders as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          organization_id,",
						"          business_unit_id,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          forecast_date = {Forecast Date*},",
						"          locked_forecast_units = {Forecast 1 Units},",
						"          current_forecast_units = {Forecast 2 Units},",
						"          average_upo = {Units per Order},",
						"          locked_forecast_orders = {Forecast 1 Orders},",
						"          current_forecast_orders = {Forecast 2 Orders},",
						"          forecast_locked_date = {Forecast Locked Date}",
						"     )) ~> sinkfulfillmentforecast"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transform_inventory')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "INVENTORY_MAIN_UX",
								"type": "DatasetReference"
							},
							"name": "inventorymain",
							"description": "inventory main"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "item",
								"type": "DatasetReference"
							},
							"name": "item"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchydetail"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "inventory",
								"type": "DatasetReference"
							},
							"name": "sinkinventory"
						}
					],
					"transformations": [
						{
							"name": "derivecolumns"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "itemselect"
						},
						{
							"name": "joinitem",
							"description": "Inner join on 'joinlocations' and 'item'"
						},
						{
							"name": "jointhtd"
						},
						{
							"name": "filterburecords"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/Inventory/211.txt'),",
						"     transaction_id as string ('211')",
						"}",
						"source(output(",
						"          {Item ID} as string,",
						"          {Location ID} as string,",
						"          {Stock Date} as date,",
						"          {Stock Quantity} as float,",
						"          {Reserved Quantity} as float,",
						"          {Available Quantity} as float,",
						"          {On Order ID} as string,",
						"          {On Order Due Date} as date,",
						"          {On Order Supplier Shipping Date} as date,",
						"          {On Order Promised Delivery Date} as date",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> inventorymain",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          item_code as string,",
						"          description as string,",
						"          short_description as string,",
						"          department as string,",
						"          sub_department as string,",
						"          class as string,",
						"          sub_class as string,",
						"          style as string,",
						"          color as string,",
						"          size as string,",
						"          size_second as string,",
						"          sku_lifecycle_status as integer,",
						"          product_division as string,",
						"          product_family as string,",
						"          measurement_unit as string,",
						"          unit_cost as float,",
						"          unit_volume as float,",
						"          unit_weight as float,",
						"          unit_cube as float,",
						"          units_per_pallet as float,",
						"          uom_conversion_factor as float,",
						"          distribution_channel as string,",
						"          item_handling_type as string,",
						"          item_unit_price as float,",
						"          minimum_sales_qty as float,",
						"          birth_year as short,",
						"          birth_month as short,",
						"          expiration_year as short,",
						"          expiration_month as short,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> item",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchydetail",
						"inventorymain derive(transaction_id = toInteger($transaction_id),",
						"          stock_type_id = 1) ~> derivecolumns",
						"jointhtd select(mapColumn(",
						"          import_history_id = importhistory@id,",
						"          business_unit_id,",
						"          organization_id,",
						"          tenant_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"derivecolumns, selectimporthistory join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory, selectlocations join({Location ID} == location_code",
						"     && selectimporthistory@organization_id == selectlocations@organization_id",
						"     && selectimporthistory@business_unit_id == selectlocations@business_unit_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"locations select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"item select(mapColumn(",
						"          item_id = id,",
						"          item_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> itemselect",
						"joinlocations, itemselect join({Item ID} == item_code",
						"     && selectimporthistory@business_unit_id == itemselect@business_unit_id",
						"     && selectimporthistory@organization_id == itemselect@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinitem",
						"importhistory, filterburecords join(business_unit_id == tenantheirarchydetail@id",
						"     && organization_id == parent_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointhtd",
						"tenantheirarchydetail filter(tenant_hierarchy_type==3) ~> filterburecords",
						"joinitem sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          item_id as integer,",
						"          location_id as integer,",
						"          on_hand_stock_date as date,",
						"          on_hand_stock_quantity as float,",
						"          reserved_on_hold_stock_ as float,",
						"          available_stock as float,",
						"          lot_id as string,",
						"          on_order_due_date as date,",
						"          on_order_quantity_ as float,",
						"          purchase_order_status as float,",
						"          on_order_supplier_shipping_date as date,",
						"          on_order_promised_delivery_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          stock_type_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          item_id,",
						"          location_id,",
						"          on_hand_stock_date = {Stock Date},",
						"          on_hand_stock_quantity = {Stock Quantity},",
						"          reserved_on_hold_stock_ = {Reserved Quantity},",
						"          available_stock = {Available Quantity},",
						"          lot_id = {On Order ID},",
						"          on_order_due_date = {On Order Due Date},",
						"          on_order_supplier_shipping_date = {On Order Supplier Shipping Date},",
						"          on_order_promised_delivery_date = {On Order Promised Delivery Date},",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id = selectimporthistory@business_unit_id,",
						"          stock_type_id",
						"     )) ~> sinkinventory"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transform_location_staffing')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LocationStaffingMain",
								"type": "DatasetReference"
							},
							"name": "locationstaffingmain"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "enum_values",
								"type": "DatasetReference"
							},
							"name": "enumvalue"
						},
						{
							"dataset": {
								"referenceName": "operationalprofile",
								"type": "DatasetReference"
							},
							"name": "operationalprofile"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "operational_calendar",
								"type": "DatasetReference"
							},
							"name": "sinkopeartionalcalendar"
						}
					],
					"transformations": [
						{
							"name": "derivecolumns"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "colsselectenumvalue"
						},
						{
							"name": "filterenumvalues"
						},
						{
							"name": "joinenumvalues"
						},
						{
							"name": "operationalprofileselect"
						},
						{
							"name": "joinoperationalprofile"
						},
						{
							"name": "selectcols"
						},
						{
							"name": "filtertransaction"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/LocationStaffing/439.txt'),",
						"     transaction_id as string ('439')",
						"}",
						"source(output(",
						"          {Profile Name*} as string,",
						"          {Location ID*} as string,",
						"          {Date*} as date,",
						"          {Metric_Name*} as string,",
						"          {Value*} as decimal(10,0),",
						"          validation_errors as string,",
						"          errors_count as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> locationstaffingmain",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          enum_type_id as integer,",
						"          value_id as integer,",
						"          value as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> enumvalue",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> operationalprofile",
						"locationstaffingmain derive(transaction_id = toInteger($transaction_id)) ~> derivecolumns",
						"filtertransaction select(mapColumn(",
						"          import_history_id = id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"derivecolumns, selectimporthistory join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory, selectlocations join({Location ID*} == location_code",
						"     && selectimporthistory@business_unit_id == selectlocations@business_unit_id",
						"     && selectimporthistory@organization_id == selectlocations@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"locations select(mapColumn(",
						"          location_id = id,",
						"          location_code,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"filterenumvalues select(mapColumn(",
						"          enum_type_id,",
						"          value_id,",
						"          value",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> colsselectenumvalue",
						"enumvalue filter(enum_type_id==4) ~> filterenumvalues",
						"joinlocations, colsselectenumvalue join(lower({Metric_Name*}) == lower(value),",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinenumvalues",
						"operationalprofile select(mapColumn(",
						"          operational_profile_id = id,",
						"          name,",
						"          organization_id,",
						"          business_unit_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> operationalprofileselect",
						"joinenumvalues, operationalprofileselect join({Profile Name*} == name",
						"     && selectimporthistory@business_unit_id == operationalprofileselect@business_unit_id",
						"     && selectlocations@organization_id == operationalprofileselect@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinoperationalprofile",
						"joinoperationalprofile select(mapColumn(",
						"          {Date*},",
						"          {Value*},",
						"          import_history_id,",
						"          business_unit_id = selectimporthistory@business_unit_id,",
						"          organization_id = selectimporthistory@organization_id,",
						"          location_id,",
						"          enum_type_id,",
						"          value_id,",
						"          operational_profile_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcols",
						"importhistory filter(id == toInteger($transaction_id)) ~> filtertransaction",
						"selectcols sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          business_unit_id as string,",
						"          organization_id as string,",
						"          location_id as integer,",
						"          date as date,",
						"          location_metric_value as decimal(0,0),",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          enum_value_id as integer,",
						"          enum_type_id as integer,",
						"          operational_profile_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          business_unit_id,",
						"          organization_id,",
						"          location_id,",
						"          date = {Date*},",
						"          location_metric_value = {Value*},",
						"          enum_value_id = value_id,",
						"          enum_type_id,",
						"          operational_profile_id",
						"     )) ~> sinkopeartionalcalendar"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transform_location_ux')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LocationsMain",
								"type": "DatasetReference"
							},
							"name": "locationmain"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						},
						{
							"dataset": {
								"referenceName": "location_type",
								"type": "DatasetReference"
							},
							"name": "locationtype"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "tenantheirarchydetail"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "sinklocation"
						}
					],
					"transformations": [
						{
							"name": "derivecolumns"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocationtypes"
						},
						{
							"name": "joinTHTD"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/Location/198.txt'),",
						"     transaction_id as string ('198')",
						"}",
						"source(output(",
						"          {Location ID*} as string,",
						"          {Location Name} as string,",
						"          Address as string,",
						"          City as string,",
						"          State as string,",
						"          Zip as string,",
						"          Country as string,",
						"          Longitude as double,",
						"          Latitude as double,",
						"          {Location Status} as string,",
						"          {Location Type} as string,",
						"          {Daily Throughput} as float,",
						"          {Storage Capacity} as float,",
						"          {Inbound Handling Cost} as float,",
						"          {Outbound Handling Cost} as float,",
						"          {Inbound Processing Time} as decimal(10,0),",
						"          {Outbound Processing Time} as decimal(10,0),",
						"          {Transfer Inbound Processing Time} as double,",
						"          {Transfer Outbound Processing Time} as double,",
						"          {Transfer Inbound Handling Cost} as double,",
						"          {Transfer Outbound Handling Cost} as double,",
						"          {Units per Hour} as float,",
						"          {Max FTE Regular Hours} as float,",
						"          {Min FTE Regular Hours} as float,",
						"          {Max Temp Regular Hours} as float,",
						"          {Min Temp Regular Hours} as float,",
						"          {Regular FTE Wage} as float,",
						"          {Regular Temp Wage} as float,",
						"          {Overtime FTE Wage} as float,",
						"          {Overtime Temp Wage} as float,",
						"          {FTE Staff Count} as integer,",
						"          {Temp Staff Count} as integer",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> locationmain",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"source(output(",
						"          id as integer,",
						"          name as string,",
						"          description as string,",
						"          created_date as date,",
						"          updated_date as date,",
						"          display_icon as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locationtype",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tenantheirarchydetail",
						"locationmain derive(transaction_id = toInteger($transaction_id)) ~> derivecolumns",
						"joinTHTD select(mapColumn(",
						"          import_history_id = importhistory@id,",
						"          business_unit_id,",
						"          organization_id,",
						"          tenant_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"derivecolumns, selectimporthistory join(transaction_id == import_history_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"joinimporthistory, selectlocationtypes join({Location Type} == location_type_name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"locationtype select(mapColumn(",
						"          location_type_id = id,",
						"          location_type_name = name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocationtypes",
						"importhistory, tenantheirarchydetail join(business_unit_id == tenantheirarchydetail@id",
						"     && organization_id == parent_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinTHTD",
						"joinlocations sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          location_code = {Location ID*},",
						"          name = {Location Name},",
						"          address = Address,",
						"          city = City,",
						"          state = State,",
						"          zip = Zip,",
						"          country = Country,",
						"          throughput = {Daily Throughput},",
						"          capacity = {Storage Capacity},",
						"          inbound_handling_cost = {Inbound Handling Cost},",
						"          outbound_handling_cost = {Outbound Handling Cost},",
						"          longitude = Longitude,",
						"          latitude = Latitude,",
						"          status = {Location Status},",
						"          inbound_processing_time = {Inbound Processing Time},",
						"          outbound_processing_time = {Outbound Processing Time},",
						"          type = location_type_id,",
						"          transfer_inbound_processing_time = {Transfer Inbound Processing Time},",
						"          transfer_outbound_processing_time = {Transfer Outbound Processing Time},",
						"          transfer_inbound_handling_cost = {Transfer Inbound Handling Cost},",
						"          transfer_outbound_handling_cost = {Transfer Outbound Handling Cost},",
						"          tenant_id,",
						"          organization_id,",
						"          business_unit_id,",
						"          units_per_hour = {Units per Hour},",
						"          max_fte_regular_hours = {Max FTE Regular Hours},",
						"          min_fte_regular_hours = {Min FTE Regular Hours},",
						"          max_temp_regular_hours = {Max Temp Regular Hours},",
						"          min_temp_regular_hours = {Min Temp Regular Hours},",
						"          max_fte_overtime_hours = {Max FTE Regular Hours},",
						"          max_temp_overtime_hours = {Max FTE Regular Hours},",
						"          regular_fte_wage = {Regular FTE Wage},",
						"          regular_temp_wage = {Regular Temp Wage},",
						"          overtime_fte_wage = {Overtime FTE Wage},",
						"          overtime_temp_wage = {Overtime Temp Wage},",
						"          fte_staff_count = {FTE Staff Count},",
						"          temp_staff_count = {Temp Staff Count}",
						"     )) ~> sinklocation"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_transportation_lane')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Data flow edited on 2023-08-08 on bringing in attributes from filename and using lookup to fetch organization_id and business_unit_id",
				"folder": {
					"name": "main"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ZONE_RAW",
								"type": "DatasetReference"
							},
							"name": "RawDataForZone",
							"description": "source data stored in datalake-\"radial-demo-data\" for populating pfp.zone table\n"
						},
						{
							"dataset": {
								"referenceName": "tenant_heirarchy_table",
								"type": "DatasetReference"
							},
							"name": "TenantHeirarchyTable",
							"description": "Data from tenant_heirarchy_table"
						},
						{
							"dataset": {
								"referenceName": "TRANSIT_TIME_RAW",
								"type": "DatasetReference"
							},
							"name": "TransitTimeTable",
							"description": "Transit time table data"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "LocationsTable"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "transportation_lane",
								"type": "DatasetReference"
							},
							"name": "WriteToDatabase",
							"description": "Write Records To transportation_lanes table"
						}
					],
					"transformations": [
						{
							"name": "DerivingAttributes",
							"description": "Deriving attributes for fields like origin_start, origin_end, business_unit_name from filename, static value for delivery_partner_id"
						},
						{
							"name": "MappingColumns",
							"description": "Final step in data transformation to select specific columns, renaming certain columns to match the zone table schema"
						},
						{
							"name": "JoinHeirarchyTable"
						},
						{
							"name": "JoinTransitTime"
						},
						{
							"name": "DeriveAttributesTransitTable"
						},
						{
							"name": "JoinLocations"
						},
						{
							"name": "SelectColumnsHeirarchyTable",
							"description": "Select columns relevant for downstream actviites"
						},
						{
							"name": "SelectColumnsRawData",
							"description": "select the relevant columns alone from RawDataZone"
						},
						{
							"name": "SelectColumnsLocationTable",
							"description": "Select relavant columns"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "FilterBUrecords"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Dest. ZIP} as string,",
						"          {Ground - ZONE} as string,",
						"          {3 Day Select} as string,",
						"          {2nd Day Air} as string,",
						"          {2nd Day Air A.M.} as string,",
						"          {Next Day Air Saver} as string,",
						"          {Next Day Air} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: true,",
						"     rowUrlColumn: 'file_name') ~> RawDataForZone",
						"source(output(",
						"          id as string,",
						"          tenant_hierarchy_type as integer,",
						"          name as string,",
						"          contact_name as string,",
						"          email as string,",
						"          phone as string,",
						"          street_address_1 as string,",
						"          street_address_2 as string,",
						"          city as string,",
						"          state as string,",
						"          zip as integer,",
						"          country as string,",
						"          active as boolean,",
						"          tenant_id as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          parent_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TenantHeirarchyTable",
						"source(output(",
						"          Zones as string,",
						"          {Transit Time} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name_transit') ~> TransitTimeTable",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> LocationsTable",
						"SelectColumnsRawData derive(origin_zip = split(split(file_name,\"/\")[4],\"_\")[2],",
						"          business_unit_name = split(split(file_name,\"/\")[4],\"_\")[1],",
						"          origin_country = 'US',",
						"          destination_country = 'US',",
						"          zone = toInteger({Ground - ZONE}),",
						"          organization_id := \"8078acfb-eca6-4708-b197-694f50a24c92\",",
						"          business_unit_id := \"994dc35f-7eba-4f6e-918b-7bd311482d7b\",",
						"          local1 := \"8078acfb-eca6-4708-b197-694f50a24c92\") ~> DerivingAttributes",
						"JoinLocations select(mapColumn(",
						"          delivery_partner_id,",
						"          rate_code,",
						"          service_type,",
						"          origin_location_code = location_code,",
						"          origin_zip,",
						"          origin_country,",
						"          destination_zip = {Dest. ZIP},",
						"          destination_country,",
						"          transit_time = {Transit Time},",
						"          zone,",
						"          business_unit_id = id,",
						"          organization_id = parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> MappingColumns",
						"DerivingAttributes, SelectColumnsHeirarchyTable join(business_unit_name == name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinHeirarchyTable",
						"JoinHeirarchyTable, DeriveAttributesTransitTable join({Ground - ZONE} == Zones,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinTransitTime",
						"TransitTimeTable derive(delivery_partner_id = split(split(file_name_transit,\"/\")[4],\"_\")[2],",
						"          service_type = split(split(file_name_transit,\"/\")[4],\"_\")[3],",
						"          rate_code = split(split(file_name_transit,\"/\")[4],\"_\")[2]+'-'+split(split(file_name_transit,\"/\")[4],\"_\")[3]+\"-\"+Zones) ~> DeriveAttributesTransitTable",
						"JoinTransitTime, SelectColumnsLocationTable join(origin_zip == toString(zip_code),",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> JoinLocations",
						"FilterBUrecords select(mapColumn(",
						"          id,",
						"          name,",
						"          parent_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumnsHeirarchyTable",
						"RawDataForZone select(mapColumn(",
						"          {Dest. ZIP},",
						"          {Ground - ZONE},",
						"          file_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumnsRawData",
						"LocationsTable select(mapColumn(",
						"          zip_code = id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumnsLocationTable",
						"MappingColumns alterRow(upsertIf(true())) ~> AlterRow1",
						"TenantHeirarchyTable filter(tenant_hierarchy_type==3) ~> FilterBUrecords",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          delivery_partner_id as string,",
						"          rate_code as string,",
						"          fulfillment_service_type as string,",
						"          service_type as string,",
						"          origin_location_code as integer,",
						"          origin_address as string,",
						"          origin_city as string,",
						"          origin_state as string,",
						"          origin_zip as string,",
						"          origin_country as string,",
						"          destination_location_code as integer,",
						"          destination_address as string,",
						"          destination_city as string,",
						"          destination_state as string,",
						"          destination_zip as string,",
						"          destination_country as string,",
						"          transit_time as integer,",
						"          zone as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['rate_code','origin_zip','destination_zip'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     preCommands: [],",
						"     postCommands: []) ~> WriteToDatabase"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_validation_current_backlog')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CURRENT_BACKLOG_UX_STAGING",
								"type": "DatasetReference"
							},
							"name": "currentbackloguxuploadstaging"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices",
							"description": "Import data from fulfillment services"
						},
						{
							"dataset": {
								"referenceName": "current_backlog_table",
								"type": "DatasetReference"
							},
							"name": "currentbacklog"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "current_backlog_table",
								"type": "DatasetReference"
							},
							"name": "ValidCurrentBacklog"
						},
						{
							"dataset": {
								"referenceName": "FailedValidationRowsCurrentBacklog",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "validations"
						},
						{
							"name": "reverserename"
						},
						{
							"name": "deriveerrors"
						},
						{
							"name": "selectmainfields"
						},
						{
							"name": "aggregateerrors"
						},
						{
							"name": "joinaggregaterror"
						},
						{
							"name": "splitvalidatedrows"
						},
						{
							"name": "derivedfilename"
						},
						{
							"name": "newchangenameforassert"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "selectfulfillmentservices"
						},
						{
							"name": "derivepresence"
						},
						{
							"name": "joinforecastservices"
						},
						{
							"name": "selectexistrecordcheck"
						},
						{
							"name": "joinexistrecordchech"
						},
						{
							"name": "selectcolsforassert"
						},
						{
							"name": "joincurrentbacklog"
						},
						{
							"name": "filtertransaction"
						},
						{
							"name": "joinbuorglocation"
						},
						{
							"name": "joinbuorgfservice"
						},
						{
							"name": "joinbuorgcbacklog"
						},
						{
							"name": "recordid"
						},
						{
							"name": "detectduplicates"
						},
						{
							"name": "filterrowswithvalidationerrors"
						},
						{
							"name": "filteremptyrows"
						},
						{
							"name": "alterRow1"
						},
						{
							"name": "dervietranscolumn"
						},
						{
							"name": "joinimporthistory"
						},
						{
							"name": "selectimporthistory"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/CurrentBacklog/580.xlsx'),",
						"     transaction_id as string ('580')",
						"}",
						"source(output(",
						"          {Fulfillment Location ID*} as string,",
						"          {Fulfillment Service*} as string,",
						"          {Backlog Date*} as date,",
						"          {Backlog Units} as string,",
						"          {Backlog Orders} as string,",
						"          {Units per Order} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> currentbackloguxuploadstaging",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as decimal(0,0),",
						"          latitude as decimal(0,0),",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"source(output(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          backlog_date as date,",
						"          open_backlog_units as long,",
						"          open_backlog_orders as long,",
						"          average_upo as float,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> currentbacklog",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"filteremptyrows, selectlocations, selectfulfillmentservices assert(expectTrue(not(isNull(Fulfillment_Location_ID))&&not(isNull(Fulfillment_Service))&&not(isNull(Backlog_Date)), false, 'nullvalues', null, 'Null Values Found In Mandatory Fields'),",
						"     expectExists(Fulfillment_Location_ID == location_code, false, 'locationexist', null, 'Location ID Not Found In Database'),",
						"     expectExists(Fulfillment_Service == service_name, false, 'serviceexist', null, 'Fulfillment Service Does Not Exists In Database'),",
						"     expectTrue(isNull(presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
						"     expectTrue(iif(isNull(Backlog_Units),true(),not(isNull(toFloat(Backlog_Units))))&& iif(isNull(Backlog_Orders),true(),not(isNull(toFloat(Backlog_Orders)))) && iif(isNull(Units_per_Order),true(),not(isNull(toFloat(Units_per_Order)))), false, 'nonnumericvals', null, 'Non numeric values present in record for numeric fields'),",
						"     expectTrue(nonduplicatedrow, false, 'duplicaterecords', null, 'Duplicate Records Found In The Upload'),",
						"     expectTrue(iif ( (toFloat(Backlog_Units) < 0) || (toFloat(Backlog_Orders) < 0) || (toFloat(Units_per_Order) < 0), false(), true() ), false, 'negativenumbers', null, 'Negative values present in record for numeric fields')) ~> validations",
						"validations select(mapColumn(",
						"          {Fulfillment Location ID*} = Fulfillment_Location_ID,",
						"          {Fulfillment Service*} = Fulfillment_Service,",
						"          {Backlog Date*} = Backlog_Date,",
						"          {Backlog Units} = Backlog_Units,",
						"          {Backlog Orders} = Backlog_Orders,",
						"          {Units per Order} = Units_per_Order,",
						"          file_name,",
						"          recordid,",
						"          location_id = selectcolsforassert@location_id,",
						"          fulfillment_service_id = selectcolsforassert@fulfillment_service_id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> reverserename",
						"reverserename derive(validation_errors = assertErrorMessages(),",
						"          transaction_id = toInteger($transaction_id),",
						"          sink_file_name = replace(file_name,'.xlsx','.txt'),",
						"          {Backlog Units} = toLong({Backlog Units}),",
						"          {Backlog Orders} = toLong({Backlog Orders}),",
						"          {Units per Order} = toFloat({Units per Order})) ~> deriveerrors",
						"joinaggregaterror select(mapColumn(",
						"          {Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Backlog Date*},",
						"          {Backlog Units},",
						"          {Backlog Orders},",
						"          {Units per Order},",
						"          file_name = reverserename@file_name,",
						"          validation_errors,",
						"          transaction_id,",
						"          sink_file_name,",
						"          file_name = aggregateerrors@file_name,",
						"          errors_count,",
						"          recordid,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectmainfields",
						"deriveerrors aggregate(groupBy(file_name),",
						"     errors_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
						"deriveerrors, aggregateerrors join(reverserename@file_name == aggregateerrors@file_name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinaggregaterror",
						"selectmainfields split(errors_count==0,",
						"     disjoint: false) ~> splitvalidatedrows@(validrows, validationfailedrows)",
						"filterrowswithvalidationerrors derive(failed_file_name = replace(replace($file_path,'/Upload/','/FailedTransactions/'),'.xlsx','.json'),",
						"          type = 'error',",
						"          message = concat('record number ',toString(recordid),' has following errors ',toString(validation_errors))) ~> derivedfilename",
						"detectduplicates select(mapColumn(",
						"          Fulfillment_Location_ID = {Fulfillment Location ID*},",
						"          Fulfillment_Service = {Fulfillment Service*},",
						"          Backlog_Date = {Backlog Date*},",
						"          Backlog_Units = {Backlog Units},",
						"          Backlog_Orders = {Backlog Orders},",
						"          Units_per_Order = {Units per Order},",
						"          file_name,",
						"          recordid,",
						"          nonduplicatedrow",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> newchangenameforassert",
						"joinimporthistory, selectlocations join({Fulfillment Location ID*} == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"joinbuorglocation select(mapColumn(",
						"          location_id = locations@id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"joinbuorgfservice select(mapColumn(",
						"          fulfillment_service_id = fulfillmentservices@id,",
						"          service_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectfulfillmentservices",
						"joinbuorgcbacklog derive(presence = 'true') ~> derivepresence",
						"joinlocations, selectfulfillmentservices join({Fulfillment Service*} == service_name,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinforecastservices",
						"joincurrentbacklog select(mapColumn(",
						"          {Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Backlog Date*},",
						"          {Backlog Units},",
						"          {Backlog Orders},",
						"          {Units per Order},",
						"          file_name,",
						"          presence,",
						"          recordid,",
						"          location_id = selectlocations@location_id,",
						"          fulfillment_service_id = selectfulfillmentservices@fulfillment_service_id,",
						"          business_unit_id = selectimporthistory@business_unit_id,",
						"          organization_id = selectimporthistory@organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectexistrecordcheck",
						"newchangenameforassert, selectexistrecordcheck join(newchangenameforassert@recordid == selectexistrecordcheck@recordid,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinexistrecordchech",
						"joinexistrecordchech select(mapColumn(",
						"          Fulfillment_Location_ID,",
						"          Fulfillment_Service,",
						"          Backlog_Date,",
						"          Backlog_Units,",
						"          Backlog_Orders,",
						"          Units_per_Order,",
						"          file_name = selectexistrecordcheck@file_name,",
						"          presence,",
						"          nonduplicatedrow,",
						"          recordid = selectexistrecordcheck@recordid,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcolsforassert",
						"joinforecastservices, derivepresence join(selectlocations@location_id == currentbacklog@location_id",
						"     && selectfulfillmentservices@fulfillment_service_id == currentbacklog@fulfillment_service_id",
						"     && {Backlog Date*} == toDate(toString(backlog_date)),",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joincurrentbacklog",
						"importhistory filter(id==toInteger($transaction_id)) ~> filtertransaction",
						"locations, filtertransaction join(locations@business_unit_id == importhistory@business_unit_id",
						"     && locations@organization_id == importhistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinbuorglocation",
						"fulfillmentservices, filtertransaction join(fulfillmentservices@business_unit_id == importhistory@business_unit_id",
						"     && fulfillmentservices@organization_id == importhistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinbuorgfservice",
						"currentbacklog, filtertransaction join(currentbacklog@business_unit_id == importhistory@business_unit_id",
						"     && currentbacklog@organization_id == importhistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinbuorgcbacklog",
						"currentbackloguxuploadstaging keyGenerate(output(recordid as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> recordid",
						"recordid window(over({Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Backlog Date*},",
						"          file_name),",
						"     asc(recordid, true),",
						"     nonduplicatedrow = rowNumber() == 1) ~> detectduplicates",
						"splitvalidatedrows@validationfailedrows filter(not(isNull(validation_errors))) ~> filterrowswithvalidationerrors",
						"selectcolsforassert filter(not(isNull(Fulfillment_Location_ID)) || not(isNull(Fulfillment_Service)) || not(isNull(Backlog_Date)) || not(isNull(Backlog_Units)) || not(isNull(Backlog_Orders)) || not(isNull(Units_per_Order))) ~> filteremptyrows",
						"splitvalidatedrows@validrows alterRow(insertIf(true())) ~> alterRow1",
						"recordid derive(transaction_id = toInteger($transaction_id)) ~> dervietranscolumn",
						"dervietranscolumn, selectimporthistory join(transaction_id == id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinimporthistory",
						"filtertransaction select(mapColumn(",
						"          id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          backlog_date as date,",
						"          open_backlog_units as long,",
						"          open_backlog_orders as long,",
						"          average_upo as float,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          organization_id,",
						"          business_unit_id,",
						"          location_id,",
						"          fulfillment_service_id,",
						"          backlog_date = {Backlog Date*},",
						"          open_backlog_units = {Backlog Units},",
						"          open_backlog_orders = {Backlog Orders},",
						"          average_upo = {Units per Order}",
						"     ),",
						"     preCommands: [],",
						"     postCommands: []) ~> ValidCurrentBacklog",
						"derivedfilename sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_validation_fulfillment_forecast')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "FULFILLMENT_FORECAST_UX_STAGING",
								"type": "DatasetReference"
							},
							"name": "fulfillmentforecastuxstaging"
						},
						{
							"dataset": {
								"referenceName": "locations",
								"type": "DatasetReference"
							},
							"name": "locations"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_services",
								"type": "DatasetReference"
							},
							"name": "fulfillmentservices",
							"description": "Import data from fulfillment services"
						},
						{
							"dataset": {
								"referenceName": "fulfillment_forecast",
								"type": "DatasetReference"
							},
							"name": "fulfillmentforecast"
						},
						{
							"dataset": {
								"referenceName": "importhistory",
								"type": "DatasetReference"
							},
							"name": "importhistory"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "FulfillmentForecastMain",
								"type": "DatasetReference"
							},
							"name": "ValidFulfillmentForecast"
						},
						{
							"dataset": {
								"referenceName": "FailedFulfillementRowsJson",
								"type": "DatasetReference"
							},
							"name": "failedrows"
						}
					],
					"transformations": [
						{
							"name": "validations"
						},
						{
							"name": "reverserename"
						},
						{
							"name": "deriveerrors"
						},
						{
							"name": "selectmainfields"
						},
						{
							"name": "aggregateerrors"
						},
						{
							"name": "joinaggregaterror"
						},
						{
							"name": "splitvalidatedrows"
						},
						{
							"name": "derivedfilename"
						},
						{
							"name": "newchangenameforassert"
						},
						{
							"name": "joinlocations"
						},
						{
							"name": "selectlocations"
						},
						{
							"name": "selectfulfillmentservices"
						},
						{
							"name": "derivepresence"
						},
						{
							"name": "joinforecastservices"
						},
						{
							"name": "selectexistrecordcheck"
						},
						{
							"name": "joinexistrecordchech"
						},
						{
							"name": "selectcolsforassert"
						},
						{
							"name": "joinfulfillmentforecast"
						},
						{
							"name": "numericalfieldintegritycheck"
						},
						{
							"name": "appendrecordid"
						},
						{
							"name": "filter1"
						},
						{
							"name": "selectimporthistory"
						},
						{
							"name": "jointransactionbuorglocation"
						},
						{
							"name": "jointransbuorgfservice"
						},
						{
							"name": "jointransbuorgfforecast"
						},
						{
							"name": "detectduplicates"
						},
						{
							"name": "filterrowswithvalidationerrors"
						},
						{
							"name": "filteremptyrows"
						}
					],
					"scriptLines": [
						"parameters{",
						"     file_path as string ('/DEV/Upload/FulfillmentForecast/460.xlsx'),",
						"     transaction_id as string ('460')",
						"}",
						"source(output(",
						"          {Forecast Date*} as date,",
						"          {Forecast 1 Units} as string,",
						"          {Forecast 1 Orders} as string,",
						"          {Forecast 2 Units} as string,",
						"          {Units per Order} as string,",
						"          {Forecast Locked Date} as date,",
						"          {Fulfillment Service*} as string,",
						"          {Fulfillment Location ID*} as string,",
						"          {Forecast 2 Orders} as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: true,",
						"     ignoreNoFilesFound: false,",
						"     rowUrlColumn: 'file_name',",
						"     wildcardPaths:[($file_path)]) ~> fulfillmentforecastuxstaging",
						"source(output(",
						"          id as integer,",
						"          location_code as string,",
						"          name as string,",
						"          address as string,",
						"          city as string,",
						"          state as string,",
						"          zip as string,",
						"          country as string,",
						"          sub_type as string,",
						"          delivery_partners as string,",
						"          throughput as float,",
						"          capacity as float,",
						"          special_information as string,",
						"          holding_cost as float,",
						"          inbound_handling_cost as float,",
						"          outbound_handling_cost as float,",
						"          longitude as double,",
						"          latitude as double,",
						"          updated_date as date,",
						"          created_date as date,",
						"          status as string,",
						"          inbound_processing_time as decimal(0,0),",
						"          outbound_processing_time as decimal(0,0),",
						"          type as integer,",
						"          transfer_inbound_processing_time as double,",
						"          transfer_outbound_processing_time as double,",
						"          transfer_inbound_handling_cost as double,",
						"          transfer_outbound_handling_cost as double,",
						"          tenant_id as string,",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          units_per_hour as float,",
						"          max_fte_regular_hours as float,",
						"          min_fte_regular_hours as float,",
						"          max_temp_regular_hours as float,",
						"          min_temp_regular_hours as float,",
						"          max_fte_overtime_hours as float,",
						"          max_temp_overtime_hours as float,",
						"          regular_fte_wage as float,",
						"          regular_temp_wage as float,",
						"          overtime_fte_wage as float,",
						"          overtime_temp_wage as float,",
						"          fte_staff_count as integer,",
						"          temp_staff_count as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> locations",
						"source(output(",
						"          id as integer,",
						"          fulfillment_service_code as string,",
						"          service_name as string,",
						"          service_type as string,",
						"          delivery_speed_value as float,",
						"          delivery_speed_unit as string,",
						"          service_radius_value as float,",
						"          service_radius_unit as string,",
						"          service_charge as float,",
						"          deployment_type as string,",
						"          created_date as timestamp,",
						"          updated_date as timestamp,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentservices",
						"source(output(",
						"          organization_id as string,",
						"          business_unit_id as string,",
						"          location_id as integer,",
						"          fulfillment_service_id as integer,",
						"          forecast_date as date,",
						"          locked_forecast_units as long,",
						"          current_forecast_units as long,",
						"          average_upo as float,",
						"          locked_forecast_orders as long,",
						"          current_forecast_orders as long,",
						"          forecast_locked_date as date,",
						"          created_date as timestamp,",
						"          updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> fulfillmentforecast",
						"source(output(",
						"          id as integer,",
						"          original_file_name as string,",
						"          user_id as string,",
						"          status_enum_value_id as integer,",
						"          processed_time as timestamp,",
						"          errors as string,",
						"          business_unit_id as string,",
						"          organization_id as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> importhistory",
						"filteremptyrows, selectlocations, selectfulfillmentservices assert(expectTrue(not(isNull(Fulfillment_Location_ID))&&not(isNull(Fulfillment_Service))&&not(isNull(Forecast_Date)), false, 'nullvalues', null, 'Null Values Found In Mandatory Fields'),",
						"     expectExists(Fulfillment_Location_ID == location_code, false, 'locationexist', null, 'Location ID Not Found In Database'),",
						"     expectExists(Fulfillment_Service == service_name, false, 'profileexist', null, 'Fulfillment Service Does Not Exists In Database'),",
						"     expectTrue(isNull(presence), false, 'checkrecordexists', null, 'Record Already Exists In DB'),",
						"     expectTrue(numericalintegrity, false, 'numericalfieldintegrity', null, 'Numerical Fields Contains Non Numeric Values'),",
						"     expectTrue(nonduplicatedrow, false, 'duplicateddata', null, 'Duplicate Records Found In Upload')) ~> validations",
						"validations select(mapColumn(",
						"          {Fulfillment Location ID*} = Fulfillment_Location_ID,",
						"          {Fulfillment Service*} = Fulfillment_Service,",
						"          {Forecast Date*} = Forecast_Date,",
						"          {Forecast 1 Units} = Forecast_1_Units,",
						"          {Forecast 1 Orders} = Forecast_1_Orders,",
						"          {Forecast 2 Units} = Forecast_2_Units,",
						"          {Forecast 2 Orders} = Forecast_2_Orders,",
						"          {Units per Order} = Units_per_Order,",
						"          {Forecast Locked Date} = Forecast_Locked_Date,",
						"          file_name,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> reverserename",
						"reverserename derive(validation_errors = assertErrorMessages(),",
						"          transaction_id = toInteger($transaction_id),",
						"          sink_file_name = replace(file_name,'.xlsx','.txt')) ~> deriveerrors",
						"joinaggregaterror select(mapColumn(",
						"          {Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Forecast Date*},",
						"          {Forecast 1 Units},",
						"          {Forecast 1 Orders},",
						"          {Forecast 2 Units},",
						"          {Forecast 2 Orders},",
						"          {Units per Order},",
						"          {Forecast Locked Date},",
						"          file_name = reverserename@file_name,",
						"          validation_errors,",
						"          transaction_id,",
						"          sink_file_name,",
						"          errors_count,",
						"          record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectmainfields",
						"deriveerrors aggregate(groupBy(file_name),",
						"     errors_count = countIf(not(isNull(validation_errors)))) ~> aggregateerrors",
						"deriveerrors, aggregateerrors join(reverserename@file_name == aggregateerrors@file_name,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinaggregaterror",
						"selectmainfields split(errors_count==0,",
						"     disjoint: false) ~> splitvalidatedrows@(validrows, validationfailedrows)",
						"filterrowswithvalidationerrors derive(failed_file_name = replace(replace($file_path,'/Upload/','/FailedTransactions/'),'.xlsx','.json'),",
						"          type = 'error',",
						"          message = concat('record number ',toString(record_id),' has following errors ',toString(validation_errors))) ~> derivedfilename",
						"numericalfieldintegritycheck select(mapColumn(",
						"          Fulfillment_Location_ID = {Fulfillment Location ID*},",
						"          Fulfillment_Service = {Fulfillment Service*},",
						"          Forecast_Date = {Forecast Date*},",
						"          Forecast_1_Units = {Forecast 1 Units},",
						"          Forecast_1_Orders = {Forecast 1 Orders},",
						"          Forecast_2_Units = {Forecast 2 Units},",
						"          Forecast_2_Orders = {Forecast 2 Orders},",
						"          Units_per_Order = {Units per Order},",
						"          Forecast_Locked_Date = {Forecast Locked Date},",
						"          file_name,",
						"          numericalintegrity,",
						"          record_id,",
						"          nonduplicatedrow",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> newchangenameforassert",
						"appendrecordid, selectlocations join({Fulfillment Location ID*} == location_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinlocations",
						"jointransactionbuorglocation select(mapColumn(",
						"          location_id = locations@id,",
						"          location_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectlocations",
						"jointransbuorgfservice select(mapColumn(",
						"          fulfillment_service_id = fulfillmentservices@id,",
						"          service_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectfulfillmentservices",
						"jointransbuorgfforecast derive(presence = 'true') ~> derivepresence",
						"joinlocations, selectfulfillmentservices join({Fulfillment Service*} == service_name,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinforecastservices",
						"joinfulfillmentforecast select(mapColumn(",
						"          file_name,",
						"          record_id,",
						"          presence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectexistrecordcheck",
						"newchangenameforassert, selectexistrecordcheck join(newchangenameforassert@record_id == selectexistrecordcheck@record_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinexistrecordchech",
						"joinexistrecordchech select(mapColumn(",
						"          Fulfillment_Location_ID,",
						"          Fulfillment_Service,",
						"          Forecast_Date,",
						"          Forecast_1_Units,",
						"          Forecast_1_Orders,",
						"          Forecast_2_Units,",
						"          Forecast_2_Orders,",
						"          Units_per_Order,",
						"          Forecast_Locked_Date,",
						"          file_name = newchangenameforassert@file_name,",
						"          file_name = selectexistrecordcheck@file_name,",
						"          presence,",
						"          numericalintegrity,",
						"          nonduplicatedrow,",
						"          record_id = selectexistrecordcheck@record_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcolsforassert",
						"joinforecastservices, derivepresence join(selectlocations@location_id == fulfillmentforecast@location_id",
						"     && selectfulfillmentservices@fulfillment_service_id == fulfillmentforecast@fulfillment_service_id",
						"     && {Forecast Date*} == toDate(toString(forecast_date)),",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinfulfillmentforecast",
						"detectduplicates derive(numericalintegrity = iif(isNull({Forecast 1 Units}),true(),not(isNull(toFloat({Forecast 1 Units})))) && iif(isNull({Forecast 1 Orders}),true(),not(isNull(toFloat({Forecast 1 Orders})))) && iif(isNull({Forecast 2 Units}),true(),not(isNull(toFloat({Forecast 2 Units})))) && iif(isNull({Forecast 2 Orders}),true(),not(isNull(toFloat({Forecast 2 Orders})))) && iif(isNull({Units per Order}),true(),not(isNull(toFloat({Units per Order}))))) ~> numericalfieldintegritycheck",
						"fulfillmentforecastuxstaging keyGenerate(output(record_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> appendrecordid",
						"importhistory filter(id == toInteger($transaction_id)) ~> filter1",
						"filter1 select(mapColumn(",
						"          id,",
						"          business_unit_id,",
						"          organization_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectimporthistory",
						"locations, selectimporthistory join(locations@business_unit_id == selectimporthistory@business_unit_id",
						"     && locations@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransactionbuorglocation",
						"fulfillmentservices, selectimporthistory join(fulfillmentservices@business_unit_id == selectimporthistory@business_unit_id",
						"     && fulfillmentservices@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransbuorgfservice",
						"fulfillmentforecast, selectimporthistory join(fulfillmentforecast@business_unit_id == selectimporthistory@business_unit_id",
						"     && fulfillmentforecast@organization_id == selectimporthistory@organization_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> jointransbuorgfforecast",
						"appendrecordid window(over(file_name,",
						"          {Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Forecast Date*},",
						"          {Forecast Locked Date}),",
						"     asc(record_id, true),",
						"     nonduplicatedrow = rowNumber() == 1) ~> detectduplicates",
						"splitvalidatedrows@validationfailedrows filter(not(isNull(validation_errors))) ~> filterrowswithvalidationerrors",
						"selectcolsforassert filter(not(isNull(Fulfillment_Location_ID)) || not(isNull(Fulfillment_Service)) || not(isNull(Forecast_Date)) || not(isNull(Forecast_1_Units)) || not(isNull(Forecast_1_Orders)) || not(isNull(Forecast_2_Units)) || not(isNull(Forecast_Locked_Date)) || not(isNull(Units_per_Order))) ~> filteremptyrows",
						"splitvalidatedrows@validrows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          {Fulfillment Location ID*} as string,",
						"          {Fulfillment Service*} as string,",
						"          {Forecast Date*} as string,",
						"          {Forecast 1 Units} as string,",
						"          {Forecast 1 Orders} as string,",
						"          {Forecast 2 Units} as string,",
						"          {Forecast 2 Orders} as string,",
						"          {Units per Order} as string,",
						"          {Forecast Locked Date} as string",
						"     ),",
						"     rowUrlColumn:'sink_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          {Fulfillment Location ID*},",
						"          {Fulfillment Service*},",
						"          {Forecast Date*},",
						"          {Forecast 1 Units},",
						"          {Forecast 1 Orders},",
						"          {Forecast 2 Units},",
						"          {Forecast 2 Orders},",
						"          {Units per Order},",
						"          {Forecast Locked Date}",
						"     )) ~> ValidFulfillmentForecast",
						"derivedfilename sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     rowUrlColumn:'failed_file_name',",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          type,",
						"          message",
						"     )) ~> failedrows"
					]
				}
			},
			"dependsOn": []
		}
	]
}